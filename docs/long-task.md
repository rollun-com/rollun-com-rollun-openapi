# Long task

Long task (лонг таск) - це ресурс, який є реалізацією скінченого автомата, що виконує якусь протяжну у часі дію. 

## Стани лонг таска
Long task має стани. Кожен стан лонг таску однозначно описується полем `stage`. Значення, які це поле може приймати, 
повинні бути описані в маніфесті.

Серед станів лонг таску можна виділити початкові та кінцеві.

*Початкові стани* - ті в які лонг таск може потрапити після свого створення. 

*Кінцеві стани* - це такі стани, після потрапляння в які, зміна стану лонг таска більше не можлива.

Лонг таск обов'язково починає своє виконання з одного з початкових станів та закінчує кінцевим.

Також лонг таск може мати додаткові поля. Набір цих полів залежить від стейджу лонг таску. Але значення цих полів
не впливають на стан лонг таску як скінченного автомата (тобто стан лонг таску як скінченного автомату описується
лише полем `stage`). На прикладі нижче таким додатковим полем є `orderId`, яке з'являється при `sucess` стейджі.

Серед таких полів є поле `status` - яке обов'язкове не залежно від стейджу, та може приймати три значення:
- `pending` - якщо лонг таск НЕ в кінцевому стані
- `fulfilled` - якщо лонг таск в кінцевому стані і його виконання завершилось успішно
- `rejected` - якщо лонг таск в кінцевому стані і його виконання завершилось невдало

Кожен стейдж однозначно відповідає одному зі статусів.

Поле `problem` у форматі [RFC-7807](https://www.rfc-editor.org/rfc/rfc7807) (приклад з нашої специфікації [тут](https://github.com/rollun-com/rollun-openapi/blob/specification/docs/questions.md#1162-%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82-%D0%BE%D0%BF%D0%B8%D1%81%D1%83-%D0%BF%D0%BE%D0%BC%D0%B8%D0%BB%D0%BA%D0%B8)) 
є обов'язковим при статусі `rejected`

Приклад лонг таску по створенню замовлення.

![Order creating stages](img/specification/creating-order-stages.jpg)

## Створення лонг таску

Створення лонг таску - це завжди синхронна операція. Тобто ми відправляємо POST запит, та у відповідь отримуємо
код 200 OK та вже створенний ресурс лонг таску. 

Лонг таск може повернутись відразу у кінцевому статусі. Це не означає, що лонг таск пропустив початкові значення та 
створився відразу в кінцевому. Лонг таск в будь-якому випадку пройшовся по ланцюжку від початкового до кінцевого стану,
просто це відбулось досить швидко щоб у відповідь на створення лонг таска синхронно повернути його відразу в кінцевому
стані.

На майбутнє ми залишаємо до розгляду варіант, коли створення лонг таску може бути асинхронною операцією. В цьому випадку 
ми б у відповідь на POST запит отримали б код 202 Accepted та ідентифікатор ресурсу через який можна відстежувати стан 
виконання операції. Але поки що вважаємо, що створення лонг таску - завжди синхронна операція.

## Ідемпотентність лонг таску

При створенні лонг таску обов'язково передається ключ ідемпотентності. Тоді повторний запит на створення лонг таску з 
цим самим ключем вже не створить лонг таск, а або поверне помилку 409 Conflict, або екземпляр, вже створенного минулим 
запитом, лонг таску. Це залежить від реалізації сервера.

Тут працює правило один ключ ідемпотнентності - один екземпляр лонг таску. Тому, якщо, наприклад, виконання задачі 
завершилось помилкою, що призвело до rejected статусу, то цей лонг таск вже не можна ніяк змінити (тому що rejected - 
кінцевий стан) та, наприклад, спробувати його перезапустити. Єдиний шлях повторно спробувати виконати дію - це створити 
новий лонг таск з новим ключем ідемпотентності.

## Перехід між стейджами лонг таску

Стейджі лонг таску можуть змінюватись як сервером, що виконує лонг таск, так і клієнтом, якщо це допустимо.

// TODO: Зміна стейджів клієнтом
1. PUT чи POST запит?
2. Сервер разом з лонг таском може надсилати також варіанти переходу до наступного стейджу (фактично HATEOAS)

## Використання etag

Для запобігання паралельного зміни статусу двома клієнтами, або клієнтом та сервером можна застосовувати Etag заголовок
із специфікації http. Детальніше [тут](https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/ETag)