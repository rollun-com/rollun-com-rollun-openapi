# Long task

Long task (лонг таск) - це ресурс, який є реалізацією скінченого автомата, що виконує якусь протяжну у часі дію. 

## Стани лонг таска
Long task має стани. Кожен стан лонг таску однозначно описується полем `stage`. Це поле є обов'язковим в кожному лонг
таску, та значення, які це поле може приймати, повинні бути описані в маніфесті як enum.

Серед станів лонг таску можна виділити початкові та кінцеві.

*Початковий стан* - це той в який лонг таск може потрапити після свого створення. Початковий стан може бути лише один. 

*Кінцеві стани* - це такі стани, після потрапляння в які, зміна стану лонг таска більше не можлива. Кінцевий стані
повинен бути хоча б один.

Лонг таск обов'язково починає своє виконання з одного з початкових станів та закінчує кінцевим.

В маніфесті в описі поля `stage` потрібно зазначити який стан є початковим, та які кінцевими.

Також лонг таск може мати додаткові поля. На прикладі нижче таким додатковим полем є `orderId`, яке з'являється при 
`fulfilled` стейджі.

Окрім `stage` є ще обов'язкове поле `status`, яке може приймати три значення:
- `pending` - якщо лонг таск НЕ в кінцевому стані
- `fulfilled` - якщо лонг таск в кінцевому стані і його виконання завершилось успішно
- `rejected` - якщо лонг таск в кінцевому стані і його виконання завершилось невдало

Кожен стейдж однозначно відповідає одному зі статусів. Якщо лонг такс в кінцевому стейджі, то поле `status` матиме 
значення або `fulfilled` або `rejected`

Якщо немає потреби в детальних стейджах, то поле `stage` може бути рівним полю `status`. Тобто також приймати три
значення: `pending`, `fulfilled` та `rejected`

Поле `problem` у форматі [RFC-7807](https://www.rfc-editor.org/rfc/rfc7807) (приклад з нашої специфікації [тут](https://github.com/rollun-com/rollun-openapi/blob/specification/docs/questions.md#1162-%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82-%D0%BE%D0%BF%D0%B8%D1%81%D1%83-%D0%BF%D0%BE%D0%BC%D0%B8%D0%BB%D0%BA%D0%B8)) 
є обов'язковим при статусі `rejected`

Приклад лонг таску по створенню замовлення.

![Order creating stages](img/specification/creating-order-stages.jpg)

## Створення лонг таску

Створення лонг таску - це завжди синхронна операція. У відповідь на створення лонг таску ми отримуємо лише його 
ідентифікатор, а не повну сутність.

Example request

```http request
POST /long-tasks/order-creation
Content-Type: application/vnd.rollun-request+json
```

```json
{
  "payload": {
    "to": "WA, Yakima, 1712 Melrose Street, 98908",
    "items": [
      {
        "id": "ABC12",
        "qty": 1
      }
    ]
  }
}
```

Example response

```http
HTTP/1.1 200 OK
Content-Type: application/vnd.rollun+json
```

```json
{
  "data": {
    "id": "qwerty123"
  }
}
```

На майбутнє ми залишаємо до розгляду варіант, коли створення лонг таску може бути асинхронною операцією. В цьому випадку 
ми б у відповідь на POST запит отримали б код 202 Accepted та ідентифікатор ресурсу через який можна відстежувати стан 
виконання операції. Але поки що вважаємо, що створення лонг таску - завжди синхронна операція.

## Ідемпотентність лонг таску

При створенні лонг таску обов'язково передається ключ ідемпотентності. Тоді повторний запит на створення лонг таску з 
цим самим ключем вже не створить лонг таск, а або поверне помилку 409 Conflict, або екземпляр, вже створенного минулим 
запитом, лонг таску. Це залежить від реалізації сервера.

Тут працює правило один ключ ідемпотнентності - один екземпляр лонг таску. Тому, якщо, наприклад, виконання задачі 
завершилось помилкою, що призвело до rejected статусу, то цей лонг таск вже не можна ніяк змінити (тому що rejected - 
кінцевий стан) та, наприклад, спробувати його перезапустити. Єдиний шлях повторно спробувати виконати дію - це створити 
новий лонг таск з новим ключем ідемпотентності.

## Перехід між стейджами лонг таску

Стейджі лонг таску можуть змінюватись як сервером, що виконує лонг таск, так і клієнтом, якщо це допустимо.

Клієнт може змінювати стейджі за допомогою http запитів, що завчасно описані в маніфесті. При цьому усі запити повинні 
бути синхронними. Запити можуть бути двох видів:
1. PATCH & PUT запити, що змінюють поля лонг таска.
2. POST /actions/... - екшени, що переводять лонг таск з одного стейджу в інший

При цьому, коли лонг таск переходить в якийсь із стейджів (навіть самого в себе), то на сервері можуть запускатись 
трігери, які також можуть змінити стейдж лонг таску.

Якщо спробувати виконати запит, що не дозволенний в поточному стейджі лонг таску, то повинна повернутись помилка
400 Bad Request.

Наприклад уявімо лонг таск, який описує стани статті. Вона може бути в трьох станах: validationError, readyToPublish, 
published. Поки вона знаходиться в станах validationError та readyToPublish то ми її можемо редагувати за допомогою
PATCH запиту. При цьому після кожного редагування на сервері запуститься трігер який проведе валідацію статті і в 
залежності від результата може змінити її стейдж. Коли стаття в стейджі readyToPublish то ми можемо запустити екшен 
`POST /articles/actions/publish`, що переведе статтю в published стейдж.

![Article stages](img/specification/article-stages.jpg)

## Використання etag

Для запобігання паралельного зміни статусу двома клієнтами, або клієнтом та сервером можна застосовувати Etag заголовок
із специфікації http. Детальніше [тут](https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/ETag)