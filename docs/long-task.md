# Long task

Long task (лонг таск) - це ресурс, який є реалізацією скінченого автомата, що виконує якусь протяжну у часі дію. 

## Стани лонг таска
Long task має стани, серед яких можна виділити початкові та кінцеві. 

*Початкові стани* - ті в які лонг таск може потрапити після свого створення. 

*Кінцеві стани* - це такі стани, після потрапляння в які, зміна стану лонг таска більше не можлива.

Лонг таск обов'язково починає своє виконання з одного з початкових станів та закінчує кінцевим.

Кожен стан лонг таску описується набором полей та їх значень. 

Обов'язкові поля:
- `status` - яке може приймати три значення:
  - `pending` - якщо лонг таск НЕ в кінцевому стані
  - `fulfilled` - якщо лонг таск в кінцевому стані і його виконання завершилось успішно
  - `rejected` - якщо лонг таск в кінцевому стані і його виконання завершилось невдало
- `stage` - детально описує поточний етап виконання лонг таску. Значення, які це поле може приймати, повинні бути описані
в маніфесті. Кожен stage однозначно відповідає якомусь зі статусів. Тобто не можлива ситуація, коли якись stage може 
бути одночасно і fullfiled і pending. Якщо у вас немає потреби в детальному описі етапів виконання лонг таску, то ви 
можете зробити значення поля `stage` рівним значенню поля `status`. Так це буде дублювання інформації, але так зроблено 
для уніфікації інтерфейсу.
- Поле `problem` у форматі [RFC-7807](https://www.rfc-editor.org/rfc/rfc7807) є обов'язковим при статусі `rejected`

Також можуть бути присутні інші поля, спеціфічні для кожного окремого виду лонг таску, що будуть описувати стан задачі.
На прикладі нижче це поле `orderId`, яке з'являється при `fulfilled` статусі.

Приклад лонг таску по створенню замовлення.

![Order creating stages](img/specification/creating-order-stages.jpg)

## Створення лонг таску

Створення лонг таску - це завжди синхронна операція. Тобто ми відправляємо POST запит, та у відповідь отримуємо
код 200 OK та вже створенний ресурс лонг таску. 

Лонг таск може повернутись відразу у кінцевому статусі. Це не означає, що лонг таск пропустив початкові значення та 
створився відразу в кінцевому. Лонг таск в будь-якому випадку пройшовся по ланцюжку від початкового до кінцевого стану,
просто це відбулось досить швидко щоб у відповідь на створення лонг таска синхронно повернути його відразу в кінцевому
стані.

На майбутнє ми залишаємо до розгляду варіант, коли створення лонг таску може бути асинхронною операцією. В цьому випадку 
ми б у відповідь на POST запит отримали б код 202 Accepted та ідентифікатор ресурсу через який можна відстежувати стан 
виконання операції. Але поки що вважаємо, що створення лонг таску - завжди синхронна операція.

## Ідемпотентність лонг таску

При створенні лонг таску обов'язково передається ключ ідемпотентності. Тоді повторний запит на створення лонг таску з 
цим самим ключем вже не створить лонг таск, а або поверне помилку 409 Conflict, або екземпляр, вже створенного минулим 
запитом, лонг таску. Це залежить від реалізації сервера.

Тут працює правило один ключ ідемпотнентності - один екземпляр лонг таску. Тому, якщо, наприклад, виконання задачі 
завершилось помилкою, що призвело до rejected статусу, то цей лонг таск вже не можна ніяк змінити (тому що rejected - 
кінцевий стан) та, наприклад, спробувати його перезапустити. Єдиний шлях повторно спробувати виконати дію - це створити 
новий лонг таск з новим ключем ідемпотентності.

## Перехід між стейджами лонг таску

Стейджі лонг таску можуть змінюватись як сервером, що виконує лонг таск, так і клієнтом, якщо це допустимо.

// TODO: Зміна статусів клієнтом
1. PUT чи POST запит?
2. Сервер разом з лонг таском може надсилати також варіанти переходу до наступного стейджу (фактично HATEOAS)

## Використання etag

Для запобігання паралельного зміни статусу двома клієнтами, або клієнтом та сервером можна застосовувати Etag заголовок
із специфікації http. Детальніше [тут](https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/ETag)