# Зміст:

> Емоджі в заголовку: Узгоджено, Відредаговано, Перенесено в специфікацію

<!-- TOC -->
* [Зміст:](#-)
* [1. Api специфікація](#1-api-)
  * [1.1 Яка різниця між PUT і PATCH запитом? ✅ ❌ ❌](#11----put--patch----)
  * [1.2 Як реалізовувати Actions? ✅ ❌ ❌](#12---actions---)
    * [Чому для виконання довільних екшенів зазвичай використовують POST а не інші http методи](#-------post----http-)
    * [Чи можна використовувати дієслова в URL](#-----url)
    * [HATEOAS AND OPENAPI](#hateoas-and-openapi)
    * [Висновки](#)
  * [1.3 Як виконувати версіонування API? ✅ ❌ ❌](#13----api---)
    * [1.3.1 Підхід до версіонування](#131---)
      * [1.3.1.1 Контроль версій за допомогою User-Agent та Server хедерів](#1311-----user-agent--server-)
      * [1.3.1.2 Контроль версій за допомогою медіа типу](#1312------)
    * [1.3.2 Коли змінювати мажорну версію](#132----)
    * [1.3.3 Коли змінювати мінорну версію](#133----)
    * [1.3.4 Коли змінювати patch версію](#134---patch-)
  * [1.4 Використання lifecycle_token ✅ ❌ ❌](#14--lifecycle_token---)
  * [1.5 Історія виконання лонг-таску  ❌ ❌ ❌](#15-------)
  * [1.6 Рейт ліміти ✅ ❌ ❌](#16-----)
    * [Як можна вказати ліміти по-замовчуванню в маніфесті](#-------)
  * [1.7 Часткове отримання ресурсу? ✅ ❌ ❌](#17------)
  * [1.8 Пагінація ❌ ❌ ❌](#18----)
    * [Offset-based](#offset-based)
    * [Cursor-based](#cursor-based)
    * [Зарезервовані параметри](#-)
      * [Reserved query parameters](#reserved-query-parameters)
      * [Reserved JSON properties](#reserved-json-properties)
    * [Висновки](#)
  * [1.9 Цикл життя лонг таску ✅ ❌ ❌](#19-------)
  * [1.10 Опис медіа типів ✅ ❌ ❌](#110------)
    * [Схема опису](#-)
    * [application/vnd.rollun-request+json](#applicationvndrollun-requestjson)
    * [application/vnd.rollun-metadata+json](#applicationvndrollun-metadatajson)
    * [application/vnd.rollun+json](#applicationvndrollunjson)
    * [application/vnd.rollun-error+json](#applicationvndrollun-errorjson)
    * [application/vnd.rollun-long-task-pending+json](#applicationvndrollun-long-task-pendingjson)
  * [1.11 Що повинні повертати запити, якщо інформація про лонг-таск видалено ✅ ❌ ❌](#111-------------)
  * [1.12 Яка інформація повинна передаватись в messages ✅ ❌ ❌](#112------messages---)
  * [1.13 Опис серверів в маніфесті ❌ ❌ ❌](#113-------)
  * [1.14 Як працювати з маніфестами при розробці ✅ ❌ ❌](#114---------)
    * [Чи вказувати локальні сервери в маніфесті?](#-----)
  * [1.15 Rql support ❌ ❌ ❌](#115-rql-support---)
    * [Намагатись записати rql в форматі ключ=значення](#--rql---)
    * [Описувати rql через кастомний атрибут](#-rql---)
  * [1.16 Обробка помилок](#116--)
    * [1.16.1 Значення статус коду](#1161---)
    * [1.16.2 Формат опису помилки](#1162---)
    * [1.16.3 Попередження](#1163-)
    * [1.16.4 Стандартні типи помилок](#1164---)
      * [1.16.4.1 InputValidationProblem](#11641-inputvalidationproblem)
      * [1.16.4.2 Missing Permission](#11642-missing-permission)
      * [1.16.4.3 Resource Not Found](#11643-resource-not-found)
      * [1.16.4.4 Too Many Requests](#11644-too-many-requests)
      * [1.16.4.5 Internal Server Error](#11645-internal-server-error)
      * [1.16.4.6 Bad Gateway](#11646-bad-gateway)
      * [1.16.4.6 Service Unavailable](#11646-service-unavailable)
      * [1.16.4.7 Gateway Timeout](#11647-gateway-timeout)
    * [1.16.5 Помилки, що не мають http відповіді](#1165-----http-)
    * [1.16.6 Помилки автозакупки](#1166--)
    * [1.16.7 Попередження автозакупки](#1167--)
* [2. Openapi генератор](#2-openapi-)
  * [2.1 Архітектура ❌ ❌ ❌](#21----)
    * [Різниця між генерацією для сервера і клієнта](#------)
    * [Http рівень](#http-)
    * [Openapi рівень](#openapi-)
      * [Конвертація: `Psr\Request` -> `Openapi\Request`](#--psrrequest----openapirequest)
      * [Конвертація: `Openapi\Response` -> `Psr\Request`](#--openapiresponse----psrrequest)
      * [Валідація схем](#-)
    * [Конвертація схеми в правила валідації на етапі генерації](#-------)
    * [Конвертація схеми в правила валідації під час виконання коду](#--------)
    * [Rollun layer](#rollun-layer)
      * [Конвертація `Openapi\Request` -> `Rollun\Request`](#-openapirequest----rollunrequest)
        * [Створення `Query`](#-query)
        * [Створення `Command`](#-command)
        * [Інформація з заголовків та cookie](#----cookie)
      * [Конвертація `Result` -> `Openapi\Response`](#-result----openapiresponse)
    * [Взаємодія на одному рівні](#---)
  * [2.2 Вибір сервера ❌ ❌ ❌](#22-----)
    * [Генерація server enum](#-server-enum)
  * [2.3 Шлях до згенерованого коду ✅ ❌ ❌](#23-------)
  * [2.4 Конфігурація ❌ ❌ ❌](#24----)
    * [Збір конфігурації](#-)
    * [Конфігурація роутера](#-)
  * [2.5 Авторизація ❌ ❌ ❌](#25----)
    * [Опис авторизації в маніфесті](#---)
    * [Які методи авторизації ми будемо використовувати](#-----)
    * [Генерація серверу](#-)
    * [Генерація клієнту](#-)
  * [2.6 Поліморфізм ❌ ❌ ❌](#26----)
  * [2.7 Організація схем, що використовуються у декількох маніфестах ❌ ❌ ❌](#27----------)
  * [2.8 Як спростити пошук реалізації маніфеста? ❌ ❌ ❌](#28--------)
  * [2.9 Назви класів, методів ❌ ❌ ❌](#29------)
  * [2.10 Підтримка rql ❌ ❌ ❌](#210--rql---)
  * [2.11 Підтримка медіа типів ❌ ❌ ❌](#211------)
  * [2.12 Підтримка рейт лімітів ❌ ❌ ❌](#212------)
  * [2.13 Обробка помилок ❌ ❌ ❌](#213-----)
  * [2.14 Кешування ❌ ❌ ❌](#214----)
  * [2.15 Лонг таски ❌ ❌ ❌](#215-----)
<!-- TOC -->

# 1. Api специфікація

## 1.1 Яка різниця між PUT і PATCH запитом? ✅ ❌ ❌

Різниця між запитами PUT і PATCH відображається в тому, як сервер обробляє об’єкт, щоб змінити ресурс, 
ідентифікований за допомогою Request-URI. PUT запит містить об’єкт, що вважається модифікованою версією ресурсу,
який зберігається на сервері, і клієнт просить замінити збережену версію. В PATCH вкладений об’єкт 
містить набір інструкцій, що описують, як ресурс, який зараз знаходиться на вихідному сервері, повинен бути змінений 
для створення нової версії. Метод PATCH МОЖЕ мати побічні ефекти на інші ресурси; тобто нові ресурси можуть бути 
створені або можуть бути змінені існуючі за допомогою застосування виправлення.

PATCH МОЖЕ створити новий ресурс залежно від типу patch документу.

PATCH описує набір змін в «patch документі», що визначається за допомогою media-type в хедері Content-Type. Хоча явно ніде не написано, але
в загальному випадку application/json - не являється patch документом. Адже сервер ніяк не зможе зрозуміти яким чином
йому змінювати ресурс.

Patch документ зазвичай може приймати одну з двох форм:

- **Містити чіткий опис змін.** Приклад [json-patch](https://datatracker.ietf.org/doc/html/rfc6902/).

The original document
```json
{
  "title": "hello, world!",
  "author": "John",
  "tags": ["example"],
  "content": "My article."
}
```

The patch

1. Замінити значення title на "First article!"
2. Додати значення "sample" до масиву tags.
3. Видалити поле author

```http request
Content-Type: application/json-patch+json

[
  { "op": "replace", "path": "/title", "value": "First article!" },
  { "op": "add", "path": "/tags", "value": ["sample"] },
  { "op": "remove", "path": "/author" }
]
```

The result

```json
{
  "title": "First article!",
  "tags": ["example", "sample"],
  "content": "My article."
}
```

- **Містити модифіковану версію ресурсу і дозволити серверу самому визначити набір змін.** Приклад [json/merge-patch](https://datatracker.ietf.org/doc/html/rfc7396)

The original document
```json
{
  "title": "hello, world!",
  "author": "John",
  "tags": ["example"],
  "content": "My article."
}
```

The patch

1. Замінити значення title на "First article!"
2. Замінити значення tags на ["sample"] (саме замінити, а не додати нове значення в масив).
3. Видалити поле author

```http request
Content-Type: application/merge-patch+json
        
{
  "title": "First article!",
  "tags": ["sample"],
  "content": null
}
```

The result

```json
{
  "title": "First article!",
  "tags": ["sample"],
  "content": "My article."
}
```

Мінус json-merge-patch в тому що він не може описати нормально описати деякі операції: наприклад додавання елементу 
в массив.

Ми будемо підтримувати json-patch.

## 1.2 Як реалізовувати Actions? ✅ ❌ ❌

> Усе висновки написані нище зроблені на основі [дисертації Роя Філдинга](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm),
> запису [REST APIs must be hypertext-driven](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven) 
> в його блозі, та [специфікації HTTP](https://datatracker.ietf.org/doc/html/rfc2616).

Для деякого розуміння дилеми з реалізації операції відмінних від CRUD (далі екшени або довільні операції) потрібно 
спочатку зрозуміти реальне значення підходу HATEOAS. HATEOAS про керування станом серверу через переходи, які сервер 
сам надає клієнту. Гарним прикладом є те як реалізований цей підхід в html. Розглянемо основні положення підходу 
HATEOAS та те як вони реалізовуються в HTML. 

- Клієнт може починати роботу з REST API без попереднього знання про структуру URI. Єдине, що повинен знати клієнт
це початковий URI та множину стандартизованих медіа типів, що необхідні для роботи з цим API. P.S. У більшості випадків
початковий URI буде повертати ресурс "Головна сторінка", що може мати свій окремий медіа тип. 

    *Приклад: майже будь-який сайт в інтернеті можна почати використовувати з його головної сторінки, яка вже містить 
гіперпосилання на інші ресурси. Для того щоб зробити новий запис в фейсбуці не потрібно знати http метод та URI за яким 
це робиться, достатньо лише зайти на головну сторінку facebook.com і через гіперпосилання дійти до потрібного 
функціоналу.* 

> При використанні http гіперпосилання містить не лише URI адресу, а також інформацію про http-метод, який повинен
> бути використаний при відправці запиту на цей URI. Вона може бути не явною, а вказаною в описі медіа типу.
> Наприклад html форми по-замовчуванню відправляються через GET метод. Інший приклад: Запити на URI який вказано в 
> атрибуті href тегу <img> також відправляються GET методом.

- Виключаючи прості точки входу в застосунок, **клієнт завчасно не знає які операції доступні над ресурсом**. Сервер 
повинен завчасно повідомити, про усі операції, що доступні над ресурсом. Хоча й множина можливих дій може бути визначена 
в опису медіа типу ресурсу, в цьому випадку достатньо знання, що сервер підтримує необхідний медіа тип. **Важливо: http 
методи не визначають множину дій, які можуть бути виконані над ресурсом. Елементи медіа типу визначають множину 
можливих дій.** 
 
    HTTP методи лише визначають: 
  - Чи операція безпечна (не змінює стан серверу) або ідемпотентна
  - Правила кешування для операції
  - Набір статус кодів, які можуть повернутись у відповідь, та їх семантичне значення
  - Правила обробки хедерів
  - etc
  
  *Приклад: html використовує форми, кнопки та гіперпосилання (що є елементами медіа типу), для того щоб визначити 
множину дій над ресурсом.*
  
    *Тобто отримуючи ресурс колекції, ми також можемо отримати:*
  - *форму (або гіперпосилання на неї), яку необхідно заповнити для того щоб створити новий елемент колекції.*
  - *гіперпосилання на детальну інформацію про кожен окремий елемент колекції*
  - *форму для фільтрації елементів колекції*
  - *кнопка для завантаження колекції в одному з форматів (csv, excel).*
    
  *Ресурс с окремим елементом колекції також може містити:*
  - *форму для редагування елементу*
  - *форма для відправки інформації про цей елемент на email*
  - *кнопки для зміни статусу елементу (наприклад зміна статусу замовлення).*
  - *кнопка для валідації елементу*
  - *кнопка для архівації елементу*
  - *кнопка для відправки елементу в систему обробки*

  Головне, що я хотів показати даним прикладом, це те що **набір дій над ресурсом визначається елементами медіа
  типу** (форми, гіперпосилання, кнопки), які відправляються клієнту разом з ресурсом, **а не http методами**. Єдиний 
  зв'язок тут в тому, що елементи медіа типу вказують http методи (наприклад форму можна відправляти як GET так і 
  POST методом), а клієнт в залежності від методу може застосовувати різні способи кешування.

    Звісно html створений для браузерів і його головна задача це визначити правила рендеренгу. Людина, яка переглядає
  ресурс у браузері, досить розумна, щоб по назві/локації кнопки або форми зрозуміти дію, що виконається, та прийняти
  рішення про те скористатись нею чи ні. Для взіємодії двух машин в опису медіа типу варто завчасно визначити усі можливі
  операції. Як, наприклад це зроблено в application/json-patch: усі можливі операції зводяться до 'add', 'remove', 
  'replace', 'move', 'copy', 'test'. 

Як ми бачимо розшифрування HTTP методів як CRUD не має сенсу, адже справжній сенс операції задається елементами
медіа типу. Http операції лише задають деякі обмеження на операцію (як ідемпотентність чи безпечність), або
правила обробки операції (кешування, значення хедерів, можливі статус коди і т.п). 

Навіть якщо спробувати однозначно побудувати співвідношення CRUD операцій до http методів, то це не можливо.

Наприклад створення ресурсу (create) може відбутись у результаті виконання методів: 
- POST - як результат обробки даних (в самому загальному сенсі). Адже лише сервер визначає яким чином йому оброблювати
дані, отримані через POST.
- PUT - якщо клієнт надіслав запит на URL за яким не закріплено ніякого ресурсу. Або модифікація/створення ресурсу 
потребує також створення додаткового ресурсу (наприклад додання нового запису в журнал змін ресурсу).
- PATCH - а данному випадку усе аналогічно до PUT. За тією різницею, що поведінка PATCH більшою мірою визначається 
медіа типом, а не самим методом і може як дозволяти створення нового ресурсу, так і забороняти.

Для оновлення ресурсу можна використовувати ті самі:
- POST - додання нового тегу до статті (аналогічно до того як створення нового ресурсу відправляючи POST запит на 
ресурс колекції можна розглядати, як update колекції).
- PUT - повна заміна ресурсу на новий
- PATCH - часткова зміна ресурсу за допомогою набору інструкцій

Залишу також деякі прямі цитати Філдинга:

> A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing 
> resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up 
> for existing standard media types. Any effort spent describing what methods to use on what URIs of interest should 
> be entirely defined within the scope of the processing rules for a media type (and, in most cases, already defined 
> by existing media types). [Failure here implies that out-of-band information is driving interaction instead of 
> hypertext.]

> A REST API must not define fixed resource names or hierarchies (an obvious coupling of client and server). Servers 
> must have the freedom to control their own namespace. Instead, allow servers to instruct clients on how to construct 
> appropriate URIs, such as is done in HTML forms and URI templates, by defining those instructions within media types 
> and link relations. [Failure here implies that clients are assuming a resource structure due to out-of band 
> information, such as a domain-specific standard, which is the data-oriented equivalent to RPC’s functional coupling]

> HTTP operations are generic: they are allowed or not, per resource, but they are always valid. Hypertext doesn’t 
> usually tell you all the operations allowed on any given resource; it tells you which operation to use for each 
> potential transition. The client (user or agent) has to decide what transition to take, not what interface to use.
> 
> HTML doesn’t need type specifications. No RESTful architecture needs type specifications. Don’t expect REST to act 
> like some other architectural style. You don’t get to decide what POST means — that is decided by the resource. 
> Its purpose is supposed to be described in the same context in which you found the URI that you are posting to. 
> Presumably, that context (a hypertext representation in some media type understood by your client) tells you or your 
> agent what to expect from the POST using some combination of standard elements/relations and human-readable text. 
> The HTTP response will tell you what happened as a result. In HTTP, a single resource-creating POST action will result 
> in a 201 response with another hypertext representation (telling you what happened and what can be done next) or 204 
> response with the Location header field indicating the URI of the new resource.

### Чому для виконання довільних екшенів зазвичай використовують POST а не інші http методи

Для виконання довільних екшенів зазвичай використовують POST, тому що він не накладає ніяких обмежень на те як сервер 
повинен оброблювати інформацію, що отримана від клієнта. 

Інші методи не підходять тому що:
- GET - безпечний (не змінювати стан серверу) та ідемпотентний.
- PUT, DELETE - ідемпотентний
- PATCH - повинен передбачуваним чином модифікувати ресурс, що визначенний в URI, якщо це не так, то краще 
використовувати POST. (Цей рядок явно вказаний в специфікації PATCH методу).

Також зручним для екшенів POST роблять наступні речення в специфікаці:
- The actual function performed by the POST method is determined by the server and is usually dependent on the 
Request-URI.
- The action performed by the POST method might not result in a resource that can be identified by a URI.

Це дозволяє нам досить спокійно використовувати URI для ідентифікації дії, яка повинна виконатись (фактично як ім'я
функції).

### Чи можна використовувати дієслова в URL

Як ми знаємо це ніде явно не заборонено, але, якщо вважати що http методи визначають тип операції над ресурсом, то
логічним чином слідує, що http методи це дієслова, а uri - іменник. 

Але також ніде на вказано, що http методи визначають тип операції. Ба більше Філдинг явно пише, що тип операції 
визначається елементами медіа типу, а не http методами.

Я не просто так у аналогію правильного REST API приводив html (до речі Філдинг також інколи посилається на нього). 
Я пропоную розглянути це питання так ніби ми проектуємо бекенд, що повертає html сторінки браузеру. При такому
підході мало в кого виникають якісь внутрішні протиріччя з приводу того використовувати дієслова в url чи ні. Адже
всі розуміють, що для людини цей url це лише набір символів, який прописаний в гіперпосиланні якоїсь кнопки чи форми.
Реальне значення має лише сенс кнопки. А HTTP метод підбирається виходячи з зображень безпеки, кешування і т.п

Фактично єдина вимога до url це, якомога довше, залишатись незмінними у часі. Адже "[implementations change, but cool 
URIs don’t.](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven#comment-732)"

### HATEOAS AND OPENAPI

Одна з головних концепцій REST API - це Uniform Interface. Клієнт не має потреби завчасно знати ні те як будувати URI, 
ні те які методи доступні на даний URI, ні те що повернеться. Єдине знання доступне клієнту - це початковий URL та 
множина можливих медіа типів, що використовуються в цьому REST API. Openapi маніфести ломають цю концепцію, адже
надають таку інформацію клієнту.

> Потрібно відмітити, що Філдинг дозволяє мати правила будування URI та типизовані ресурси, але усе це дозволяється
> лише як частина реалізації кінцевого сервера, та повинно бути скритим для клієнта. 
> 
> Fielding:
> A REST API should never have “typed” resources that are significant to the client. Specification authors may use 
> resource types for describing server implementation behind the interface, but those types must be irrelevant and 
> invisible to the client. The only types that are significant to a client are the current representation’s media type 
> and standardized relation names.

Тоді для чистого REST використання маніфестів можна використовувати лише для генерації серверного коду, ажже клієнт
повинен орієнтуватись тільки на початковий URL та множину медіа типів?

Фактично так. Для того щоб відповідати концепції з єдиним інтерфейсом ми можемо генерувати початкову сторінку на основі
маніфесту. Якою вже буде користуватись клієнт. 

Тому якщо ми використовуємо генерацію коду з маніфестів на клієнті потрібно просто признати, що ми робимо RPC API,
можемо його назвати Http RPC. 

### Висновки

- HTTP методи - це не CRUD, та вони взагалі не визначають сенс операції (хоча можуть накладати певні обмеження, які 
роблять їх більш або менш корисними для певних типів операцій). 
- Сенс операції визначається елементами медіа типу.  
- Використання дієслів в URL є цілком нормальним
- Зазвичай для довільних екшенів використовується POST (тому що інші методи просто не підходять з ряду своїх обмежень).
- Якщо ми не використовуємо HATEOAS та використовуємо генерацію коду з openapi маніфестів на клієнті то це RPC. 

## 1.3 Як виконувати версіонування API? ✅ ❌ ❌

Версіонування api залишаємо в url, це дозволить простіше кешувати ресурси (адже uri однозначно співвідноситься з даними
які повертаються), а також дозволить вказувати версію при відправці get запиту через браузер.

В маніфесті будем застосовувати семантичне версіонування. Це дозволить, при мінорних змінах, серверам розуміти що в них 
імплементується не остання версія і її потрібно обновити.

```yaml
openapi: "3.0.0"
info:
  title: petShop
  description: API exposing my pet shop’s functionality
  version: "2.1.2"
servers:
  - url: https://example.org/petShop/v2
```

Можливий підхід як в [gcloud](https://www.belgif.be/specification/rest/api-guide/#api-versioning), коли в url міститься
тільки мажорна версія, тобто сервер завжди підтримує одну мінорну і патч версію. Це дозволить залишити простоту в 
реалізації серверу. І можливо ніяк не буде впливати на клієнта, якому важлива тільки мажорна версія. Це стане 
зрозумілішим коли розпишемо співвідношення між змінами в API та версією.

### 1.3.1 Підхід до версіонування

З великою ймовірністю REST API, що описане в маніфесті, буде змінюватись. Зміни можуть бути наступними:
- Виправлення помилок
- Впровадження нових можливостей
- Видалення старих можливостей
- Зміна старих можливостей

При цьому деякі зміни можуть приводити до появи помилок на клієнті, наприклад, якщо було видалено поле яким 
користувався клієнт.

Для того, щоб не запобігти неочікуваної появи помилок, через зміни API інтерфейсу в маніфесті, можна використовувати
версіонування API. 

> Api - це абстрактне поняття, яке може бути описане за допомогою різних форматів: openapi маніфест, 
> мова програмування, природня мова (e.g. українська, англійська) і т.п.
> 
> Тому на далі коли говориться про зміну в API (чи REST API), то також мається на увазі, що й ідентична зміна 
> відбудеться в openapi маніфесті, як в документі, що описує API. Так само і навпаки: зміна в маніфесті означає 
> ідентичну зміну в API, який описується цим маніфестом.

Для версіонування будь-якого API (будь-то інтерфейс php бібліотеки, чи REST API) існує стандарт під назвою 
[семантичне версіонування](https://semver.org/lang/uk/). Який ми й будемо використовувати.

> Короткий опис семантичного версіонування:
> 
> Версія має вигляд МАЖОРНА.МІНОРНА.ПАТЧ. При цьому слід збільшувати:
> 1. МАЖОРНУ версію, якщо зроблені зміни API, що несумісні з попередньою версією
> 2. МІНОРНУ версію, якщо додана нова функціональність, що є сумісною з попередньою версією
> 3. ПАТЧ версію, якщо були зроблені виправлення помилок, що не впливають на сумісність з попередньою версією

Зміна буде вважатись сумісною з попередньою версією, тоді коли при заміні старої версії API на нову, функціонування 
**будь-якої** системи, яка **користується** цим API, не порушиться.

Важливо розуміти, що сумісність розглядається лише стосовно системи, яка **користується** API, а не для системи, яка 
**реалізовує** це API. В загальному випадку будь-яка зміна API є несумісною для системи, що **реалізовує** API, 
хоча й в деяких конкретних випадка, в залежності від специфіки реалізації, можуть бути виключення. Так само як і зміна,
що в загальному випадку порушує сумісність, може не порушувати її для якогось конкретного специфічного клієнта.

> У нашому випадку систему, яка користується API - клієнт, а система, що реалізовує API - сервер.

Оскільки серверів так само як і клієнтів може бути безліч, та вони усі можуть реалізовувати/використовувати різні 
версії маніфесту (рис 1.3.1-1), а в деяких випадках одночасно декілька, то потрібен механізм, що буде контролювати 
сумісність версій маніфесту на клієнті та сервері.

![Рис 1.3.1-1](../docs/img/specification/api-versioning.jpg)
Рис 1.3.1-1

> Сервер не може реалізовувати більше одної НЕ мажорної версії. Тобто для кожної мажорної версії, сервер одночасно
> може реалізовувати тільки одну комбінацію мінорна + патч версія. Але може одночасно реалізовувати декілька мажорних
> версій.

#### 1.3.1.1 Контроль версій за допомогою User-Agent та Server хедерів

Для контролю сумісності між мажорними версіями використовується url, але в ньому не вказані мінорні та патч версії. Для 
того, щоб повністю контролювати сумісність клієнта та сервера можна використовувати User-Agent та Server хедери, 
наступним чином:

Клієнт в кожному запиті **ПОВИНЕН** передавати назву/версію маніфесту та генератора з якого відправляється запит
у хедері [Used-Agent](https://datatracker.ietf.org/doc/html/rfc2616#section-14.43). Приклад:

Request:
```http request
GET /resource
User-Agent: {Generator-Name}/{Generator-Version} {Manifest-Title}/{Manifest-Version}
```

Сервер **ПОВИНЕН** передавати назву/версію маніфесту та генератора, що оброблювали запит у хедері 
[Server](https://datatracker.ietf.org/doc/html/rfc2616#section-14.38).

Якщо версія маніфесту, що реалізованна сервером менша, ніж передана клієнтом у запиті, то код відповіді від сервера 
**ПОВИНЕН** бути [*501 Not Implemented*](https://datatracker.ietf.org/doc/html/rfc2616#section-10.5.2). Приклад:

Response
```http
HTTP/1.1 200 OK
Server: {Generator-Name}/{Generator-Version} {Manifest-Title}/{Manifest-Version}
```

> Опис 501 коду: *The server does not support the functionality required to fulfill the request.*
> 
> Хоч цей код придумали, щоб сервер міг відповісти, що він не підтримує HTTP метод, яким відправлений запит. Але в 
> специфікації ніде не має обмежень, що він повинен використовуватись лише для цього випадку.

Клієнт може перевірити версію маніфесту, що реалізована на стороні сервера відправивши OPTIONS запит на url маніфесту.
Сервер **ПОВИНЕН** підтримувати OPTIONS запити. Приклад:

Request:
```http request
OPTIONS openapi/{manifest-name}/{major-version}
User-Agent: {Generator-Name}/{Generator-Version} {Manifest-Title}/{Manifest-Version}
```

Response
```http
HTTP/1.1 200 OK
Server: {Generator-Name}/{Generator-Version} {Manifest-Title}/{Manifest-Version}
```

На перших порах перед тим як оновлювати клієнтську версію, програмісту потрібно буде вручну перевірити, що усі сервери, 
які він використовує підтримують потрібну йому версію. Але надалі це можна буде автоматизувати за допомогою OPTIONS 
запитів.

#### 1.3.1.2 Контроль версій за допомогою медіа типу

Взагалі в http для узгодженості версій клієнта та сервер використовується [Content 
Negotiation](https://datatracker.ietf.org/doc/html/rfc2616#section-12), що краще описаний в [документації
Mozilla](https://developer.mozilla.org/ru/docs/Web/HTTP/Content_negotiation). 

Загалом це механізм, що через хедери дозволяє серверу та клієнт дізнатись інформацію один про одного: які медіа типи
підтримуються (як клієнтом так і сервером), мови яким надає перевагу клієнт і т.п. Наприклад усім відомий хедер
`Accept`, так само як і описані вище `User-Agent` та `Server` - це частина цього механізму.

В ідеальному REST контроль версій повинен відбуватись за допомогою медіа-типів. Замість того, щоб
робити різні url (`/v1/orders/`, `/v2/orders/`), можна використовувати різні медіа-типи (`application/order.v1`,
`application/order.v2`). Якщо, ще в медіа тип додати мінорні та патч версії, то ми б отримали досить зручний механізм
для вияснення того чи зумісні версії клієнта та сервера.

Наприклад, якщо клієнт не вказав конкретну версію в медіа типі, то сервер прислав би відповідь з кодом 
[*300 Multiple Choices*](https://datatracker.ietf.org/doc/html/rfc2616#section-10.3.1), у якій би були перераховані
усі сумісні з сервером версії. Тобто, якщо на сервері реалізовано версії: 1.1.3 та 2.0.1, то сумісні з сервером версії,
це: 1.0.0, 1.0.1 ( та усі 1.0.х), 1.1.0, 1.1.1, 1.1.2, 1.1.3, 2.0.0, 2.0.1. А клієнт вже міг би перевірити чи є у 
списку потрібна йому версія.

> Якщо клієнтом буде браузер, а не мікросервіс, то можна 1) перевірити чи є підтримка 300го коду браузером,
> можливо він дає можливість в UI людині обрати потрібну їй версію 2) якщо ж браузер не дає такої можливості, то
> генерувати html з формою, що дозволить обрати версію та відправити запит (зрозуміти, що запит прийшов з браузера
> можна за допомогою User-Agent хедера). 

Якщо клієнт відправив запит, та у медіа типі вказана версія, що не підтримується сервером, то сервер може відповісти
кодом [*415 Unsupported Media Type*](https://datatracker.ietf.org/doc/html/rfc2616#section-10.4.16).

Такий підхід більше слідує семантиці HTTP та REST принципам, та має сенс, якщо реалізовувати реальний HATEOAS підхід.
Тому, що url не будуть залежати від версії, та зможуть повноцінно використовуватись як ідентифікатори ресурсів. На 
відмінну від того, як зараз ми фактично використовуємо окреме поле `id` для того, щоб ідентифікувати окремий елемент
колекції, ми могли б використовувати увесь url як ідентифікатор.

Але допоки ми не реалізуємо HATEOAS у нашій системі, то можемо використовувати лише підхід описаний в пункті 1.3.1.1,
та продовжити вказувати мажорні версії в url.

### 1.3.2 Коли змінювати мажорну версію

При *будь-яких* змінах, що порушують зворотну сумісність (в тому числі при виправленні помилок, за виключеннями, що 
будуть описані талі).

Приклади змін, що порушують зворотну сумісність:
- Змінна типу поля
- Зміна значення (сенсу) поля, навіть якщо його тип не змінився
- Видалення поля
- Додання обмежень до логіки валідації
- Збільшення діапазону enum значень у відповіді
- Зменшення діапазону enum значень у запиті
- Зміна сенсу enum значень
- Видалення ендпоінту
- Додання обов'язкового поля до запиту
- Зміна поля з необов'язкового на обов'язкове у запиті
- Зменшення діапазону enum значень у відповіді (тому що це впливає на валідацію)

Рекомендується, за можливості, запобігати таких змін. Для цього можна, наприклад:
- замість видалення поля/ендпоінту, можна його відмітити як deprecated. 
  > Якщо стандартними засобами помітити щось як deprecated не можливо, то можна просто написати про це в описі. 
- Замість зміни сенсу, або типу поля можна створити нове поле, та підтримувати обидва поля, до наступної мажорної 
версії маніфесту.

### 1.3.3 Коли змінювати мінорну версію

Зі [специфікації семантичного версіонування](https://semver.org/lang/uk/#spec-item-7):

> Мінорна версія Y (x.Y.z | x > 0) ПОВИННА бути збільшена, якщо до публічного API додана нова зворотньосумісна 
> функціональність. Вона ПОВИННА бути збільшена, якщо будь-яка функціональність публічного API позначена, як 
> застаріла (deprecated). Вона МОЖЕ бути збільшена, якщо в приватний код внесені істотні зміни функціональних 
> можливостей або вдосконалення. Вона МОЖЕ включати зміни рівня патчів. Патч версія ПОВИННА бути скинута до 0 при 
> збільшенні мінорної версії.

Приклади:
- Додання нової інформації у відповідь, яка ніяк не впливає на інформацію, що вже поверталась.
  > При умові, що клієнти ігнорують усі невідомі їм поля
  > 
  > Наприклад нам поверталась деяка відстань в метрах в полі `distanceInMeters`, а потім ми додали поле
  > `distanceInFoots` з цією самою відстанню, але в футах.
- Додання необов'язкового поля до запиту
- Помітити enum значення/поле/ендпоінт як deprecated.
  > На жаль наразі відмітити одне значення з діапазону enum як застаріле неможливо, тому це потрібно просто писати в 
  > описі. Наприклад, якщо ми перестаємо використовувати значення in_progress в деякому status енамі, то в маніфесті це 
  > потрібно відобразити так:
  >```
  > status:
  >   type: string
  >   description: |
  >     pending - ...
  >     in_progress - deprecated.
  >     fulfilled - ...
  >     rejected - ...
  >   enum:
  >     - pending
  >     - in_progress
  >     - fulfilled
  >     - rejected
  >```
  > У випадку, якщо якесь enum значення, що використовується лише у відповідях, поміченно як deprecated, то сервер 
  > **ПОВИНЕН** перестати його використовувати. 
- Додання нового ендпоінту
- Додання документації

### 1.3.4 Коли змінювати patch версію

Це виправлення помилок, що не порушують [зворотну сумісність](#132-коли-змінювати-мінорну-версію). А також:
- Додання прикладів в маніфест
- Виправлення помилок в документації. 

## 1.4 Використання lifecycle_token ✅ ❌ ❌

Мені подобається підхід який в нас реалізований вже: коли застосунок очікує, що lifecycle_token буде в контейнері,
і не важливо яким чином він туди потрапив:
- Згенерувався в middleware оскільки в запиті до сервера його не було
- Middleware отримав його з хедеру 

І в усіх випадках не важливо чи це був запит до openapi, datastore чи callback.

При цьому не бачу потреби передавати його в dto, оскільки якщо якомусь классу буде потрібен цей lifecycle_token 
він може прийняти його в конструкторі (як це робить логер).

## 1.5 Історія виконання лонг-таску  ❌ ❌ ❌

Історія може повертатись окремим http запитом.

## 1.6 Рейт ліміти ✅ ❌ ❌

Можна повертати інформацію про ліміти в хедерах, як це робить [github](https://docs.github.com/en/rest/overview/resources-in-the-rest-api#rate-limit-http-headers)

```bash
$ curl -I https://api.github.com/users/octocat
> HTTP/2 200
> Date: Mon, 01 Jul 2013 17:27:06 GMT
> x-ratelimit-limit: 60
> x-ratelimit-remaining: 56
> x-ratelimit-reset: 1372700873
```

| Header Name           | 	Description                                                |
|-----------------------|-------------------------------------------------------------|
| x-ratelimit-limit     | 	Дозволена кількість запитів в годину                       |
| x-ratelimit-remaining | Кількість запитів що залишилась в поточному лімітному вікні |
| x-ratelimit-reset     | Таймстамп в UNIX коли лімітне вікно обновиться              |

> Для рейт ліміт хедерів також є [драфт специфікації](https://tools.ietf.org/id/draft-polli-ratelimit-headers-00.html#:~:text=The%20RateLimit%2DLimit%20response%20header,it%20MAY%20not%20be%20served.&text=The%20expiring%2Dlimit%20value%20MUST,closer%20to%20reach%20its%20limit.), 
> в цілому там тіж самі три хедера, але кожен запит ще має request-quota - те за скільки запитів буде вважать цей запит.
> Наприклад один складний запит можна вважати за два запити чи більше. 

Також github мають окремий ендпоінт, що повертає ліміти по кожному ресурсу:

``` http request
GET /rate_limit
```

```json
{
  "resources": {
    "core": {
      "limit": 5000,
      "remaining": 4999,
      "reset": 1372700873,
      "used": 1
    },
    "search": {
      "limit": 30,
      "remaining": 18,
      "reset": 1372697452,
      "used": 12
    },
    "graphql": {
      "limit": 5000,
      "remaining": 4993,
      "reset": 1372700389,
      "used": 7
    },
    "integration_manifest": {
      "limit": 5000,
      "remaining": 4999,
      "reset": 1551806725,
      "used": 1
    },
    "code_scanning_upload": {
      "limit": 500,
      "remaining": 499,
      "reset": 1551806725,
      "used": 1
    }
  },
  "rate": {
    "limit": 5000,
    "remaining": 4999,
    "reset": 1372700873,
    "used": 1
  }
}
```

Можливо є сенс замість одного ендпоінта робити окремий для кожного ресурсу: /orders/rate-limits, /customers/rate-limits.
Мені здається так краще, тому що буде повертатись інформація тільки щодо одного ресурсу, що наразі цікавий клієнту.

Якщо використовувася [conditional request](https://docs.github.com/en/rest/overview/resources-in-the-rest-api#conditional-requests) 
і повернувся код 304 Not Modified, то цей запит не враховується в рейт лімітах.

Якщо ліміти закінчились повертається 429 код відповіді.

```bash
$ curl -I https://api.github.com/users/octocat
> HTTP/2 429
> Date: Mon, 01 Jul 2013 17:27:06 GMT
> x-ratelimit-limit: 60
> x-ratelimit-remaining: 0
> x-ratelimit-reset: 1372700873
```

### Як можна вказати ліміти по-замовчуванню в маніфесті

Openapi маніфести можна [розширяти](https://swagger.io/docs/specification/openapi-extensions/) вказуючи в них свої 
додаткові властивості. Вони повинні починатись с `x-` та можуть знаходитись в:
- `info` section
- `paths` section, individual paths and operations
- operation parameters
- `responses`
- `tags`
- security schemes

Тобто, якщо я зрозумів усе правильно, то ми можемо кожнії операції (ендпоінту) вказати свій кастомний атрибут з
лімітами по замовчуванню, наприклад: 

```yaml
paths:
  /users/{id}:
    x-ratelimit-limit: 100 # Кількість запитів доступних для лімітного вікна
    x-ratelimit-window: 60 sec # Час життя лімітного вікна
    responses:
      # ...
```

Або для усіх едпоінтів одночасно в секції info

```yaml
info:
  title: ...
  version: ...
  x-ratelimit-limit: 100
  x-ratelimit-window: 60 sec
```

TODO:
1. Дослідити різні алгоритми реалізації rate лімітів.
2. Пошукати бібліотеки які реалізовують rate ліміти для php.
3. Написати вимоги до openapi генератора, що пов'язані з rate лімітами
4. Написати рекомендований рейт ліміт
6. Формат ресурсу з лімітами

## 1.7 Часткове отримання ресурсу? ✅ ❌ ❌

Для цього можна використовувати select в rql.

```http request
GET /articles/1
```

```http
HTTP/1.1 200 OK

{
  "tasks" : {
    "id": 1,
    "title": "My article",
    "content": "..."
  }
}
```

```http request
GET /articles/1?select=id
```

```http
HTTP/1.1 200 OK

{
  "data" : {
    "id": 1
  }
}
```

Головна проблема це як описати цю операцію в маніфесті. Якщо в нас наприклад по замовчуванню title завжди повинен 
повертатись.

Нам або потрібно робити усі поля optional, або описувати окремий ендпоінт для select запиту.

Можливе рішення 1:

- В required описувати тільки ті поля, що повернуться в будь якому разі. 
- В select використовувати лише опциональні поля, а required будуть повертатись в будь-якому випадку.
- Якщо клієнт використовує поле, що не вказане в required, то він обов'язково повинен вказати його в select. Код можна
генерувати так, щоб він перевіряв, що від сервера повернулись усі поля, що вказані в select.

Для get query запиту усі поля ресурсу будуть не обов'язкові. Генератор буде перевіряти чи всі select поля 
передані у відповіді.

## 1.8 Пагінація ❌ ❌ ❌

Якщо колекція передбачувано буде мати багато елементів, то вона **ПОВИННА** підтримувати пагінацію. Визначення того, що
вважати за "багато" елементів залишається на архітекторі системи, адже це може залежати від вимог до швидкості роботи
системи, обмеженням по пам'яті, розміру конкретного ресурсу та багато чого іншого.

Існує два популярних підходи до реалізації пагінації:
- offset-based 
- cursor-based (aka key-based or luke index):

### Offset-based

Пагінація яка використовується в наших датасторах, факточно вказується номер елементу, що наступний після останнього 
отриманого. Зазвичай зміщення вказується не явно, а через номер сторінки та кількість елементів на сторінці, тоді 
зміщення рахується як `offset = page * page_size`.

Переваги:
- Велика поширеність у фреймворках/інструментах.
- Простота використання
- Можливість "стрибнути" на якусь певну сторінку, попередньо не отримавши на неї посилання

Недоліки:
- Порівняно низька швидкість роботи для виликих наборів данних. (Чому не знаю, ймовірно пов'язано з внутрішньою 
реалізацією курсорів в базах даних)
- Низька швидкість роботи в NoSQL базах даних
- Можливість дублікатів при обході сторінок, якщо при цьому додався новий запис в базу даних.

Якщо ми будемо реалізовувати цей варіант, то для пагінації сервер повинен повертати або загальну кількість елементів,
або кількість сторінок (разом з розміром однієї сторінки). А клієнт буде передавати номер сторінки, та необов'язоквий
розмір сторінки в query параметрах.

Request example
```http request
GET /resources?page=2
```

Response example
```json5
{
  "metadata": {
    "pagination": {
      "totalCount": 101,
      "totalPages": 6,
      "currentPage": 2,
      "pageSize": 20
    }
  },
  "data": [
    // ...
  ]
}
```

### Cursor-based

Для клієнтської сторони курсор це лише набір символів, який вказує на певну сторінку. Реальне значення курсору може
відрізнятись в залежності від імплементації сервера. Зазвичай у якості курсору використовують ідентифікатор першого або
останнього елементу на сторінці.

Переваги:
- Швидкість роботи для великих наборів даних та NoSQL баз даних
- неможливість дублікатів при обході сторінок

Недоліки:
- Складність реалізації
- Неможливість "стрибнути" на певну сторінку, попередньо не отримавши посилання на неї

Зауваження:
- Може не працювати, якщо потрібен total count of results (поки не знаю чому, можливо мається на увазі його 
неефективність при даній умові)
- При неправильній реалізації може бути помилка, якщо курсор вказуватиме на елемент, що вже видалено

Request example (cursor - необов'язковий в першому запиті, але присутній для прикладу)
```http request
GET /resources?cursour=null
```

> Замість null можна використовувати якісь інші зарезервовані значення: 0 або -1 і т.п. Головне щоб це значення було
> вказано для поля у розділі default, а також коректно оброблювалось серверною стороною.

Response example
```json5
{
  "metadata": {
    "pagination": {
      "nextPageCursor": "gRk90324",
      "prevPageCursor": null,
      "currentCursor": 'nm2bu4n5j',
      "pageSize": 20
    }
  },
  "data": [
    // ...
  ]
}
```

Детальніше: [Zalando RESTful API and Event Guidelines](https://opensource.zalando.com/restful-api-guidelines/#pagination)

### Зарезервовані параметри

#### Reserved query parameters

| name     | manifest support                                         | required | has default value | description                                                    |
|----------|----------------------------------------------------------|----------|-------------------|----------------------------------------------------------------|
| pageSize | **mandatory** if any pagination used                     | false    | true              | maximum number of items per page desired by client             |
| page     | **mandatory** for offset-based, **N/A** for cursor-based | false    | true              | the index of page to be retrieved                              |
| cursor   | **N/A** for offset-based, **mandatory** for cursor-based | false    | true              | the cursor (received in prev response) of page to be retrieved |

> Manifest support визначає чи зобов'язаний цей параметр бути присутнім в маніфесті (а значить і підтримуватись 
> сервером)

#### Reserved JSON properties

| name              | manifest support                                         | required | nullable        | description                                                                                                                    |
|-------------------|----------------------------------------------------------|----------|-----------------|--------------------------------------------------------------------------------------------------------------------------------|
| pageSize          | **mandatory** if any pagination used                     | true     | false           | Maximum number of items per page. For the last page, its value should be independent of the number of actually returned items. |
| nextPageCursor    | **N/A** for offset-based, **mandatory** for cursor-based | true     | true            | cursor to next page                                                                                                            |
| prevPageCursor    | **N/A** for offset-based, **mandatory** for cursor-based | true     | true            | cursor to prev page                                                                                                            |
| currentPageCursor | **N/A** for offset-based, **mandatory** for cursor-based | true     | manifest-depend | cursor to current page                                                                                                         |
| firstPageCursor   | **N/A** for offset-based, **optional** for cursor-based  | true     | false           | cursor to first page                                                                                                           |
| lastPageCursor    | **N/A** for offset-based, **optional** for cursor-based  | true     | false           | cursor to last page                                                                                                            |
| totalCount        | **mandatory** for offset-based, **N/A** for cursor-based | true     | false           | total items in collection                                                                                                      |
| totalPages        | **mandatory** for offset-based, **N/A** for cursor-based | true     | false           | total pages (with {pageSize} size) in collection                                                                               |
| currentPage       | **mandatory** for offset-based, **N/A** for cursor-based | true     | false           | index of current page                                                                                                          |

### Висновки

Для простоти реалізації краще використовувати offset-based пагінацію, але у випадках якщо наявність дублікату
при обході сторінок критична, то потрібно використовувати cursor-based.

Ми почнемо з підтримки offset-based пагінацій, cursor-based - на майбутнє. 

## 1.9 Цикл життя лонг таску ✅ ❌ ❌

При виконанні будь-якого http запит у відповідь може повернутись 202 код. Це означає, що сервер прийняв запит в 
обробку, але поки ще не виконав (відклав його у чергу). В результаті запит може як виконатись, так і ні. Представлення 
при цьому коді містить опис поточного стану виконання запиту, а також вказівник на ресурс (далі задача), що надає 
користувачеві оцінку того, коли запит буде виконаний.

В нашому випадку у відповіді з 202 статусом медіа тип **ПОВИНЕН** бути [application/vnd.rollun-long-task+json](#applicationvndrollun-long-task-pendingjson). Також може бути присутній заголовок Retry-After з естімейтом 
виконання задачі.

**Початок асинхроного запиту**

Request
```http request
POST /articles
Accept: application/vnd.rollun+json, application/problem+json, application/vnd.rollun-long-task+json
Content-Type: application/vnd.rollun-request+json

{
  "payload": {
    "idempotencyKey": "abc",
    "title": "My article!"
  }
}
```

Response
```http
HTTP/1.1 202 Accepted
Location: http://www.example.org/actions/post/123
Retry-After: 30
Content-type: application/vnd.rollun-long-task+json

{
  "task": {
    "id": "123",
    "idempotencyKey": "abc",
    "stage": "step-0"
  }
}
```

**Отримання стану задачі**

Request
```http request
GET /articles/actions/post/123
Accept: application/problem+json, application/vnd.rollun-long-task+json
```

Response
```http
HTTP/1.1 200 Ok
Content-type: application/vnd.rollun-long-task+json
Retry-After: 10

{
  "task": {
    "id": "123",
    "idempotencyKey": "abc",
    "stage": "step-1",
  }
}
```

**Якщо виконання успішно закінчилось**

У відповідь ми отримуємо 303 статус, з посиланням на результат операції в полі "result" (якщо результат існує).

Request
```http request
GET /articles/actions/post/123
Accept: application/vnd.rollun+json, application/problem+json, application/vnd.rollun-long-task+json
```

Response
```http
HTTP/1.1 303 See Other
Location: http://www.example.org/articles/1
Content-type: application/vnd.rollun-long-task+json

{
  "task": {
    "id": "123",
    "idempotencyKey": "abc",
    "stage": "done",
    "completed":"2018-09-13T02:10:00Z",
    "result": "1" \\ ідентифікатор створеного ресурсу
  }
}
```

Request

```http request
GET http://www.example.org/articles/1
Accept: application/vnd.rollun+json, application/problem+json, application/vnd.rollun-long-task+json
```

Response

```http
HTTP/1.1 200 OK
Content-type: application/vnd.rollun+json

{
  "data": {
    "id": 1,
    "idempotencyKey": "abc",
    "title": "My article!"
  }
}
```

**Якщо виконання закінчилось помилкою**, то повертається код **200**, а тіло відповіді буде описувати помилку. 

> Детальніше про те чому код саме 200 в розділі про обробку помилок

Request
```http request
GET /articles/actions/post/123
Accept: application/vnd.rollun+json, application/problem+json, application/vnd.rollun-long-task+json
```

Response

```http
HTTP/1.1 200 Ok
Content-Type: application/rollun.problem+json
```

```json
{
  "problem": {
    "type": "urn:problem-type:rollun:internalServerError",
    "instance": "urn:lifecycle-token:d9e35127e9b14201a2112b52e52508df",
    "status": 500,
    "title": "Internal Server Error",
    "detail": "Null pointer exception while executing 'Article::create'."
  }
}
```

**Перезапуск задачі**

В данному випадку все залежить від двух факторів:
- чи зберігся на сервері ключ ідемпотентності та ідентифікатор задачі
- чи хочемо ми змінити дані запиту при перезапуску задачі

Зрозуміти чи зберігся ключ ідемпотентності та ідентифікатор задачі можна відправивши запит на отримання задачі, якщо 
повернувся код 200 або 410, то збереглись, 404 - ні. 

*Якщо ключ ідемпотентності та ідентифікатор задачі не зберігся на сервері*, то ми можемо створити нову задачу з тим
самим ключем ідемпотентності. Тобто діяти так наче минулої задачі не було і ми створюємо її перший раз: так як
було описано вище. 

*Якщо ключ ідемпотентності та ідентифікатор задачі збереглися*, то створити нову задачу не вдасться оскільки ключ
ідемпотентності вже зарезервовано. В такому випадку можна відправити запит саме на перезапуск задачі. Сам запит може
бути двух варіацій:

- Без зміни даних запиту
  
  Можливо тільки якщо на сервері збереглись данні запиту. В такому випадку достатньо відправити POST запит без тіла
  запиту.

  ```http request
  POST /articles/actions/post/123/restart
  Accept: application/problem+json, application/vnd.rollun-long-task+json
  ```

- Зі змінною даних запиту

  В такому випадку потрібно відправити POST запит з тілом запиту

  ```http request
  POST /articles/actions/post/123/restart
  Accept: application/problem+json, application/vnd.rollun-long-task+json
  Content-Type: application/vnd.rollun-request+json
  ```
  
  ```json
  {
    "payload": {
      "idempotencyKey": "abc",
      "title": "Another title"
    }
  }
  ```

## 1.10 Опис медіа типів ✅ ❌ ❌

### Схема опису

- **Parent:** батьківський медіа тип. Описуваний медіа тип містить усі властивості батківського типу, 
якщо явно не написано інше.

### application/vnd.rollun-request+json

**Parent:** application/json

Цей медіа тип призначений для тіла запиту. 

На верхньому рівні є завжди json об'єктом (не масивом, примитивом etc).

Для передачі корисних даних (фактично вхідних аргументів) **ПОВИННО** використовуватись поле `payload`. Поле **МОЖЕ**
бути відсутнім, якщо операції не передаються ніякі вхідні аргументи.

Передача інформації, для якої є визначені в http специфікації заголовки, повинна передаватись через них. А саме:

- Accept - список медіа типів які здатен опрацювати клієнт
- Accept-Charset - кодування символів (charset) яке здатен зрозуміти клієнт (utf-8, iso-8859-15, etc)
- Accept-Encoding - кодування (encoding) яке здатен опрацювати клієнт (gzip, compress, br)
- Accept-Language - набір природних мов, яким клієнт надає перевагу
- Authorization - данні авторизації
- From - email адреса власника клієнта (що, відправляє запит)
- Заголовки умовних запитів: If-Match, If-None-Match, If-Modified-Since, If-Unmodified-Since, If-Range
- Інші технічні заголовки

Openapi schema:

```yaml
SuccessResponse:
    type: object
    properties:
        payload:
            nullable: true
            description: >
                Корисна інформація про стан ресурсу, або колекції ресурсів. Стан ресурсу описується набором полей 
                об'єкту, або примитивом (рядок, число і т.п.).
```

### application/vnd.rollun-metadata+json

**Parent:** application/json

Є батьківським для декількох наступних медіа типів. Можливо може використовуватись як тіло відповіді для OPTIONS 
запитів.

```yaml
SuccessResponse:
    type: object
    properties:
        metadata:
            $ref: "#/components/schemas/Metadata"
            description: Метаінформація про ресурс, або колекцію ресурсів.
Metadata:
  type: object
  properties:
    pagination:
      oneOf:
        - $ref: "#/components/schemas/OffsetPaginationMetadata"
        - $ref: "#/components/schemas/PaginationMetadata"

PaginationMetadata:
  type: object
  required:
    - pageSize
  properties:
    pageSize:
      type: int
      description: > 
        Maximum number of items per page. For the last page, its value should be independent of the number of actually 
        returned items.

OffsetPaginationMetadata:
  allOf:
    - $ref: "#/components/schemas/PaginationMetadata"
  required:
    - totalCount
    - totalPages
    - currentPage
  properties:
    totalCount:
      type: int
      description: total items in collection
    totalPages: 
      type: int
      description: total pages (with {pageSize} size) in collection
    currentPage:
      type: int
      description: index of current page

CursorPaginationMetadata:
  allOf:
    - $ref: "#/components/schemas/PaginationMetadata"
  required:
    - nextPageCursor
    - prevPageCursor
    - currentPageCursor
  properties:
    nextPageCursor:
      type: int
      description: cursor to next page
    prevPageCursor:
      type: int
      description: cursor to prev page
    currentPageCursor:
      type: int
      description: cursor to current page
```

### application/vnd.rollun+json

**Parent:** application/vnd.rollun-metadata+json

Медіа тип призначений для успішних відповідей: з кодом 2хх. **НЕ РЕКОМЕНДУЄТЬСЯ** для використання зі статус кодами 
відмінними від 2xx.

На верхньому рівні є завжди json об'єктом.

Основна інформація про стан ресурсу **ПОВИННА** міститись у полі `data`. Поле `data` **МОЖЕ** бути відсутнім, якщо
успішне виконання задачі не має результату. **МОЖЕ** бути null для опису порожнього результату.

> Відсутність результату (поле 'data' відсутнє) може повертатись операцією-процедурою, яка ніколи не повертає ніякого 
> результату. У таких операцій все ще є сенс повертати тіло відповіді, оскільки, окрім безпосередньо результату (поля
> 'data') в ньому може міститись інформація про попередження, метаданні і т.п.
> 
> Порожній результат (поле 'data' дорівнює null) означає, що операція загалом повертає результат, але у данному 
> конкретному випадку його немає (з легальних причин).

Об'єкт **МОЖЕ** містити поле `messages`. Рівень повідомлення **ПОВИНЕН** бути один з: `info`, `notice`, `warning`, 
`debug`.

Openapi schema:

```yaml
SuccessResponse:
    type: object
    required:
        - data
    properties:
        metadata:
          $ref: "#/components/schemas/Metadata"
          description: Метаінформація про ресурс, або колекцію ресурсів.
        data:
            nullable: true
            description: >
                Корисна інформація про стан ресурсу, або колекції ресурсів. Стан ресурсу описується набором полей 
                об'єкту, або примитивом (рядок, число і т.п.).
        messages:
            type: array
            items:
                $ref: "#/components/schemas/Message"

Message:
    type: object
    required:
        - level
        - type
        - text
    properties:
        level:
            type: string
            enum: [ `emergency`, `alert`, `critical`, `error`, `warning`, `notice`, `info` ]
        type:
            type: string
            enum:
                - UNDEFINED
            description: >
                Тип повідомлення для зручного розрізняння помилки клієнтською програмою.
                Назви типів повинні бути у верхньому регістрі, а слова розділені нижнім 
                підкреслюванням '_' (e.g. VALIDATION_ERROR).
                UNDEFINED - тип за замовчуванням
        text:
            type: string
            description: довільний текст з поясненням для людини
```

### application/vnd.rollun-error+json

- **Parent:** application/json

Медіа тип призначений для опису помилок при створенні чи отриманні ресурсу і **НЕ ПОВИНЕН** використовуватись у запитах.
**МОЖЕ** використовуватись разом з 2хх кодом, якщо сама http операція виконалась успішно, але результат який описується
цією операцією - помилка. Приклад такої поведінки можна знайти в описі лонг тасків.

На верхньому рівні є завжди json об'єктом.

Об'єкт **НЕ ПОВИНЕН** містити поле `data`.

Об'єкт **ПОВИНЕН** містити поле `messages` з хоча б одним повідомленням з рівнем`error` або вище, що буде описувати 
причину помилки. 

Рівень повідомлень **ПОВИНЕН** бути один з: `emergency`, `alert`, `critical`, `error`, `warning`, `notice`, `info`, 
`debug`. 

> Рівні сортируются у порядку спадання наступним чином: emergency, alert, critical, error, warning, notice, info

Openapi schema:

```yaml
SuccessResponse:
    type: object
    properties:
        messages:
            type: array
            items:
                $ref: "#/components/schemas/Message"
            minItems: 1
            description: At leas one item with level error or higher

Message:
    type: object
    required:
        - level
        - type
        - text
    properties:
        level:
            type: string
            enum: [ `emergency`, `alert`, `critical`, `error`, `warning`, `notice`, `info` ]
        type:
            type: string
            enum:
                - UNDEFINED
            description: >
                Тип повідомлення для зручного розрізняння помилки клієнтською програмою.
                Назви типів повинні бути у верхньому регістрі, а слова розділені нижнім 
                підкреслюванням '_' (e.g. VALIDATION_ERROR).
                UNDEFINED - тип за замовчуванням
        text:
            type: string
            description: довільний текст з поясненням для людини
```

### application/vnd.rollun-long-task-pending+json
**Parent:** application/vnd.rollun-metadata+json

Призначений для опису стану виконання асинхронної задачі.

На верхньому рівні є завжди json об'єктом.

В полі `task` **ПОВИНЕН** міститись об'єкт `long-task`.

Об'єкт `long-task` **ПОВИНЕН** містити поля:
- `id` : string - ідентифікатор задачі.
- `idempotency-key` - ключ ідемпотентності
- `status` - enum: pending, rejected, fulfilled

> Нам не потрібне поле status, тому що цей тип використовується лише при pending статусу задачі. 
> Для більш детального опису стану виконання можна використовувати поле `currentStage`.

Об'єкт `long-task` **МОЖЕ** містити поля:
- `problem`: `application/problem+json` - якщо статус 'rejected',
- `resultLocation`: object - посилання на результат виконання задачі
- `currentStage` : string - етап виконання задачі, може бути enum
- `percentComplete`: int[0-100] - стан виконання задачі у відсотках
- `createdAt`: date-time - час створення задачі
- `startedAt`: date-time - час початку виконання задачі

При використанні цього типу, якщо задача в статусі `pending`, то **РЕКОМЕНДУЄТЬСЯ** повертати хедер `Retry-After`, 
що буде описувати естімейт, коли задача завершиться.

## 1.11 Що повинні повертати запити, якщо інформація про лонг-таск видалено ✅ ❌ ❌

404 Not Found- якщо ідентифікатор задачі звільнено і в подальшому під цим ідентифікатором може з'явитись нова задача.
Навіть якщо ми використовуємо uuid, адже все одно ми ніде не зберігаємо інформацію що ідентифікатор зарезервовано.

410 Gone - Якщо інформацію про задачу видалено, але ми десь запам'ятали, що цей ідентифікатор колись був зайнятий.

Як можливість можна додати

## 1.12 Яка інформація повинна передаватись в messages ✅ ❌ ❌

Типи повідомлень які можуть потрапити в messages:

- **Опис помилки при виконанні запиту**

```http request
GET /orders
```

```http
HTTP/1.1 500 Internal Server Error

{
  "messages": [
    {
      "level": "error",
      "type": "DATABASE_PROBLEM",
      "message": "Database not available. Try again later."
    }
  ]
}
```

- **Метаінформація про ресурс**

Наприклад штат у якому найбільше замовлень, чи попередження про несвіжість даних: в данном контексті саме несвіжість
усієї колекції, а не даних в якомусь конкретному замовлені. Тобто в колекції може не бути якогось елементу, але
усі інші елементи колекції містять актуальну інформацію.

```http request
GET /orders
```

```http
HTTP/1.1 200 OK

{
  "data": [
    //... 
  ], 
  "messages": [
    {
      "level": "info",
      "type": "MOST_POPULAR_STATE",
      "message": "Texas"
    },
    {
      "level": "warning",
      "type": "DATA_IS_NOT_FRESH",
      "message": "Last collection update was 2 days ago."
    }
  ]
}
```

- **Метаінформація про запит**

```http request
GET /orders
```

```http
HTTP/1.1 200 OK

{
  "data": [
    //... 
  ], 
  "messages": [
    {
      "level": "info",
      "type": "REQUEST_TIME",
      "message": "0.1 sec"
    }
  ]
}
```

- **Попередження та метаінформація пов'язані з конкретним елементом колекції**

Наприклад в деяких з повернених замовлень спосіб відправки не збігається з тим який ми запитували. Або якись
конкретний елемент колекції містить не актуальну інформацію, хоча сама колекція в актуальному стані.

```http request
GET /resources
```

```http
HTTP/1.1 200 OK

{
  "data": [
    //... 
  ], 
  "messages": [
    {
      "level": "info",
      "type": "SHIPPINH_METHOD_MISMATCH",
      "message": "Order AU001 has incorrect carrier. Requested 'USPS' Actual 'FedEx'."
    },
    {
      "level": "warning",
      "type": "ELEMENT_DATA_IS_NOT_FRESH",
      "message": "Order RM002 has las update 2 days ago."
    }
  ]
}
```

Ось такого роду помилки не зручно передавати в messages, адже доведеться якимось чином з'ясовувати, до якого саме
елементу колекції відноситься помилка. Куди зручніше записувати такі попередження як частину інформації про елемент.

```http 
HTTP/1.1 200 OK

{
  "data": [
    {
      "number": "AU001",
      // ... ,
      "messages": [
        {
          "level": "warning",
          "type": "SHIPPINH_METHOD_MISMATCH",
          "message": "Order AU001 has incorrect carrier. Requested 'USPS' Actual 'FedEx'."
        }
      ]
    },
    {
      "number": "RM002",
      // ... ,
      "messages": [
        {
          "level": "warning",
          "type": "DATA_IS_NOT_FRESH",
          "message": "Order RM002 has las update 2 days ago."
        }
      ]
    }
  ]
}
```

Відповідь: лише технічна інформація, про помилку виконання запиту. Тобто перший варіант.

## 1.13 Опис серверів в маніфесті ❌ ❌ ❌

Я б виділив декілька проблем:

1. *В маніфесті не можна явно вказати тип сервера: які є зеркалами один одного, які тестові, а які просто різні.*
2. *Маніфести не можна явним чином наслідувати один від одного*
3. *Не можна вказати ім'я сервера, щоб якось ідентифікувати його в коді*

Перша та друга проблема є лише теоритичним, та поки немає реальних кейсів, що потребують їх вирішення. Тому я 
би відклав їх. Але залишу свої думки по способам їх розв'язання.

**Перша проблема**

Для розв'язання першої та третьої проблеми, можна зробити кастомний атрибут, який вказував би на те, які сервера є 
дзеркалами один одного, а які ні, та заодно назвати їх. Наприклад назвемо цей атрибут `x-servers`:

```yaml
servers:
  - url: https://pu-orders-1
  - url: https://pu-orders-2
  - url: https://tr-orders
  - url: https://au-orders
x-servers:
  - PartsUnlimited: 
      - https://pu-orders-1
      - https://pu-orders-2
  - TuckerRocky:
      - https://tr-orders
  - Autodist:
      - https://au-orders
```

В коді можна генерувати під кожне ім'я з x-server окремий інтерфейс, який буде однозначно відповідати набору 
серверів, що є дзеркалами один одного.

Перевагами цього методу є те що він повністю вирішує одразу дві проблеми. Недоліком є часткове дублювання інформації, а
також те, що цей атрибут не є частиною стандарту.

**Друга проблема**

Розв'язувати другу проблему простим чином не вдасться, оскільки наслідування можливе лише для схем, що вже не мало, але 
не покриває усі потреби. Єдине що ми можемо це звести до максимум перевикористання наступних 
[компонентів](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#components-object):

- responses
- parameters
- examples
- requestBodies
- headers
- securitySchemes
- links
- callbacks

Але це буде саме перевикористання, якщо вам потрібно буде змінити об'єкт responses (наприклад додати новий http 
статус код), то вам доведеться копіювати старий об'єкт response та вносити до нього зміни. Надалі ми можемо 
написати якись механізм, який буде перевіряти, що компоненти правильно наслідуються один від одного, але це 
явно не першої пріоритетності завдання. 

**Третя проблема**

Вирішити цю проблему можна декількома способами. 

1. Додавання атрибуту x-servers, як вказано при вирішені першої проблеми.
2. Використовувати поле description для того щоб вказати ім'я сервера
3. Генерувати ім'я сервера на основі url

Я поки схильний до третього варіанту, але з деякими але. Фактично щоб згенерувати на основі url унікальне ім'я
потрібно брати весь url: протокол, домен, шлях, що зробить імена досить великими і незручними. Зате допоможе
запобігти ситуації коли для наступних серверів згенерується однакове ім'я:

```yaml
servers:
  - url: http://pu-orders/openapi
  - url: https://pu-orders/openapi
  - url: https://pu-orders/openapi/something
```    

Я би запропонував, щоб ім'я генерувалось максимально коротким з можливих. Наприклад для початку намагаємось 
згенерувати унікальне ім'я лише на основі домену (PuOrders в випадку вище). Якщо ім'я вийшо не унікальним і співпадає у
двох сервері, до додаємо до нього шлях та/або протокол (ex. HttpPuOrdersOpenapi, HttpsPuOrdersOpenapi), щоб ім'я
стало унікальним.

## 1.14 Як працювати з маніфестами при розробці ✅ ❌ ❌

Проблема з тим як вказувати локальні (localhost) сервера в маніфесті наштовхнула мене на питання "а навіщо нам це
потрібно?". Очевидна відповідь - для тестування при локальній розробці. Але ідея про те що нам потрібно тестувати
надсилання http запитів, а тим паче те що при тестах потрібно локально розвернути усі мікросервіси, та тестувати їх як 
одне ціле викликає сумніви.

Мені здається для того, щоб визначитись з тим як вказувати локальні сервери в маніфесті потрібно спочатку дати відповідь 
на питання "як ми тестуємо мікросервіси?". Зважаючи на всю широкість цього питання я пропоную відкласти його, та 
поки у нас не буде відповіді зробити проміжне рішення, що буде задовільняти наші потреби на данному етапі.

### Чи вказувати локальні сервери в маніфесті?

Мені здається що це погана ідея, яка принесе нам більше проблем ніж вигоди. Вважаю я так через ряд наступних проблем:
- Потрібно розв'язувати питання: яким чином забезпечити у локальній середі (на комп'ютері розробника) коректність 
запитів до усіх локальних серверів, що вказані в маніфесті.
- Наявність зайвої інформації в маніфесті. Вказанням одного локального сервера інколи не обійдешся: якщо потрібно
тестувати запити до різних серверів. Для забезпечення потреб в тестуванню для усіх клієнтів потрібно вказувати хоча б 
по одному локальному серверу для кожного продакшн серверу. Таким чином в нас буде засмічуватись розділ servers
локальними серверами. Об'єктивною проблемою це не назвеш, але мені хотілось би цього запобігти.
- Розробник обмеженний серверами, які завчасно вказані в маніфесті, що може бути проблемою при генерації сторонніх
маніфестів.

Я пропоную вказувати в маніфесті тільки продакшн сервера, та тестові. Проблеми з наявністю тестових серверів я не 
бачу, оскільки вони мають стабільні url. 

Для того, щоб при розробці відправляти запити локально ми можемо передбачити якісь механізми в нашому генераторі.
Наприклад можливість вказувати аліаси для продакшн серверів, на які будуть відправлятись запити, якщо застосунок
знаходиться в dev оточенні. А якщо такі аліаси не вказані, оточення дорівнює dev і ми намагаємось відправити запит,
то просто кидати виключення. 

## 1.15 Rql support ❌ ❌ ❌

В специфікації URL явно не вказано в якому форматі повинна бути query частина, тобто це може бути будь-який рядок.
Але в openapi специфікації query обов'язково повинно бути у форматі ключ=значення. Тому хоч з точки зору URL запис
`mydomain.com?eq(id,1)` коректний, але в openapi маніфесті його ніяк не опишеш. Детальніше:
[issue #1502](https://github.com/OAI/OpenAPI-Specification/issues/1502). Можливо з виходом нових версій закриють цю 
проблему і ми зможемо в нормальному форматі описати rql, але поки доведеться шукати компроміси.

Є два підходи до вирішення цієї проблеми:

### Намагатись записати rql в форматі ключ=значення
  
Наприклад, перше, що спадає на думку - записувати rql в query параметр з назвою rql: 
`mydomain.com?rql=limit(1,10)&eq(id,1)`. Але це рішення не підходить, тому що виникає проблема з тим, що частини rql 
розділяються амперсандом, так само як і query параметри, що спричиняє конфлікт. 

Тоді рішенням може бути розділення rql на декілька логічних частин і записувати їх в різні параметри: limit, query, sort.
Наприклад `mydomain.com?limit=limit(1,10)&query=eq(id,1)`. Таке рішення не гарантує повної підтримки rql, наприклад,
запит `eq(foo,3)&lt(price,10)` в такому вигляді не вдасться записати, але його можна замінити на еквівалентний
`and(eq(foo,3),lt(price,10))`.

Головним мінусом такого рішення є те, що нам доведеться переписувати датастори, на підтримку нового формату rql.
Також неприємно те, що ми фактично винаходимо новий стандарт натхнений rql.

```yaml
"/resources":
    get:
      parameters:
        - name: query
          in: query
          required: false
          schema:
            type: string
            example: 'and(eq(field1,value1),eq(field2,value2))'
        - name: limit
          in: query
          required: false
          schema:
            type: integer
            default: 20
            example: 20
        - name: offset
          in: query
          required: false
          schema:
            type: integer
            default: 0
            example: 0
        - name: sort
          in: query
          required: false
          schema:
            type: string
            example: -field1
        - name: select
          in: query
          required: false
          style: form
          explode: false
          schema:
            type: array
            items:
              type: string
            example: field1,field2
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ResourceListResult"
```

Example: 

```
/resource?query=and(eq(field1,value1),eq(field2,value2))&limit=20&offset=20&sort=-field1&select=field1,field2
```

### Описувати rql через кастомний атрибут

Ми можемо придумати власний атрибут в маніфесті, який буде вказувати, що колекція підтримує rql запити. Наприклад:

```yaml
"/resources":
    get:
      x-rql:
        query:
          depth: 10
        limit:
          limit:
            default: 20
            min: 0
          offset:
            default: 0
            min: 0
        select:
          allowed-fields:
            - field1
            - field2
          # or
          restricted-fields:
            - field3
            - field4
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ResourceListResult"
```

Мені таке рішення подобається більше, адже воно позбавлене недоліків попереднього, та якщо openapi все-таки зроблять
підтримку формату query відмінну від application/x-www-form-urlencoded то буде простіше на неї перейти.

Мінусом такого рішення звісно буде те, що стороні інструменти не будуть вміти коректно обробляти цей описа. Наприклад 
swagger-ui просто покаже, що у операції є розширені властивості, але не буде ніякого поля куди можна вписати 
rql (хоча ми завжди можемо дописати swagger-ui).

![Swagger ui rql extension](img/specification/swagger-ui-rql-externsion.png)

## 1.16 Обробка помилок

### 1.16.1 Значення статус коду

Статус код визначає лише успішність виконання поточної http операції (хоча й результат операції може описувати 
попередні операції). Добре ци видно на прикладі з асинхроними задачами.

Припустимо, що ми хочемо створити нову статтю. У нашого Api стаття характеризується полями: title, description та 
author. Серед яких title та author - обов'язкові. Також зазвичай створення нової статті - це синхроний процес, але в 
деяких випадках система буває перенавантаженою, та відкладає створення нових ресурсів у чергу.

Розглянемо варіант створення статті, при якому відбувається помилка: в запиті відсутнє обов'язкове поле author, для
двох випадків:

**1. Синхронне створення**

Запит

```http request
POST /articles
Content-Type: application/json

{
  "title": "Hello, world!"
}
```

Оскільки POST операцію (тобто створення) не вдалось виконати, то у відповідь повернеться код помилки 400 Bad Request 
(чому він можна глянути [тут](https://stackoverflow.com/questions/3290182/which-status-code-should-i-use-for-failed-validations-or-invalid-duplicates))
та деякий об'єкт що описує помилку (поки не будемо вдаватись в формат об'єкту).

**2. Асинхронне створення**

Візьмемо запит з попереднього пункту, та допустимо, що операція створення відклалась в чергу через перенавантаження
системи. В такому випадку у відповіді повернеться 202 Accepted код, який сигналізує що запит прийнято, але ще не 
опрацьовано, а також посилання на ресурс задачі, через який можна відслітковувати стан виконання операції.

```http
HTTP/1.1 202 Accepted 
Location: /articles/tasks/1
```

Після чого ми відправляємо запит на отримання стану виконання операції:

```http request
GET /articles/tasks/1
```

Якщо задачу, ще не завершено, та get запит відпрацював успішно, то у відповідь ми разом із станом задачі отримаємо код 
200 OK. Вже на цьому етапі варто помітити, що хоч і операція виконується асинхроно код на GET запит повертається 200, а
не 202. Тому що цей код визначає саме успішність **операції по отриманню** ресурсу `/articles/tasks/1`, який вже 
описує стан минулого запиту (POST /articles).

Так само, після того, як до створення статті дійте черга та валідатор помітить, що поле `autor` відсутнє, то ми у 
відповідь на `GET /articles/tasks/1` отримаємо 200 код, а не 400, а в тілі відповіді буде об'єкт з описом помилки 
(звісно при умові, що сам GET запит відпрацював успішно, тобто не виникло ніяких проблем з мережею і т.п.). 

### 1.16.2 Формат опису помилки 

В нас прийнято описувати помилки в полі `messages` об'єкту відповіді. Типовий варіант опису помилки виглядає наступним
чином:

```http
HTTP/1.1 500 Internal Server Error

{
  "messages": [
    {
      "level": "error",
      "type": "DATABASE_PROBLEM",
      "message": "Database not available. Try again later."
    }
  ]
}
```

В цьому форматі на мою думку є недоліки. Пройдемось по деяким з них.

**Використання [RFC-5424](https://www.rfc-editor.org/rfc/rfc5424) рівнів**

> ```
> 0       Emergency: system is unusable
> 1       Alert: action must be taken immediately
> 2       Critical: critical conditions
> 3       Error: error conditions
> 4       Warning: warning conditions
> 5       Notice: normal but significant condition
> 6       Informational: informational messages
> 7       Debug: debug-level messages
> ```
> [Section 6.2.1 RFC-5424](https://www.rfc-editor.org/rfc/rfc5424#section-6.2.1)

Ці рівні створювались як частина повідомлення для журналу подій системи. Вони описують саме важливість повідомлення 
про РОБОТУ СИСТЕМИ, при цьому клієнт та сервер - дві різні системи й одна і та сама помилка може мати різний вплив
на них.

Розберемо на прикладі. Припустимо, що *в коді сервера є синтаксична помилка, яка заважає виконанню усіх запитів*

Для сервера це помилка рівня Emergency - система не працездатна. 

Для клієнтів які відправляють запити на сервер це виглядає як помилка сервера (5хх код). Який це рівень помилки для
клієнта? Залежить від клієнта:
- Emergency - якщо через помилки сервера клієнт повністю втратив свою працездатність по всьому функціоналу. Наприклад
сервер проводив авторизацію, без якої клієнт взагалі не може працювати.
- Alert - якщо клієнт потребує негайного втручання (я так розумію що при цьому частина його функціоналу працює)
- Critical - важко уявити
- Error - якщо певний функціонал клієнта не працює, при цьому працює інший.
- Warning - якщо помилка сервера не впливає на функціонування клієнта. Наприклад клієнт не зміг перевірити чи існує
нова версія ресурсу, який є у нього в кеші в актуальному стані. 
- Notice, Information, Debug - з таким рівнем може записуватись додаткова інформація (який запиту був відправлений і 
т.п.)

Сервер не може знати про те на скільки його функціонування є важливим для конкретного клієнта, сам клієнт повинен 
вирішувати це.

**Массив помилок замість однієї помилки**

Це трохи ускладнює клієнта, оскільки обробка массиву завжди трохи складніша ніж обробка одного елементу цього массиву. 
При цьому реальну ситуацію, коли сервер повинен повернути декілька помилок важко уявити. Якщо сервер зіштовхнувся з 
якоюсь помилковою ситуацію, яка заважає подальшому виконанню, то він повинен відразу закінчити своє виконання і 
повернути цю помилку. Якщо ж помилкова ситуація тако, що не заважає подальшому виконанню, то це не помилка, а 
попередження, яких може бути декілька штук.

**Не використовується готовий стандарт**

Замість того, щоб вигадувати власний формат, можна скористатись форматом зі стандарту 
[RFC-7807](https://www.rfc-editor.org/rfc/rfc7807) з медіа типом `application/problem+json`.
Я пропоную розширювати його під наші потреби замість того щоб видумувати з нуля власний формат. 

Об'єкт опису помилки в цьому стандарті містить наступні поля:

- `title` (string) - engineers-readable повідомлення з коротким описом типу помилки.
- `detail` (string) - human-readable повідомлення з детальним описом помилки.
- `status` (number) - http статус код, що описує помилку (якщо я правильно зрозумів, то може не завжди відповідати 
статус коду, що повернувся у відповіді, наприклад, якщо помилка описує результат попередньої операції).
- `type` (string) - uri, що описує помилку. Я би наклав на нього обмеження, що це повиненн бути саме urn, тому що він
сюди добре підходить.
 
> Ідея URN виникла внаслідок істотних недоліків системи URL. Ресурси у Всесвітній павутині і Інтернеті переміщуються, 
> а посилання у вигляді URL залишаються, вказуючи на вже відсутні ресурси. Старі URL також робляться непотрібними 
> при реструктуризації ресурсів, перейменуванні, видаленні, переміщенні в інший домен DNS. Для вирішення цієї проблеми 
> була розроблена ефективна система PURL (англ. Persistent Uniform Resource Locator — постійний URL), зараз широко 
> використовувана, а також система DOI (англ. Digital Object Identifier — ідентифікатор цифрового об'єкта). Але це все 
> ж лише часткові вирішення проблеми. Принциповим же рішенням повинен стати стандарт однакового іменування ресурсів 
> URN. URN вказує незмінне ім'я ресурсу без зазначення його місцезнаходження і способу звернення. В результаті 
> URN-імена постійні, вони не залежать від конкретних серверів і протоколів. Іншими словами, URN концептуально позначає 
> сам ресурс , а не місце, де знаходиться якийсь ресурс (а може, вже не знаходиться), як це робить URL. Наприклад, є 
> людина на ім'я Михайло Петренко, який живе в Києві за адресою вул. Земляний вал, 14. Якщо хтось запитає його: 
> «Ви хто?», Він, зрозуміло, відповість «Я — Михайло Петренко». Адже він не скаже: «Я людина, що живе на Земляному 
> валу, 14». Так от URN ідентифікує людину як «Михайло Петренко», а URL лише повідомляє, що хтось живе за адресою 
> вул. Земляний вал, 14 (а може там знаходиться і організація … URL цього не повідомляє).
> 
> *[Wikipedia](https://uk.wikipedia.org/wiki/URN)*

- `instance` (string) - uri конкретно цього випадку проблеми (в нашому випадку це lifecycle_token)
- Інші довільні поля специфічні для конкретного типу помилки

На прикладі це виглядає наступним чином:

Запит

```http request
POST /articles
Content-Type: application/json

{
  "payload": {
    "title": "Hello, world!"
  }
}
```

Відповідь

```http
HTTP/1.1 400 Bad Request
Content-Type: application/problem+json
```

```json
{
  "type": "urn:problem-type:rollun:inputValidationProblem",
  "instance": "urn:lifecycle-token:d9e35127e9b14201a2112b52e52508df",
  "status": 400,
  "title": "Validation error",
  "detail": "There is no author in request body",
  "issues": [
      {
        "type": "urn:problem-type:rollun:inputValidationProblem:schemaViolation",
        "in": "body",
        "name": "author",
        "detail": "Field author is mandatory"
      }
  ]
}
```

> Формат поля `type`:
>
> `urn:problem-type:<org>:[<api>]:<type>`
>
> де:
>
> `<org>`: ідентифікатор організації (rollun)
>
> `<api>` [необов'язковий]: назва api (title маніфесту), для специфічних помилок конкретного API
>
> `<type>`: тип помилки в lowerCamelCase
> 
> Типи помилок, за можливості, потрібно робити незалежними від конкретного API

> Формат поля `instance`:
> 
> `urn:lifecycle-token:<lifecycle-token>`

> Поле `issues` специфічне для типу помилки `urn:problem-type:rollun:validationError`

Openapi schema:

```yaml
Problem:
      description: A Problem Details object (RFC 7807)
      type: object
      required:
        - type
        - title
        - status
        - detail
        - instance
      properties:
        type:
          type: string
          format: uri
          description: An absolute URI that identifies the problem type
        title:
          type: string
          description: |
            A short, summary of the problem type. Written in English and readable for engineers (usually not suited 
            for non technical stakeholders and not localized).
          example: Service Unavailable
        status:
          type: integer
          format: int32
          description: The HTTP status code generated by the origin server for this occurrence of the problem.
          minimum: 400
          maximum: 600
          exclusiveMaximum: true
          example: 503
        detail:
          type: string
          description: A human-readable explanation specific to this occurrence of the problem
        instance:
          type: string
          format: uri
          description: Lifecycle token
```

Оскільки нам також потрібно якось записувати попередження, то потрібно трохи доповнити цей стандарт. Є два шляхи:
1. Винести проблему у форматі application/problem+json в поле problem, а попередження повертати в полі warnings

```json
{
  "problem": {
    "type": "urn:problem-type:rollun:inputValidationProblem",
    "instance": "urn:lifecycle-token:d9e35127e9b14201a2112b52e52508df",
    "status": 400,
    "title": "Validation error",
    "detail": "There is no author in request body"
  },
  "warnings": [
    {
      "type": "urn:warning-type:deprecation",
      "title": "Deprecation",
      "details": "Field 'field1' is deprecated"
    }
  ]
}
```

2. Додати поле warnings як частину об'єкта проблеми

```json
{
  
  "type": "urn:problem-type:rollun:inputValidationProblem",
  "instance": "urn:lifecycle-token:d9e35127e9b14201a2112b52e52508df",
  "status": 400,
  "title": "Validation error",
  "detail": "There is no author in request body",
  "issues": [
    {
      "type": "urn:problem-type:rollun:inputValidationProblem:schemaViolation",
      "in": "path",
      "name": "supplier",
      "detail": "Supplier 'not-exist' is not in enum"
    }
  ],
  "warnings": [
    {
      "type": "urn:warning-type:deprecation",
      "title": "Deprecation",
      "details": "Field 'field1' is deprecated"
    }
  ]
}
```

Я думаю краще обрати перший варіант

### 1.16.3 Попередження

Випадки в яких може повертатись попередження:
- *Виникли помилки, що не завадили виконанню операції* (наприклад при створенні замовлення клієнту не змогло 
відправитись оповіщення по email). 
- *Клієнт не дотримується рекомендацій по використанню API* (наприклад не передає в запиті поле, що не обов'язкове, але 
рекомендоване)

Попередження повинні бути записані в массив `warnings`. Який присутній і в успішній відповіді і відповіді з помилками

Формат попередження: 
- `type` - urn з типом помилки
- `title` - engineers-readable повідомлення з коротким описом попередження.
- `details` - human-readable повідомлення з коротким описом попередження.

Поля `level` спеціально немає, тому що одне і те саме попередження для кожного клієнта може бути по різному важливим.
Тому клієнт сам по типу попередження повинен вирішити на скільки воно критичне для нього.

### 1.16.4 Стандартні типи помилок

#### 1.16.4.1 InputValidationProblem

- **Status code**: 400 Bad Request
- **Title**: Validation problem
- **Description**: Вхідне повідомлення не пройшло валідацію. Деталі описані у полі `issues`. `issue` тип 
`urn:problem-type:rollun:inputValidationProblem:schemaViolation` означає, що повідомлення не пройшло валідацію 
openapi схеми.

Openapi schema

```yaml
InputValidationProblem:
  type: object
  allOf:
    - $ref: "#/components/schemas/Problem"
  properties:
    issues:
      type: array
      items:
        $ref: "#/components/schemas/InputValidationIssue"
InputValidationIssue:
  type: object
  properties:
    type:
      type: string
    in:
      type: string
      enum:
        - body
        - header
        - path
        - query
    name:
      type: string
    detail: 
      type: string
```

Запит

```http request
GET /suppliers/not-exist/orders
```

Відповідь

```http
HTTP/1.1 400 Bad Request
Content-Type: application/rollun.problem+json
```

```json
{
  "problem": {
    "type": "urn:problem-type:rollun:inputValidationProblem",
    "instance": "urn:lifecycle-token:d9e35127e9b14201a2112b52e52508df",
    "status": 400,
    "title": "Validation error",
    "detail": "There is no author in request body",
    "issues": [
      {
        "type": "urn:problem-type:rollun:inputValidationProblem:schemaViolation",
        "in": "path",
        "name": "supplier",
        "detail": "Supplier 'not-exist' is not in enum"
      }
    ]
  }
}
```

#### 1.16.4.2 Missing Permission

- **Status code**: 403 Forbidden
- **Title**: Missing Permission
- **Description**: Клієнт не має дозволу на запуск цієї операції.

Запит

```http request
PUT /parts-unlimited/orders
Authorization: Bearer ds4d2f13sdds2q13qxcgbdf245
```

Відповідь

```
HTTP/1.1 403 Forbidden
Content-Type: application/problem+json
```

```json
{
   "type": "urn:problem-type:rollun:missingPermission",
   "instance": "urn:lifecycle-token:d9e35127e9b14201a2112b52e52508df",
   "status": 403,
   "title": "Missing Permission",
   "detail": "Not permitted to update the order of this supplier"
}
```

#### 1.16.4.3 Resource Not Found

- **Status code**: 404 Not Found
- **Title**: Resource Not Found
- **Description**: Сервер не знайшов ресурс, або не бажає розкривати клієнту його існування. Ця помилка не вказує на
те чи ресурс тимчасово не доступний, чи його не існує взагалі (код 410 в приорітеті, якщо сервер точно знає, що 
відсутність ресурсу постійна). В полі `details` міститься детальніша інформація чому ресурс не знайдено. 

Запит

```http request
GET /parts-unlimited/orders/123
```

Відповідь

```http
HTTP/1.1 404 Not Found
Content-Type: application/problem+json
```

```json
{
   "type": "urn:problem-type:rollun:missingPermission", 
   "instance": "urn:lifecycle-token:d9e35127e9b14201a2112b52e52508df",
   "status": 404,
   "title": "Resource Not Found",
   "detail": "The order with number '123' never existed or has been deleted."
}
```

#### 1.16.4.4 Too Many Requests

- **Status code**: 429 Too Many Requests
- **Title**: The request limit has been reached
- **Description**: Клієнт вичерпав ліміт запитів в поточному лімітному вікні.

Запит

```http request
GET /parts-unlimited/orders/123
```

Відповідь

```http
HTTP/1.1 429 Too Many Requests
Content-Type: application/problem+json
x-ratelimit-limit: 60
x-ratelimit-remaining: 0
x-ratelimit-reset: 1372700873
```

```json
{
   "type": "urn:problem-type:rollun:tooManyRequests",
   "instance": "urn:lifecycle-token:d9e35127e9b14201a2112b52e52508df",
   "status": 429,
   "title": "The request limit has been reached",
   "detail": "No more requests accepted before 2013-07-01T17:47:53.000Z"
}
```

#### 1.16.4.5 Internal Server Error

- **Status code**: 500 Internal Server Error
- **Title**: Internal Server Error
- **Description**: Сервер зіштовхнувся с помилкою, яку не знає як обробляти.

Запит

```http request
GET /parts-unlimited/orders/123
```

Відповідь

```http
HTTP/1.1 500 Internal Server Error
Content-Type: application/problem+json
```

```json
{
   "type": "urn:problem-type:rollun:internalServerError",
   "instance": "urn:lifecycle-token:d9e35127e9b14201a2112b52e52508df",
   "status": 500,
   "title": "Internal Server Error",
   "detail": "Null pointer exception while executing 'Order::create'."
}
```

#### 1.16.4.6 Bad Gateway

- **Status code**: 502 Bad Gateway
- **Title**: Bad Gateway
- **Description**: Сервер, діючи як шлюз (gateway) або проксі некоректну відповідь (або яку не знає як обробляти) від
  висхідного сервера. На мій полгяд є сенс використовувати цей код у всіх ситаціях (якщо немає очевидно кращого коду),
  коли сервер не може виконати запит, через те що отримав некоректну відповідь від іншого сервера. Але це не стосується
  ситуацій, коли сервер отримав цілком легальну помилку від іншого сервера, яку знає як обробляти (Наприклад висхідний
  сервер, що відправляє електроні листи повернув помилку, що заданого email не існує).

Запит

```http request
GET /autodist/orders/123
```

Відповідь

```http
HTTP/1.1 502 Bad Gateway
Content-Type: application/problem+json
Retry-After: 120
```

```json
{
   "type": "urn:problem-type:rollun:badGateway",
   "instance": "urn:lifecycle-token:d9e35127e9b14201a2112b52e52508df",
   "status": 502,
   "title": "Bad Gateway",
   "detail": "Cannot fulfill request because autodist api returned 500 Internal Server Error"
}
```

#### 1.16.4.6 Service Unavailable

- **Status code**: 503 Service Unavailable
- **Title**: Internal Server Error
- **Description**: Сервер тимчасово не доступний, або не може виконати операцію через недоступність серверів від
яких він залежить. Якщо відоммо час, коли сервер відновить роботу, то він повинен бути зазначенний у хедері 
Retry-After

Запит

```http request
GET /autodist/orders/123
```

Відповідь

```http
HTTP/1.1 503 Service Unavailable
Content-Type: application/problem+json
Retry-After: 120
```

```json
{
   "type": "urn:problem-type:rollun:internalServerError",
   "instance": "urn:lifecycle-token:d9e35127e9b14201a2112b52e52508df",
   "status": 503,
   "title": "Service Unavailable",
   "detail": "Autodist api is temporarily unavailable. Please try again after 120 seconds."
}
```
#### 1.16.4.7 Gateway Timeout

- **Status code**: 504 Gateway Timeout
- **Title**: Gateway Timeout
- **Description**: Сервер, діючи як шлюз (gateway) або проксі не дочекався відповіді від висхідного серверу
  Запит

```http request
GET /autodist/orders/123
```

Відповідь

```http
HTTP/1.1 504 Gateway Timeout
Content-Type: application/problem+json
Retry-After: 120
```

```json
{
  "type": "urn:problem-type:rollun:gatewayTimeout",
  "instance": "urn:lifecycle-token:d9e35127e9b14201a2112b52e52508df",
  "status": 504,
  "title": "Gateway Timeout",
  "detail": "Cannot fulfill request because autodist api request is timeout"
}
```

### 1.16.5 Помилки, що не мають http відповіді

Деякі помилки виникають через те що сервер або не зміг відправити запит, або не отримав ніякої відповіді. Для таких 
випадків немає http кодів (адже вони застосовуються у відповіді якої в даних ситуація просто немає), так само як
і немає сенсу описувати тіло відповіді, якої немає. Ці випадки клієнт сам повинен коректно визначати та обробляти.

Перелік таких помилок:
- Request Timeout
- DNS errors
- Connection errors

### 1.16.6 Помилки автозакупки

Усі перераховані нище помилки повертаються з кодом 400 Bad Request.

- `urn:problem-type:rollun:autobuy:orderAlredyExist` - замовлення з переданим ключем ідемпотентності вже існує, але
ми не можемо повернути інформацію про це замовлення (така ситуація може виникати в TR)
- `urn:problem-type:rollun:autobuy:itemsNotAvailable` - замовлення не може бути створенним, тому шо 
товару немає в наявності
- `urn:problem-type:rollun:autobuy:unknownShippingMethod` - постачальник не має переданного способу 
доставки
- `urn:problem-type:rollun:autobuy:unavailableShippingMethod` - постачальнику відомий спосіб відправки,
але він не може створити з ним данне замовлення (пояснення чому буде в details). 
- `urn:problem-type:rollun:autobuy:unknownItem` - помилка конвертації rid -> csn, тому що заданний
rid не існує для данного постачальника
- `urn:problem-type:rollun:autobuy:invalidAddress` - некоректний та/або неіснуючий адрес

### 1.16.7 Попередження автозакупки

- `urn:problem-type:rollun:autobuy:requestMismatch` - дані створенного замовлення не відповідають 
даним запиту.

# 2. Openapi генератор

## 2.1 Архітектура ❌ ❌ ❌

Згенерований код складається з декількох рівні, що розміщені в заданому порядку, та кожен є абстракцією над попереднім 
рівнем. Кожен рівень відповідає своїм функціям, та за потреби може використовувати, або не використовувати рівні, що 
знаходяться нижче. Та не може використовувати рівні, що знаходяться вище.

Ідея рівнів натхнена [мережевою моделлю OSI](https://uk.wikipedia.org/wiki/%D0%9C%D0%B5%D1%80%D0%B5%D0%B6%D0%B5%D0%B2%D0%B0_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_OSI),
та умовно рівні генератора можна розглядати як продовження цієї моделі: перший рівень згенерованого коду, це сьомий
рівень OSI з якого використовується лише http. Хоча у нас немає на меті створити продовження OSI моделі та це порівняння
приведено лише для загального розуміння ідеї. А в деяких конкретних випадках у нас можуть бути відмінності від OSI
моделі.

Кожен рівень містить інтерфейс-обробник, що буде оброблювати запит та структури даних необхідні для цього інтерфейсу. А
також:
- за можливості, стандартні реалізації цього інтерфейсу, що будуть конвертувати структури даних між рівнями.
- Валідатори запиту/відповіді
- Серіалізатори запиту/відповіді
- і т.п.

> Слова запит та відповідь вжито в загальному сенсі, як прохання щось виконати та результат роботи. Тобто це не завжди
> http запит/відповідь. Наприклад на останньому рівні, замість слова запит(Request), використовується Command, щоб
> якомога більше абстрагувати його від http рівня.

Схематично це можна показати так:

![Layers](../docs/img/arch/layers.jpg)

> Тут і надалі для того, щоб відрізняти структуру запиту на Openapi та Http рівнях я буду використовувати відповідно
> назви Openapi\Request та Psr\Request. Де:
> - `Openapi\Request` - наша власна структура запиту, про яку буде написано пізніше
> - `Psr\Request` - структура запиту з [PSR-7](https://www.php-fig.org/psr/psr-7/) рекомендацій
>
> При цьому при реалізації реальні назви будуть відрізнятись. Наприклад `Psr\Request` насправді
> `Psr\Http\Message\RequestInterface`.
>
> Аналогічна ситуація з `Openapi\Response` та `Psr\Response`.

Converter - на діаграмі вище, це реалізація інтерфейсу-обробника, що генерується на кожному з рівнів (про який
згадувалось вище).

| Рівень     | Функції                                                        | Запит           | Інтерфейс-обробник | Відповідь        |                                 
|------------|----------------------------------------------------------------|-----------------|--------------------|------------------|
| 3. Rollun  | Реалізація максимальної підтримки специфікації нашої компанії. | Command         | Handler            | Result           |
| 2. Openapi | Реалізація функцій загальних для будь-якого openapi маніфесту  | Openapi\Request | Operation          | Openapi\Response |
| 1. Http    | Реалізація передачі даних через http протокол                  | Psr\Request     | RequestHandler     | Psr\Response     |

В більшості випадків код, що буде писати програміст можна вважати 4-м рівнем, який реалізовує інтерфейси з Rollun рівня.
Але обмежень немає, та за потреби код може писатись під будь-який рівень. Наприклад можна замінити бібліотеку, якою
відправляються http запити, чи доповнити логіку конвертації об'єктів запиту/відповіді між рівнями.

Потрібно зазначити, що openapi специфікація є залежною від http протоколу і проєктується виключно під нього. Про
це можна почитати в issue на github: [#523](https://github.com/OAI/OpenAPI-Specification/issues/523),
[#586](https://github.com/OAI/OpenAPI-Specification/issues/586). Тому останній рівень у нас http, а не, наприклад,
transport чи protocol.

### Різниця між генерацією для сервера і клієнта

Інтерфейс-обробник про який згадувалось вище буде генеруватись в обох випадках: і для сервера і для клієнта, причому
його буде одна копія яка буде знаходитись в окремому від сервера чи клієнт просторі назв, наприклад
`Generator\{manifestName}\Common`. Різниця полягає в тому, що клієнт **використовує** (викликає методи), а сервер
**імплементує** цей інтерфейс.

В більш прикладному плані це означає, що згенерований код для клієнтської частини можна просто почати використовувати,
оскільки там вже буде згенерованно імплементацію інтерфейсу, що буде або конвертувати запит на рівень *нижче*, або
відправляти запит на сервер. А для серверної частини хоч і можуть бути згенеровані стандартні реалізації для нижніх
рівнів, які будуть конвертувати запит на рівень *вище*, але все одно на найвищому рівні програмісту доведеться
створити власну реалізацію.

При цьому потрібно зазначити, що для того що забобігти залежності нижніх рівнів від верхніх для серверної частини
реалізація інтерфейсу буде знаходитись на рівень вище, ніж сам інтерфейс. Оскільки ця реалізація буде викликати
інтерфейс-обробник, що знаходиться на рівень вище, тобто залежати від нього. Схематично це можна показати
наступним чином:

**Cервер**
![Server dependencies](../docs/img/arch/server-deps.jpg)

Для клієнтської частини реалізація інтерфейсу буде на тому ж рівні, що і сам інтерфейс. Тому що ця реалізація буде
конвертувати запит на рівень нижче.

**Клієнт**
![Client dependencies](../docs/img/arch/client-deps.jpg)

Надалі ці деталі ми будемо упускати, показуючи лише структуру запиту/відповіді та сам інтерфейс, без його реалізацій.

### Http рівень

На цьому рівні генерується RequestHandler інтерфейс, що має метод handle, який приймає psr-7 request, та повертає
psr-7 response.

![Http layer](../docs/img/arch/http-layer.jpg)

### Openapi рівень

На цьому рівні знаходяться інтерфейси для підтримки будь-яких маніфестів. Тобто тут не повинно бути рішень, що порушать
роботу з валідним, згідно openapi специфікації, маніфестом, але написаним не за стандартами нашої компанії.

Оскільки на цьому рівні ми забезпечуємо максимальну сумісність з будь-яким openapi маніфестом, то гарне рішення буде
використовувати термінологію з openapi специфікації: операція, запит/відповідь (у тому форматі в якому вони описанні в
специфікації), параметри і т.п.

В цілому цей рівень працює аналогічно попередньому, лише замість RequestHandler інтерфейсу тут Operation інтерфейс,
який відрізняється назвою, але виконує ту саму роль (опрацювати запит) та інша структура запиту і відповіді (така
як в openapi специфікації).

Терміни з openapi специфікації:
- Операція - це унікальна сукупність http методу та url. Наприклад POST /orders та GET /orders це дві різні операції, так
  само як і POST /articles та POST /customers
- [Параметри](https://swagger.io/docs/specification/describing-parameters/) - вхідні дані операції (поряд з тілом
  запиту): заголовки, cookie, query string, path параметри
- Схема - структура даних, що може бути описана в маніфесті. Наприклад тіло запиту, query параметр і т.п

По аналогії з http рівнем для серверної частини реалізація Operation інтерфейсу працює ідентично, та знаходиться на
рівень вище, в Rollun рівні.

![Openapi layer](../docs/img/arch/openapi-layer.jpg)

#### Конвертація: `Psr\Request` -> `Openapi\Request`

Для початку розглянемо структуру OpenapiRequest:

```php
interface OpenapiRequest 
{
    public function getParameters(): Parameters;
    
    public function hasBody(): bool;
    /** @throws RequestHasNotBody */
    public function getBody(): Schema;
}

interface Parameters 
{
    public function hasPathParameter(string $name): bool;
    /** @throws ParametrNotFound */
    public function getPathParameter(string $name): Parameter;
    
    public function hasQueryParameter(string $name): bool;
    /** @throws ParametrNotFound */
    public function getQueryParameter(string $name): Parameter;
    
    public function hasHeaderParameter(string $name): bool;
    /** @throws ParametrNotFound */
    public function getHeaderParameter(string $name): Parameter;
    
    public function hasCookieParameter(string $name): bool;
    /** @throws ParametrNotFound */
    public function getCookieParameter(string $name): Parameter;
}

interface Parameter 
{
    public function getName(): string;    
    public function getValue(): mixed;
}

interface Schema 
{
}
```

Для цих інтерфейсів будуть генеруватись відповідні реалізації для кожного ендпоінту. Наприклад, якщо в маніфесті
описано ендпоінт `POST /orders`, то згенерується реалізація:
```php
class PostOrdersRequest implements OpenapiRequest {
  public function getParameters(): PostOrdersParameters;

  public function hasBody(): bool;
  public function getBody(): Order;
}
```
Відповідно будуть згенеровані й `PostOrdersParameters implements Parameters` та `Order implements Schema`.

Якщо структура запиту може відрізнятись в залежності від медіа типу, то можна згенерувати декілька об'єктів під
кожну зі структур. Але якщо тіло запиту під різними медіа типами має ідентичну структуру, то можна згенерувати лише
один об'єкт.

Наприклад для наступного опису в маніфесті можуть створитись `PostDropshipOrderRequest`,
`PostPickupOrderRequest` об'єкти.

```yaml
paths:
  "/orders":
    post:
      requestBody:
        content:
          application/dropship-order-request:
            schema:
              $ref: '#/components/schemas/PostDropshipOrderRequest'
          application/pickup-order-request:
            schema:
              $ref: '#/components/schemas/PostPickupOrderRequest'
```

А для наступного, лише `PostOrderRequest`.

```yaml
paths:
  "/orders":
    post:
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PostOrderRequest'
          application/xml:
            schema:
              $ref: '#/components/schemas/PostOrderRequest'
```

Загалом для всіх основних полів з `Rsr7Request` є відповідні в `OpenapiRequest`, тому складності в конвертації не
повинно виникнути.

Головне, що потрібно передбачити:
- Конвертація даних в об'єкти з підтримкою поліморфізму (oneOf (дискримінатор), anyOf, allOf)
- Підтримка різних схем при різних медіа типах
- Підтримка різних кодувань
- Десеріалізація/серіалізація query параметрів

#### Конвертація: `Openapi\Response` -> `Psr\Request`

Відбувається зеркально.

#### Валідація схем

Валідація повинна відбуватись перед створенням об'єкта `Openapi\Request` чи `Openapi\Response`. Для валідації є два
загальних підходи.

### Конвертація схеми в правила валідації на етапі генерації

Підхід полягає в тому, що на етапі генерації ми конвертуємо openapi schema в правила валідації. Так роблять
більшість генераторів: symfony, laravel, laminas і т.д 

Наприклад в symfony, наступна openapi схема 

```yaml
User:
  type: object
  properties:
    id:
      type: integer
      format: int64
```

Перетворюється в наступні анотації для symfony валідатора

```php
class User 
{
    /**
     * @var int|null
     * @SerializedName("id")
     * @Assert\Type("int")
     * @Type("int")
     */
    protected $id;

    // ...
}
```

У такого підходу є декілька недоліків:

- Якщо в новій версії генератора змінилась логіка формування правил валідації, то потрібно перегенеровувати усі старі
маніфести
- Сенс формувати такі правила є тільки під якись специфічний генератор (інакше краще використовувати другий метод), що 
створює зайві залежності 
- Додається складність в mustache шаблони (які не занадто гнучкі)

### Конвертація схеми в правила валідації під час виконання коду

Підхід полягає в тому, щоб використовувати валідатор, який приймає аргументами дані і схему, та валідує дані згідно
схеми. В такому випадку не потрібно виконувати конвертацію схеми в правила валідації на етапі генерації коду: валідатор
буде з'ясовувати ці правила прямо під час валідації на основі схеми.

Такий підхід позбавлений недоліків попередноього, але можливо трохи повільніший (хоча на стільки трохи, що немає сенсу
це враховувати при сучасних потужностях комп'ютерів). 

Ще одним потенційним недоліком можна було б відмітити, що складність конвертації схеми в правила валідації переноситься
з генератора(зазвичай mustache шаблонів) на сам валідатор. Але насправді це скоріше перевага, адже код валідатора
буде в будь-якому випадку більш гнучкий ніж mustache шаблони та дозволить позбутись зайвої складності застосуванням
патернів программування та SOLID принципів. 

Такий підхід використовується в Slim, попередній приклад буде виглядати наступним чином:

```php
class User extends BaseModel
{
    protected const MODEL_SCHEMA = <<<'SCHEMA'
      {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      }
      SCHEMA;
}
```

Я б також переніс опис схеми з об'єкта в конфігурацію, оскільки конфігурацію, за потреби, простіше перевизначати та 
доповнювати. 

`config/schemas.php`
```php
return [
    'schemas' => [
        User::class => json_decode(file_get_contents(__DIR__ . '/schemas/User.json'))
    ]
] 
```

`config/schemas/User.json`
```yaml
{
  "type" : "object",
  "properties" : {
    "id" : {
      "type" : "integer",
      "format" : "int64"
    }
  }
}
```

Передбачити:
- Валідація повинна правильно працювати з поліморфізмом (oneOf (дискримінатор), anyOf, allOf)

### Rollun layer

На цьому рівні знаходиться логіка та інтерфейси, що специфічні лише для специфікації нашої компанії. Тут може бути
логіка, яка несумісна з валідними openapi маніфестами, допоки вона (логіка) сумісна з маніфестами написаними за
стандартами нашої компанії.

Реалізацію HandlerInterface повинен забезпечити програміст вже в коді свого застосунку.

![Rollun layer](../docs/img/arch/rollun-layer.jpg)

#### Конвертація `Openapi\Request` -> `Rollun\Request`

`Rollun\Request` - лише інтерфейс (або абстрактний класс), який напряму на створюється, замість нього створюється:
- `Query` - Для GET запиту
- `Command` - Для POST, PUT, PATCH, DELETE запитів

Для усіх інших запитів поки не вирішив.

Інформація для `ClientInfo` береться з відповідних хедерів запиту.

##### Створення `Query`

Цей клас приймає у конструктор QueryString клас, який своєю чергою також буде абстрактним, замість нього буде створено:
- `Rql` - якщо query string це rql
- `KeyValueParams` - для query string яку можна звести до 'ключ => значення' пар
- Для інших випадків можна створити свою реалізацію

##### Створення `Command`

Цей клас подібно до `Query` також може містити `QueryString`, наприклад для PUT, DELETE запитів, який формується
ідентично.

Інформація в payload потрапляє з однойменного поля `payload` в [application/vnd.rollun-request+json](#applicationvndrollun-requestjson))
медіа типі. Інші медіа типи для тіла запиту не підтримуються.

##### Інформація з заголовків та cookie

Уся інша інформація: авторизація, кодування, правила кешування і т.п повинна оброблюватись раніше формування
об'єкту запиту. Та за потреби взагалі його не формувати

Наприклад, якщо користувач не пройшов автентифікацію, то об'єкт запиту взагалі немає сенсу формувати, у якості відповіді
повернеться стандартна помилка.
Теж саме з кешуванням, якщо прийшов запит, який не потрібно виконувати в залежності від умови, то це
повинно вирішитись ще до формування об'єкту запиту.

Для випадків вище клас обробник команди можна зобов'язати імплементувати деякі допоміжні методи. Наприклад,
```php
// Це лише приблизний приклад, при проектуванні ці методи можуть переміститись до інших інтерфейсів,
// змінити свою сігнатуру, з'являться нові методи і т.п. 

interface Handler {
    public function hasEtag(): bool;
    public function getEtag(): string;
    
    public function hasLastModified(): bool;
    public function getLastModified(): DateTimeInterface;
    
    /**
     * @throws UserNotFoundException
     */
    public function authorize(string $username, string $password): User;
    
    public function handle(): Result;
}
```

Якщо програмісту все-таки необхідно обробити специфічний хедер, інформація з якого не доступна на цьому рівні, то
у нього є декілька варіантів:

1. Реалізувати обробку хедера на попередньому рівні (Openapi layer), де доступні усі хедери
2. Успадкуватись від классу `Command` додавши усі необхідні поля, та розширити логіку конвертації `OpenapiRequest`
   -> `Command`, наприклад написавши декоратор.
3. Якщо цей заголовок використовується в багатьох сервісах, то можна додати його до нашої специфікації і відповідно
   випустити нову версію генератора, який розширює класс `Command`

#### Конвертація `Result` -> `Openapi\Response`

На цьому рівні результат операції не містить прямої інформації про заголовки, правила кешування і т.п. Ця інформація
збирається з різних місць і опирається на стандарти нашої компанії.

Наприклад замість того щоб десь явно повертати 200, чи 202 код з обробника повертається об'єкт `Result`, який може бути
як в одному зі статусів `pending`, `fulfilled`, `rejected`, а код вже обирається в залежності від цього статусу.

Код 500 формується виходячи з того чи відбувся ексепшн чи ні.

Медіа тип обирається в залежності від того відбулась помилка чи ні, синхронна операція чи асинхронна і т.п

Etag, Last-Modified і інші хедери отримуються на основі абстрактних методів, які імплементував, чи не імплементував
програміст.

І тому подібне.

Якщо програмісту потрібно втрутитись в процесс конвертації результату в відповідь, наприклад щоб додати специфічний
заголовок, то він повинен це робити створюючи свою імплементацію чи декоратори (або за допомогою інших патернів) для
стандартних інтерфейсів, за допомогою яких відбувається конвертація.

### Взаємодія на одному рівні

По аналогії з мережевою моделью OSI. Інтерфейси на кожному рівні дозволяють застосункам взаємодіяти на одному рівні так,
ніби інших рівнів не існує. Для того, щоб краще це зрозуміти розглянемо на прикладі.

Припустимо, що у нас є клієнт і сервер, які розташовані на різних віртуальних машинах та взаємодіють по http, Вони
обидва працюють з третім рівнем згенерованого коду. На цьому рівні генератор згенерує інтерфейс Handler

```php
namespace Generated\Openapi\{openapiVersion}\{manifestName}\{layer}\UseCase\{Resource}\{OperationId};

interface Handler 
{
    public function handle(Command $command): Result
}
```

При цьому на клієнтській стороні згенерується відразу реалізація для цього інтерфейсу, що сформує http запит
та відправить його на сервер, а отримавши http відповідь конвертує її в об'єкт Result (на справді перед тим як
сформується http запит буде ще сформовано Openapi Request та Psr-7 Request, і аналогічно з відповіддю, але для простоти
пропустимо це). Але для клієнта це все інкапсульовано, він лише взаємодіє з Handler інтерфейсом не знаючи, що конкретна
реалізація цього інтерфейсу відправляє http запити.

На серверній стороні сформується абсолютно ідентичний Handler інтерфейс, який севрер повинний реалізувати.
Але генерується Psr-7 HttpRequestHandler, який отримає запит від клієнта, сформує на його основі команду да передасть її
в реалізацію Handler інтерфейсу, а отриманий Result перетворить в Http відповідь. В цьому випадку взаємодія по http
також інкапсульована від сервера, він лише реалізує Handler інтерфейс не знаючи звідки береться Command і що
робиться з Result який він повернув.

Застосунки і клієнту і серверу взаємодіють з Handler інтерфейсом, який належить третьому рівню, не знаючи, що вони на
справді розташовані на різних віртуальних машинах і взаємодіють по http. Якщо замінити взаємодію по http на якусь іншу,
(тобто замінити рівень transport), то в їх коді нічого не зміниться. Зміниться лише код, що генерується, або залежить
на пряму від першого рівня.

Це й малось на увазі вище у рядку "Інтерфейси на кожному рівні дозволяють застосункам взаємодіяти на одному рівні так,
ніби інших рівнів не існує".

## 2.2 Вибір сервера ❌ ❌ ❌

### 2.2.1 На http рівні

На цьому рівні ніякого вибору сервера не здійснюється, адже вхідний параметр: Psr7\Request вже містить в собі url 
сервера.

### 2.2.2 На openapi рівні 

Вибір сервера, на який буде відправлятись запит буде здійснюватись за допомогою стратегій для `Operation` 
інтерфейсу. Така схема дозволить реалізовувати логіку вибору сервера будь-якої складності.

![Openapi layer server selection](./img/arch/openapi-layer-server-selection.jpg)

На схемі представлено декілька можливих стандартних декораторів:
- `SimpleStrategy` - відправляє запит на один завчасно заданий сервер
- `BalanceLoaderStrategy` - рівномірно розподіляє навантаження між декількома серверами 

#### Генерація server enum

Розглянемо детальніше SimpleStrategy. Візьмемо за приклад маніфест в якому вказані наступні сервери:

```yaml
servers:
  - url: https://api.foo.com/v1
  - url: https://bar.com/v1
  - url: http://bar.com/v1
```

В першу чергу в php повинно згенеруватись enum з усіма серверами:

```php
enum Server 
{
    // Над формуванням назви сервера ще можна подумати
    case HttpsApiFooCom;
    case HttpsBarCom;
    case HttpBarCom;
    
    public function url(): string
    {
        return match($this) {
            Server::HttpsApiFooCom => 'https://api.foo.com/v1',
            Server::HttpsBarCom => 'https://bar.com/v1',
            Server::HttpBarCom => 'https://bar.com/v1',
        };
    }
}
```

Стратегія приймає цей enum у якості сервера, та отримує `baseUrl` за допомогою методу `Server::url()`.
Таким чином у нас буде можливість для тестів успадкуватись від цього маніфесту, та перевизначити `Server::url()`
метод на локальні мок сервера.

### 2.2.3 На rollun рівні

Для генерації коду на цьому рівні в маніфесті повинні бути описані унікальні сервери (які не є зеркалами один одного),
за допомогою кастомного атрибуту x-servers

```yaml
servers:
- url: https://server1-1
- url: https://server1-2
- url: https://server2
x-servers:
- name: Server1
  urls:
    - https://server1-1
    - https://server1-2
- name: Server2
  urls:
    - https://server2
```

Для кожного унікального сервера будуть згенеровані свої реалізації HandlerInterface.

![Rollun layer server selection](./img/arch/rollun-layer-server-selection.jpg)

Через вибір конкретної реалізації і буде здійснюватись вибір сервера. Кожна реалізація буде застосовувати
BalanceLoaderStrategy з рівня openapi між серверами, які вказані в `x-servers.urls` розділі маніфесту

## 2.3 Шлях до згенерованого коду ✅ ❌ ❌

Замість src/{manifestName} код можна генерувати в src/Generated/OpenApi/{generator}/{manifestName}.

Це рішення має ряд переваг:

- В автолоадинг достатньо один раз прописати шлях до src/Generated/OpenApi/{generator}. 
Замість того щоб робити це при кожній генерації нового маніфесту.
- В директорії src стане значно простіше орієнтуватись.
- Папку src/Generated можна ігнорувати при різних аналізах коду (статичний, покриття тестами, код стайл і т.п.)
- Простіше організувати збір конфігурації згенерованого коду (адже ми точно будемо знати де знаходиться увесь 
згенерованний код)

Підтримка можливості обрати куди згенерувати маніфест не потрібна.

Також я би додавав в шлях мажорну версію генератора: src/Generated/OpenApi/{generator}/{generatorVersion}/{manifestName}. 
Це дозволить підтримувати декілька маніфестів, згенерованих різними версіями генератора одночасно (що дозволить
плавніше переходити на нову версію). Особливо це корисно якщо ми усі класи, що потрібні для роботи генератора (
валідатори і т.п.), будемо генерувати в директорію: src/Generated/OpenApi/{generator}/{generatorVersion} , замість того 
щоб тримати їх напряму в бібліотеці openapi-generator. Також в ідеалі генератор, перед генерацією маніфеста, повинен
перевіряти, що цей самий маніфест вже не згенеровано в проекті іншою мажорною версією генератора і пропонувати
видалити його, якщо так. 

## 2.4 Конфігурація ❌ ❌ ❌

### Збір конфігурації

Для кожного маніфесту може генеруватись своя папка з конфігурацією в 
`src/Generated/OpenApi/{generator}/{generatorVersion}/{manifestName}/config`.
В цій папці конфігурація буде представлена набором php файлів, аналогічно як в `config/autoload`.  

В директорію `src/Generated/OpenApi/{generator}/{generatorVersion}` буде генеруватись ConfigProvider, що наслідується 
від `PhpFileProvider`, та збирає конфігурацію з усіх директорі 
`src/Generated/OpenApi/{generator}/{generatorVersion}/*/config`.

```
.
└── src
    └── Generated
        └── Openapi
            └── RollunGenerator
                └── V1
                    ├── Articles
                    │   └── config
                    │       ├── dependecies.global.php
                    │       └── router.global.php
                    └── Orders
                    │  └── config
                    │       ├── dependecies.global.php
                    │       └── router.global.php
                    ├── ConfigProvider.php
```

### Конфігурація роутера

Конфігурація роутингу буде знаходитись в 
`src/Generated/OpenApi/{generator}/{generatorVersion}/{manifestName}/config/router.global.php`в форматі, який ми 
визначимо зручним для генерації, тобто не прив'язаний до ніякого фреймворку чи бібліотеки.

Наприклад symfony генерує [yaml файл](https://github.com/misha-rollun/openapi-generator-tests/blob/master/symfony/5/petstore/Resources/config/routing.yml) 
з усіма роутами:

```yaml
open_api_server_pet_addpet:
  path:     /pet
  methods:  [POST]
  defaults:
    _controller: open_api_server.controller.pet::addPetAction

open_api_server_pet_deletepet:
  path:     /pet/{petId}
  methods:  [DELETE]
  defaults:
    _controller: open_api_server.controller.pet::deletePetAction
  requirements:
    petId: '\d+'
```

Slim генерує класс [RegisterRoutes](https://github.com/misha-rollun/openapi-generator-tests/blob/master/slim/5/petstore/lib/App/RegisterRoutes.php#L39)
в якому конфігурація вказана в полі operations:

```php
class RegisterRoutes
{
    /** @var array[] list of all api operations */
    private $operations = [
        [
            'httpMethod' => 'POST',
            'basePathWithoutHost' => '/api/v3',
            'path' => '/pet',
            'apiPackage' => 'OpenAPIServer\Api',
            'classname' => 'AbstractPetApi',
            'userClassname' => 'PetApi',
            'operationId' => 'addPet',
            'responses' => [
                '200' => [
                    'jsonSchema' => '{
                      "description" : "Successful operation",
                      "content" : {
                        "application/json" : {
                          "schema" : {
                            "$ref" : "#/components/schemas/Pet"
                          }
                        },
                        "application/xml" : {
                          "schema" : {
                            "$ref" : "#/components/schemas/Pet"
                          }
                        }
                      }
                    }',
                ],
                '405' => [
                    'jsonSchema' => '{
                      "description" : "Invalid input"
                    }',
                ],
            ],
            // ...
        ];
```

Конфігураця окремого роута складається з:
- url шлях
- http метод
- контроллера (request handler)
- список middlewares специфічних для окремого роута

В директорію `src/Generated/OpenApi/{generatorVersion}`, буде генеруватись `RouterInterface`,
`Factory\RouterInterfaceFactory` та `RouterCollectorMiddleware`:

- `RouterInterface` - містить методи за допомогою яких можна додати роути ($router->add($method, $path, $middlewares).
- `FactoryRouterInterfaceFactory` - Laminas фабрика, що буде намагатись зрозуміти який роутер використовується в проекті,
  та створювати адаптер для нього (класи адаптерів також будуть згенеровані завчасно, фабрика лише повинна визначити
  який саме адаптер їй використовувати).
- `RouterCollectorMiddleware` буде збирати інформацію про роутинг з конфігурації усіх маніфестів, та додавати її в роутер.

```php
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;

class RouterCollectorMiddleware implements \Psr\Http\Server\MiddlewareInterface 
{
    public function __construct(
        private readonly RouterInterface $router,
        private readonly Config $config // також клас який ми можемо згенерувати
    ) {}
    
    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        $routerConfig = $this->config->getRouterConfig();
        $this->router->addRoutesFromConfig($routerConfig);
        return $handler->handle($request);
    }
}
```

## 2.5 Авторизація ❌ ❌ ❌

### Опис авторизації в маніфесті

В маніфесті ми можемо описати способи авторизації в розділі `components.securitySchemes`, а потім в розділі security,
для окремої операції або глобально, посилатись на ці способи.

Також в маніфесті можна вказати що операція потребує авторизацію **хоча б одним** з перелічених методів, **одночасно**
декількома методами, або комбінований варіант: хоча б одним з перелічених способів, коли кожен спосіб може складатись
одночасно з декількох методів.

Доступні способи авторизації:
- HTTP схеми автентифікації (що використовують заголовок Authorization):
  - [Basic](https://swagger.io/docs/specification/authentication/basic-authentication/)
  - [Bearer](https://swagger.io/docs/specification/authentication/bearer-authentication/)
  - інші HTTP схеми, що визначені в [RFC 7235](https://tools.ietf.org/html/rfc7235) та [HTTP Authentication Scheme Registry](https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml)
- [API ключі](https://swagger.io/docs/specification/authentication/api-keys/) в заголовках, query string або cookies
  - [Cookie authentication](https://swagger.io/docs/specification/authentication/cookie-authentication/)
- [OAuth 2](https://swagger.io/docs/specification/authentication/oauth2/)
- [OpenID Connect Discovery](https://swagger.io/docs/specification/authentication/openid-connect-discovery/)

Приклад маніфесту з використанням основних способів авторизації:

```yaml
openapi: 3.0.3
info:
  title: Security
  description: Security
  version: 1.0.0
servers:
  - url: 'https://example.com'
paths:
  '/basic':
    get:
      security:
        - BasicAuth: []
      responses:
        "200":
          description: Basic authorization
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ResourceListResult"
  '/bearer':
      get:
        security:
          - BearerAuth: []
        responses:
          "200":
            description: Bearer authorization
            content:
              application/json:
                schema:
                  $ref: "#/components/schemas/ResourceListResult"
  '/oauth2':
      get:
        security:
          - OAuth2:
              - read
        responses:
          "200":
            description: OAuth 2 authorization
            content:
              application/json:
                schema:
                  $ref: "#/components/schemas/ResourceListResult"
  '/multiple':
    get:
      security:
        - BasicAuth: []
        - BearerAuth: []
        - OAuth2:
            - read
      responses:
        "200":
          description: OAuth 2 authorization
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ResourceListResult"
components:
  schemas:
    ResourceListResult:
      type: object
      properties:
        data:
          type: array
          items:
            $ref: '#/components/schemas/Resource'
    Resource:
      type: object
      properties:
        id:
          type: string

  securitySchemes:
    BasicAuth:
      type: http
      scheme: basic
    BearerAuth:
      type: http
      scheme: bearer
    OAuth2:
      type: oauth2
      flows:
        authorizationCode:
          authorizationUrl: https://example.com/oauth/authorize
          tokenUrl: https://example.com/oauth/token
          scopes:
            read: Grants read access
```

Детальніше про те як описувати авторизацію в openapi маніфесті: [Swagger - Authentication](https://swagger.io/docs/specification/authentication/)

### Які методи авторизації ми будемо використовувати

Basic - для самих простих варіантів, можливо для взаємодії сервісів всередині приватної докер мережі.

Bearer - простий і універсальний спосіб для будь-яких взаємодій: як всередині приватної докер мережі, так і для фронтенд
запитів.

OAuth2 - для авторизації за допомогою google та інших сторонніх сервісів.

### Генерація серверу

Для початку розглянемо існуючі генератори: Zend, 
[Laminas](https://openapi-generator.tech/docs/generators/php-mezzio-ph/#feature-set), 
[Symfony](https://openapi-generator.tech/docs/generators/php-symfony/#feature-set) не підтримують авторизацію.
У різних випадках або генерується код з помилками, або просто нічого пов'язаного з авторизацією.

Slim4 генератор підтримує авторизацію (хоча чомусь в документації вказано, що ні). 

Основна ідея авторизації в slim полягає в тому, що він генерує клас [`AbstractAuthenticator`](https://github.com/misha-rollun/openapi-generator-tests/blob/master/slim/security/lib/Auth/AbstractAuthenticator.php),
який програміст повинен розширити класами, імена яких збігаються з описаними в маніфесті security схемами: 
`BasicAuthenticator`, `BearerAuthenticator`, `OAuth2Authenticator`. `AbstractAuthenticator` має метод, що приймає 
`Psr\Http\Message\ServerRequestInterface` та повинен виконати авторизацію та записати об'єкт авторизованого користувача
в атрибути запиту:

```php
public function __invoke(ServerRequestInterface &$request, TokenSearch $tokenSearch)
{
   /**
    * Try find authorization token via header, parameters, cookie or attribute
    * If token not found, return response with status 401 (unauthorized)
    */
    $token = $tokenSearch->getToken($request);

    /**
     * Verify if token is valid on database
     * If token isn't valid, expired or has insufficient scope must throw an UnauthorizedExceptionInterface
     */
    $user = $this->getUserByToken($token);

    /**
     * Set authenticated user at attributes
     */
    $request = $request->withAttribute('authenticated_user', $user);

    return true;
}
```

> Звідки береться TokenSearch я не досліджував, адже це якісь особливості бібліотеки авторизації, яка використовується
> в slim і навряд чи це нам потрібно. В загальному випадку одного об'єкту запиту вистачає для будь-якого рівня
> складності авторизації.

> В нашому випадку абстрактний аутентифікатор не повинен займатись отриманням користувача, лише провести 
> аутентифікацію і в залежності від результату відправити або не відправити запит далі по ланцюжку.

Після чого при конфігурації роутингу, slim для кожного роуту, для якого потрібна авторизація прокидує спеціальний
middleware, що проводить авторизацію за допомогою класів, що описані в абзаці вище. Тобто, якщо у нас роут `/basic`
потребує Basic авторизацію, а роут `/multiple` усі види авторизації, то slim сформує роутер приблизно наступним чином:

```php
$router->add(method: 'GET', path: '/basic', middlewares: [
    new OpenapiAuthMiddleware($container->get(BasicAuthenticator::class)),
])

$router->add(method: 'GET', path: '/multiple', middlewares: [
    new OpenapiAuthMiddleware($container->get(BasicAuthenticator::class)),
    new OpenapiAuthMiddleware($container->get(BearerAuthenticator::class)),
    new OpenapiAuthMiddleware($container->get(OAuth2Authenticator::class)),
])
```

Ідея з тим як це реалізовано в slim генераторі мені подобається і я за реалізацію чогось схожого. З можливістю генерації
більш конкретних класів для способів авторизації, що ми активно використовуємо. Наприклад генерувати 
`AbstractBasicAuthenticator` з абстрактним методом, який аргументами приймає 'username' та 'password', замість усього 
запиту.

Як згадувалось раніше в маніфесті можна вказати різні комбінації методів авторизації для операції:
- за одним з декількох способів,
- за декількома способами одночасно
- комбінований варіант

Slim не підтримує такі комбінації, щоб реалізувати цю підтримку можна генерувати класи `OneOfAuthenticator`, 
`AllOfAuthenticator`, які будуть приймати у конструктор список автентифікаторів і відповідно перевіряти, що хоча б один 
або усі одночасно автентифікатори провели авторизацію успішно. Тоді приклад вище, буде виглядати наступним чином:

```php
$router->add(method: 'GET', path: '/basic', middlewares: [
    new OpenapiAuthMiddleware($container->get(BasicAuthenticator::class)),
])

$router->add(method: 'GET', path: '/multiple', middlewares: [
    new OpenapiAuthMiddleware(
      new AllOfAuthenticator([
          $container->get(BasicAuthenticator::class),
          $container->get(BearerAuthenticator::class),
          $container->get(OAuth2Authenticator::class)
      ])
    )
])
```

Можна й робити складні комбінації:

```php
$router->add(method: 'GET', path: '/', middlewares: [
    new OpenapiAuthMiddleware(
      new AllOfAuthenticator([
          new OneOfAuthenticator([
            $container->get(BasicAuthenticator::class),
            $container->get(BearerAuthenticator::class),
          ]),
          $container->get(OAuth2Authenticator::class)
      ])
    )
])
```

### Генерація клієнту

На клієнті для Api классу повинен генеруватись метод `authorize`, що буде приймати деякий `Authenticator`. Для
кожної конкретної операції це буде свій `Authenticator`. Наприклад операція `GET /multiple` може виглядати наступним 
чином:

```php
use Psr\Http\Message\RequestInterface;

interface GetMultipleOperation
{
    public function authorize(GetMultipleAuthenticator $authenticator): void;
    public function handle(): ResourceListResult; 
}

class GetMultipleAuthenticator extends AllOfAuthenticator
{
    public function __construct(
        BasicAuthenticator $basicAuthenticator,
        BearerAuthenticator $bearerAuthenticator,
        OAuth2Authenticator $oAuth2Authenticator,
    ) {
        parent::__construct([
            $basicAuthenticator,
            $bearerAuthenticator,
            $oAuth2Authenticator
        ]);
    }
}

class AllOfAuthenticator implements Authenticator
{
    public function __construct(
        /** @var  Authenticator[] */
        private array $authenticators
    );
    
    public function authenticate(RequestInterface $request): RequestInterface
    {
        foreach ($this->authenticators as $authenticator)
        {
            $request = $authenticator->authenticate($request);
        } 
        return $request
    }
}

interface Authenticator
{
    /**
     * Add authentication data to request
     */
    public function authenticate(RequestInterface $request): RequestInterface;
}

class BasicAuthenticator implements Authenticator
{
    public function __construct(
        public readonly string $login,
        public readonly string $password
    ) {}
    // ...
}

class BearerAuthenticator implements Authenticator
{
    // ...
}

class OAuth2Authenticator implements Authenticator
{
    // ...
}
```

Якби у прикладі вище була б oneOf авторизація, то клас `GetMultipleAuthenticator` був би таким:

```php
class GetMultipleAuthenticator implements Authenticator
{
    public function __construct(
        private BasicAuthenticator|BearerAuthenticator|OAuth2Authenticator $authenticator,
    ) {
    }
    
    public function authenticate(RequestInterface $request): RequestInterface
    {
        return $this->authenticator->authenticate($request);
    }
}
```

## 2.6 Поліморфізм ❌ ❌ ❌

З підтримкою поліморфізму в openapi генераторах все не дуже добре. Деякі просто не працюють, деякі працюють, але не
проводять ніякої валідації, чи визначення який саме об'єкт було передано. Повної підтримки не має ні один генератор,
принаймні я такого не знайшов.

Openapi схема на якій я проводив тести:

```yaml
Shop:
  type: object
  properties:
    id:
      type: string
    info:
      oneOf:
        - $ref: '#/components/schemas/BookShopInfo'
        - $ref: '#/components/schemas/SupermarketInfo'

BookShopInfo:
  type: object
  properties:
    tags:
      type: string
      enum:
        - books
        - reading
    genres:
      type: array
      items:
        type: string

SupermarketInfo:
  type: object
  properties:
    tags:
      type: string
      enum:
        - food
        - spices
    vendors:
      type: array
      items:
        type: string
```

Згенеровний код для основних генераторів можна подивитись [тут](https://github.com/misha-rollun/openapi-generator-tests)

Спочатку загальні моменти. Усі генератори при використанні oneOf генерують допоміжний клас (або інтерфейс), який 
явно не описаний в маніфесті. Наприклад для маніфесту вище згенерується допоміжний клас ShopInfo.

При цьому в згенерованій openapi моделі цей ShopInfo не завжди правильний. В нашому прикладі і BookShopInfo і 
SupermarketInfo мають enum поле tags, с різними доступними значеннями. При цьому openapi-generator згенерує наступні
моделі:

> Приклад нижче для останньої версії (пятої) генератора, четверта версія, що ми використовуємо настільки погано
> підтримує oneOf, що можна сказати, що взагалі не підтримує.

```json5
[
  {
    "model": {
      "name":  "Shop",
      "vars": [
        {
          "name": "id"
        },
        {
          "name": "info",
          "openApiType": "ShopInfo"
        }
      ]
    }
  }, 
  {
    "model": {
      "name":  "ShopInfo",
      "oneOf": [
        "BookShopInfo",
        "SupermarketInfo"
      ],
      "vars": [
        // openapi-generator об'єднав поля з BookShopInfo і SupermarketInfo
        {
          "name": "tags",
          // Значення для enum взялись тільки з SupermarketInfo
          "_enum": [
            "food",
            "spices"
          ]
        },
        {
          "name": "genres"
        },
        {
          "name": "vendors"
        }
      ]
    }
  },
  {
    "model": {
      "name":  "BookShopInfo",
      "vars": [
        {
          "name": "tags",
          "_enum": [
            "books",
            "reading"
          ]
        },
        {
          "name": "genres"
        }
      ]
    }
  },
  {
    "model": {
      "name":  "SupermarketInfo",
      "vars": [
        {
          "name": "tags",
          "_enum": [
            "food",
            "spices"
          ]
        },
        {
          "name": "vendors"
        }
      ]
    }
  },
]
```

Деякі генератори не перевіряють в своїх mustache шаблонах чи модель це oneOf і генерують її як звичайний клас.
Наприклад так робить mezzio (laminas) генератор:

```php
class Shop
{
    /**
     * @DTA\Data(field="id", nullable=true)
     * @DTA\Validator(name="Scalar", options={"type":"string"})
     * @var string|null
     */
    public $id;

    /**
     * @DTA\Data(field="info", nullable=true)
     * @DTA\Strategy(name="Object", options={"type":\App\DTO\ShopInfo::class})
     * @DTA\Validator(name="TypeCompliant", options={"type":\App\DTO\ShopInfo::class})
     * @var \App\DTO\ShopInfo|null
     */
    public $info;

}

class ShopInfo
{
    /**
     * @DTA\Data(field="tags", nullable=true)
     * @DTA\Validator(name="Scalar", options={"type":"string"})
     * @var string|null
     */
    public $tags;

    /**
     * @DTA\Data(field="genres", nullable=true)
     * @DTA\Strategy(name="Object", options={"type":::class})
     * @DTA\Validator(name="TypeCompliant", options={"type":::class})
     * @var string[]|null
     */
    public $genres;

    /**
     * @DTA\Data(field="vendors", nullable=true)
     * @DTA\Strategy(name="Object", options={"type":::class})
     * @DTA\Validator(name="TypeCompliant", options={"type":::class})
     * @var string[]|null
     */
    public $vendors;

}
```

Php (client), Symfony, C# генератори працюють так само.

Symfony працює через SymfonyValidator та SymfonySerializer, але я не можу сказати на скільки коректно вони працюють, 
це треба перевіряти. Можливо ми можемо запозичити у них деякі рішення.

Slim генератор фактично генерує коректний код:

```php
class ShopInfo extends BaseModel
{
    /**
     * @var string Models namespace.
     * Can be required for data deserialization when model contains referenced schemas.
     */
    protected const MODELS_NAMESPACE = '\OpenAPIServer\Model';

    protected const MODEL_SCHEMA = <<<'SCHEMA'
        {
          "oneOf" : [ {
            "$ref" : "#/components/schemas/BookShopInfo"
          }, {
            "$ref" : "#/components/schemas/SupermarketInfo"
          } ]
        }
    SCHEMA;
}
```

Але я не знайшов ніякої валідації по цій схемі чи десеріалізації об'єкта з json. Хоча теоретично валідацію і 
десеріалізацію можна відносно легко дописати.

У Java така сама проблема: генерується коректний код, але я не знайшов валідації чи десеріалізації:

```java
public interface ShopInfo {
}

public class BookShopInfo implements ShopInfo { 
    // ...
}

public class SupermarketInfo implements ShopInfo {
    // ...
}
```

## 2.7 Організація схем, що використовуються у декількох маніфестах ❌ ❌ ❌

Openapi дозволяє посилатись з одного файлу маніфесту на компоненти, що визначені в інших файлах. Таким чином типи даних,
що використовуються в різних маніфестах, можна описати один раз в окремому файлу.

Організацію структури файлової системи можна взяти з [gcloud](https://www.belgif.be/specification/rest/api-guide/#api-specs),
а саме: типи даних, що використовуються в декількох Api, повинні знаходитись в OpenApi файлах за шляхом: 

```
<domain>/<version>/<domain-version>.yaml
<domain>/<subdomain>/<version>/<domain-subdomain-version>.yaml
```

Кожен файл має свій власний життєвий цикл: зі своїми мажорними, мінорними та патч версіями. 

*Використання мінорних та патч версій може бути не обов'язковим, або їх можна взагалі прибрати і залишити лише мажорні. 
Це питання ще необхідно додатково дослідити.*

Фактично файли з компонентами не повинні бути валідним OpenApi файлом. Але в gcloud їх рекомендують все ж таки робити
валідними, щоб забобігти проблем сумісності з різними інструментами.

Приклад:

> /person/identifier/v1/person-identifier-v1.yaml
> ```yaml
> info:
>   title: person-identifier
>   description: data types for person identifiers
>   version: "1.1.2"
> paths: {} # empty paths property required to be a valid OpenAPI file
> components:
>   schemas:
>       Ssin:
>           description: "Social Security Identification Number issued by the National Register or CBSS"
>           type: string
>           pattern: \d{11}
> ```
> 
> На тип можна посилатися з іншого файлу OpenAPI наступним чином:
> 
> ```yaml
> "$ref": "./person/identifier/v1/person-identifier-v1.yaml#/definitions/Ssin"
> ```

Більше прикладів можна знайти в репозиторіях [gcloud](https://github.com/belgif): 
- [openapi-common](https://github.com/belgif/openapi-common)
- [openapi-problem](https://github.com/belgif/openapi-problem)
- [openapi-person](https://github.com/belgif/openapi-person)
- і т.п.


Єдине, що залишиться програмісту це додати цей middleware в config/pipeline.php свого проекту.

>Ідея від АВ: роутинг може основуватись на тому те знаходиться файл контролера. Контролери генеруються в директорію в 
> залежності від url, а далі роутер визначає. Написати плюси і мінуси.

## 2.8 Як спростити пошук реалізації маніфеста? ❌ ❌ ❌

Проблема актуальна лише для серверної частини.

Якщо увесь згенерованний код буде розміщений в одному місці (`src/Generated/Openapi/...), а реалізація контролерів
знаходитись в довільному місці, то може виникнути проблема за тим щоб швидко знаходити реалізації в проектах з якими
раніше не працював. Для того щоб уникнути цієї проблеми потрібно або розміщувати реалізації в завчасно оговореному
місці, або конфігурацію (через яку можна буде дізнати де знаходиться реалізація).

Загалом я за перший підхід, оскільки він більше схожий не загальну практику: усі контролери розміщуються в директорії
`Controllers`. Для того щоб не путати PSR-7 контролери, з контролерами openapi, а також швидко знаходити контролер для 
конкретного маніфеста можна розміщувати їх у директорію `Controllers\Openapi\{manifestName}`


## 2.9 Назви класів, методів ❌ ❌ ❌

Теги не використовуються. Для генерації назв класів потрібно використовувати url та назви компонентів (схем, 
авторизації і т.п).

Для генерації назв методів використовувати:
- Якщо operationId наявний - його значення
- Якщо немає operationId - стандартні назви: post, get, getById, etc

## 2.10 Підтримка rql ❌ ❌ ❌

На першому і другому рівні підтримка не потрібна.

На третьому рівні:

Генератор повинен підтримувати rql для get, а також можливо для patch, put і delete, запитів (але не getById, putById, 
patchById, deleteById): 
- Валідувати, що елементи колекції у відповіді містять усі поля, що були передані в select
- Сервер: Автоматично парсити rql та передавати в контролер Query об'єкт 
- Клієнт: Дозволити передавати в rql аргумент Query об'єкт або рядок. Якщо передано об'єкт, то перетворювати його в 
рядок при відправці. Якщо рядок, то валідувати його. 

Для того щоб генератор розумів, що конкретний рядок являється rql, то потрібно або зарезервувати ключ в якому завжди
буде знаходитись rql, або знайти в маніфесті вказувати розширений тип поля (мені здається що таке є).

## 2.11 Підтримка медіа типів ❌ ❌ ❌

На першому і другому рівні:

Архітектурно повинні підтримуватись усі медіа типи. Реалізацію потрібно робити лише для типів, що описані для третього 
рівня.

На третьому рівні:

Повинні підтримуватись лише медіа типи application/vnd.rollun-* , що описані [вище](#опис-медіа-типів).

## 2.12 Підтримка рейт лімітів ❌ ❌ ❌

На третьому рівні:

- повинна бути можливість задати рейт ліміти для сервера. 
- Клієнтська частина повинна моніторити ці ліміти, та не відправляти запити, якщо виходить за них

## 2.13 Обробка помилок ❌ ❌ ❌

При виникненні невідомої або технічної помилки (виключення) на будь-якому з рівнів вона повинна записатись в messages Openapi
Response та/або Psr-7 Response (в залежності від того де виникла помилка). 

На третьому рівні массив messages не потрібен, при виникненні невідомої або технічної помилки буде кидатись виключення.
Яке клієнт повинен опрацювати через try\catch.

## 2.14 Кешування ❌ ❌ ❌

## 2.15 Лонг таски ❌ ❌ ❌