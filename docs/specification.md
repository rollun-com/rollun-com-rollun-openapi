# Rollun REST API specification

## 1. Визначення REST архітектури

## 1.1 Починаємо з Null стилю

Філдинг (автор REST архітектури) виділяє два підходи до проєктування архітектури. Перший - це коли архітектор починає
з чистого листа і створює архітектуру зі знайомих компонентів доти, доки вона не задовольнить усі вимоги до системи.
Другий - це коли архітектор починає з потреб системи в цілому, без обмежень, та потім поступово визначає та застосовує
обмеження до елементів системи. REST було розроблено з використанням другого підходу, тому він складається з набору
обмежень, які повинно дотримуватись API, щоб називатись REST API.

## 1.2 Клієнт-серверна архітектура

Першим обмеженням є приведення архітектури до моделі клієнт-сервер. Ця модель детальніше описана в [главі 3.4.1](https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_4_1)
дисертації Роя Філдинга. 

## 1.3 Відсутність стану

Друге обмеження додається до моделі клієнт-сервер: взаємодія повинна бути без стану. Тобто кожен запит від клієнта
до сервера повинен містити усю, необхідну для розуміння запиту, інформацію і не може використовувати будь-який
збережений на сервері контекст. Стан сеансу повністю зберігається на клієнті.

## 1.4 Кешування

Обмеження на кешування вимагає, щоб дані у відповідь на запит були явно, або неявно, позначені як такі, що кешуються,
або такі що не кешуються. Якщо відповідь кешується, то клієнт отримує право повторно використати дані з кешу для 
еквівалентних запитів.

## 1.5 Однорідний (уніфікований) інтерфейс

Головною особливістю, яка відрізняє архітектурний стиль REST від інших мережевих стилів, є акцент на уніфікованому
інтерфейсі між компонентами. 

До уніфікованих інтерфейсів застосовуються чотири обмеження:

**Ідентифікація ресурсів**

Ключовою абстракцією інформації в REST є *ресурс*. Ресурсом може бути будь-яка інформація, яку можна назвати: документ 
або зображення, тимчасовий сервіс (наприклад, «сьогоднішня погода у Львові»), набір інших ресурсів, невіртуальний об’єкт
(наприклад, людина) тощо.. Іншими словами, будь-яка концепція, яка може бути ціллю гіпертекстового посилання автора, 
повинна відповідати визначенню ресурсу.

**Маніпуляція ресурсами через представлення**

**Самоописові повідомлення**

**Гіпермедіа як рушій стану застосунку**

## 3. Ресурси

### 3.1 URI

*Правило*
> URI **повинен бути записаний в kebab-case.**

Приклади:

```
✅ http://parts-unlimited/openapi/suppliers-orders-cache/v1

❌ http://partsUnlimited/openapi/suppliersOrdersCache/v1

❌ http://parts_unlimited/openapi/suppliers_orders_cache/v1

❌ http://parts-unlimited/openapi/SUPPLIERS_ORDERS_CACHE/v1
```

*Правило*
> Формат URL path: `/openapi/{manifest-title}/v{major-version}/{resources}`
> 
> **openapi**
>
> Обов'язковий префікс
> 
> **manifest-title**
> 
> Поле `title` з секції `info` openapi маніфесту в kebab-case.
> 
> **major-version**
> 
> Мажорна версія API (поле `version` секції `info` openapi маніфесту). Integer, що починається з одиниці.
> 
> **resources**
> 
> Повний шлях, що ідентифікує ресурс.

*Правило*
> URI **не повинен містити розширення файлу**

Замість цього розширення описується за допомогою медіа типу, який можна вказати в заголовках HTTP.

```
✅ http://parts-unlimited/openapi/suppliers-orders-cache/v1/orders

❌ http://parts-unlimited/openapi/suppliers-orders-cache/v1/orders.json
```

### 3.2 Типи ресурсів

Виділяються наступні типи ресурсів:
- Документ
- Колекція
- Action
- Датастор
- Кінцевий автомат

### 3.3 Документ

Документ - це ресурс який посилається на одну конкретну бізнес сутність або екземпляр об'єкта. Завжди json об'єкт, 
тобто не колекція, рядок і т.п.

*Правило*
> Кожен **документ повинен мати поле з ідентифікатором.** Це поле рекомендується називати `id` та його тип повинен бути
> string.

*Правило*
> Ідентифікатор ресурсу документа рекомендується **обирати з природних бізнес ідентифікаторів** ресурсу, як, наприклад, 
> ІПН людини. У разі відсутності таких ідентифікаторів можна використовувати сурогатний ключ.

Приклад:

```http request
GET /articles/AB123
```

```json
{
  "data": {
    "id": "AB123",
    "title": "My first article!",
    "status": "draft",
    "content": "No content yet."
  }
}
```

Документ частіше за все міститься в батьківській колекції та визначається ідентифікатором. Документ 
може містити дочірні колекції.

![collection](img/specification/collection.png)

Рекомендується не зловживати зв'язками в URI. Довгі цепочки залежностей, як, наприклад, `/customers/1/orders/99/products`
буде складніше обслуговувати та адаптувати у разі зміни зв'язків між ресурсами. Цей приклад URI краще розбити на коротші
та простіші URI: `/customers/1/orders` - щоб переглянути усі замовлення клієнта 1, а потім`/orders/99/products` щоб 
знайти усі товари замовлення 99.

*Правило*

> Query параметр `select` зарезервовано для отримання представлення ресурсу тільки з вказаними властивостями.
> 
> При цьому усі поля ресурсу в маніфесті повинні бути об'явленні як optional. Запит повинен мати select за 
> замовчуванням. 
> 
> Якщо запит не підтримує select (наприклад за ненадобності), то повинні повертатись усі поля ресурсу.
> 
> Якщо клієнт вказав у select властивості, яких немає у ресурсу, то повинен повернутися http код 400 з описом
> помилки в тілі відповіді.

Приклад:

```http request
GET /articles/AB123?select=title,status
```

```json
{
  "data": {
    "title": "My first article!",
    "status": "draft"
  }
}
```

### 3.4 Колекція

Колекція - це список ресурсів документів.

*Правило 6*

> **Для назв колекцій слід використовувати іменник у множині**, як, наприклад, `employers`, `people`, `orders`.

Приклад колекції

```http request
GET /orders
```

```json
{
  "data": [
    {
      "id": "1",
      "invoice": {
        "total": 10.34,
        "currency": "USD"
      }
    },
    {
      "id": "2",
      "invoice": {
        "total": 12.26,
        "currency": "USD"
      }
    }
  ]
}
```

### 3.4.1 RQL

Фільтрування, вибірка та пагінація в колекціях здійснюється за допомогою RQL.

*Правило*

> Кожна колекція повинна підтримувати RQL. Але, за потреби, може робити це не в повному обсязі. Наприклад відмовитись
> від підтримки groupby ноди. Про це повинно бути написано в описі операції в openapi маніфесті. 
> 
> Якщо клієнт надсилає rql який не підтримується сервером, то сервер повинен відповісти кодом 501 Not Implemented з
> описом помилки в тілі відповіді.

#### 3.4.1.1 Опис RQL

Описати RQL в тому вигляді в якому його задумували не вийде, оскільки хоч в специфікації URL явно не вказано в якому 
форматі повинна бути query частина, тобто це може бути будь-який рядок. Але в openapi специфікації query обов'язково 
повинно бути у форматі ключ=значення. Тому хоч з точки зору URL запис mydomain.com?eq(id,1) коректний, але в openapi 
маніфесті його ніяк не опишеш. Детальніше: [issue #1502](https://github.com/OAI/OpenAPI-Specification/issues/1502).

Для розв'язання цієї проблеми ми розділили RQL на декілька логічних частин, щоб його можна було записати в форматі 
ключ-значення.

Опис усіх ключів RQL в openapi маніфесті:

```yaml
"/resources":
    get:
      parameters:
        - name: query
          in: query
          required: false
          schema:
            type: string
            example: 'and(eq(field1,value1),eq(field2,value2))'
        - name: limit
          in: query
          required: false
          schema:
            type: integer
            default: 20
            example: 20
        - name: offset
          in: query
          required: false
          schema:
            type: integer
            default: 0
            example: 0
        - name: sort
          in: query
          required: false
          schema:
            type: string
            example: -field1
        - name: select
          in: query
          required: false
          style: form
          explode: false
          schema:
            type: array
            items:
              type: string
            example: field1,field2
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ResourceListResult"
```

```
/resource?query=and(eq(field1,value1),eq(field2,value2))&limit=20&offset=20&sort=-field1&select=field1,field2
```

#### 3.4.1.2 Фільтрація

Фільтрація елементів колекції здійснюється за допомогою query параметру `query`. 

Наприклад query ```/cars?query=and(eq(doors,5),or(eq(color,blue),eq(color,black)))``` буде інтерпретовано як "знайти
автомобілі у яких 5 дверей та їх колір або синій або чорний".

#### 3.4.1.3 Пагінація

*Правило*

> Якщо колекція передбачувано буде мати багато елементів, то вона **ПОВИННА** підтримувати пагінацію. Визначення того, що 
> вважати за "багато" елементів залишається на архітекторі системи, адже це може залежати від вимог до швидкості роботи 
> системи, обмеженням по пам'яті, розміру конкретного ресурсу та багато чого іншого.

Існує два популярних підходи до реалізації пагінації:
- offset-based
- cursor-based (aka key-based or luke index):

*Правило*

> Для пагінації повинен використовуватись offset-based підхід.

**Опис offset-based підходу**

Це пагінація яка використовується в наших датасторах, фактично вказується номер елементу, що наступний після останнього
отриманого. Контролюється двома параметрами: розмір сторінки (limit) та зміщення (offset). 

Для початку клієнт повинен визначитись з тим скільки елементів колекції повинно повертатись на одній сторінці. Це буде
query параметр limit. При цьому цей параметр може мати значення по замовчуванню, тож клієнт може використовувати його.
Потім щоб перейти на сторінкку з номером n, де n - це ціле число, що більше або рівне за одиницю, клієнт повинен 
передати query параметр offset, який розраховується наступним чином: `offset = (n - 1) * limit`

*Правило*
> Query параметри offset і limit **ПОВИННІ** мати значення по замовчуванню.


Переваги:
- Велика поширеність у фреймворках/інструментах.
- Простота використання
- Можливість "стрибнути" на якусь певну сторінку, попередньо не отримавши на неї посилання

Недоліки:
- Порівняно низька швидкість роботи для виликих наборів данних.
- Низька швидкість роботи в NoSQL базах даних
- Можливість дублікатів при обході сторінок, якщо при цьому додався новий запис в базу даних.

*Правило*
> Якщо використовується пагінація, то разом з колекцією повинна повертатись metadata пагінації в форматі, як у прикладі
> нижче.

Request example
```http request
GET /resources
```

Response example
```json5
{
  "metadata": {
    "pagination": {
      "totalCount": 101,
      "offset": 0,
      "limit": 20
    }
  },
  "data": [
    // ...
  ]
}
```

**Опис Cursor-based підходу**

На данний момент ми не використовуємо cursor-based пагінацію, але для повноти інформації також опишемо цей підхід
в загальних рисах.

В цьому підході клієнт, щоб перейти на якусь сторінку повинен явно отримати від сервера значення курсору для цієї 
сторінки. Для клієнтської сторони курсор це лише набір символів, який вказує на певну сторінку. Реальне значення курсору 
може відрізнятись в залежності від імплементації сервера. Зазвичай у якості курсору використовують ідентифікатор першого 
або останнього елементу на сторінці.

Переваги:
- Швидкість роботи для великих наборів даних та NoSQL баз даних
- неможливість дублікатів при обході сторінок

Недоліки:
- Складність реалізації
- Неможливість "стрибнути" на певну сторінку, попередньо не отримавши посилання на неї

Зауваження:
- Може не працювати, якщо потрібен total count of results (поки не знаю чому, можливо мається на увазі його
  неефективність при даній умові)
- При неправильній реалізації може бути помилка, якщо курсор вказуватиме на елемент, що вже видалено

Request example (cursor - необов'язковий в першому запиті, але присутній для прикладу)
```http request
GET /resources?cursour=null
```

Замість null можна використовувати якісь інші зарезервовані значення: 0 або -1 і т.п. Головне щоб це значення було
вказано для поля у розділі default, а також коректно оброблювалось серверною стороною.

Response example
```json5
{
  "metadata": {
    "pagination": {
      "nextPageCursor": "gRk90324",
      "prevPageCursor": null,
      "currentCursor": 'nm2bu4n5j',
      "limit": 20
    }
  },
  "data": [
    // ...
  ]
}
```

### 3.5 Action

Action (екшн) ресурс - це процедурний концепт. Action ресурси - це віддалено запускаємі функції з вхідними аргументами та
результатом. Вони можуть бути корисні, щоб описати операції, які не підпадають під операції над колекціями чи 
документами, наприклад, валідація даних.

*Правило*
> Назва екшену повинна бути дієсловом, а не іменником. Кожен action міститься в колекції actions. Ця колекція може 
> бути як окрема колекція, якщо action виконує дію над декількома ресурсами одночасно, так і дочірньою для документа.
>
> Запуск екшена може виконуватись одним із http методів:
> - POST - якщо екшн має побічні ефекти (змінює стан ресурсу), або для екшенів що не мають побічних ефектів, але 
> потребують тіло запиту
> - GET - для екшенів, що не мають побічних ефектів

Приклади:

Відправка повідомлення роботодавцю

```http request
POST /employers/93017373/actions/sendNotification
```

Конвертація грошей з однієї валюти в іншу (використовується GET, тому що операція не має побічних ефектів)

```http request
GET /actions/convertMoney?from=EUR&amount=45&to=USD
```