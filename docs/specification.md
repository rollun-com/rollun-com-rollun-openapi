# Rollun REST API specification

## 1. Формат специфікації

Кожне правило починається с курсирного слова "Правило" та виділяється як цитата, наступним чином:

*Правило*

> Правило якому повинно слідувати API.

В документі будуть зустрічатись два види посилань:
- внутрішні - посилаються на цей документ. Ніяк особливим чином не виділяються. Приклади: [Http](#2-http), 
[Patch vs Put](#261-patch-vs-put)
- зовнішні - посилаються на джерела поза цим документом. Виділяються курсивом. Приклади: 
[*семантичне версіонування*](https://semver.org/lang/uk/), [*RFC 9110*](https://www.rfc-editor.org/rfc/rfc9110)

## 2. Http

Протокол http спроектований згідно вимог до REST архітектури і ми використовуємо його для того, щоб будувати наші REST 
API.

### 2.1 Ідемпотентність

Ідемпотентність - це властивість операції, коли результат виконання декількох однакових запитів призводить до того 
самого стану серверу, що й виклик одного запиту. Іншими словами ідемпотентна операція не має ніяких побічних ефектів, 
окрім сбору статистики та подібних операцій. 

Важливо зазначити, що ідемпотентність стосується лише стану серверу, фактичні відповіді на запити можуть бути різними.
Наприклад метод DELETE, який є ідемпотентним, може перший раз повернути код 200 OK, а наступні рази повертати код 
404 Not found.

Згідно специфікації http ідемпотентними є методи: `GET`, `HEAD`, `PUT`, `DELETE`. Але ми розширюємо цей список вносячи
наступне правило:

*Правило*

> **Метод POST повинен бути ідемпотентним.** Зробити POST метод ідемпотентним можна додаючи ключ ідемпотентності в 
> тіло запиту (поле "payload.idempotencyKey"). При цьому сервер повинен відстежувати, щоб запити з однаковим ключем 
> ідемпотентності не виконувались повторно.

*Приклад*

Перший запит: 

```http request
POST /articles
Content-Type: application/vnd.rollun-request+json

{
  "payload": {
    "idempotencyKey": "12345",
    "title": "My article",
    "content": "My first article!"
  }
}
```

Відповідь:

```http
HTTP/1.1 201 Created
Location: /articles/qwerty
Content-type: application/vnd.rollun+json

{
  "task": {
    "id": "qwerty",
    "idempotencyKey": "12345",
    "title": "My article",
    "content": "My first article!"
  }
}
```

Повторний, ідентичний запит:

```http request
POST /articles
Content-Type: application/vnd.rollun-request+json

{
  "payload": {
    "idempotencyKey": "12345",
    "title": "My article",
    "content": "My first article!"
  }
}
```

Відповідь:

```http
HTTP/1.1 200 OK
Location: /articles/qwerty
Content-type: application/vnd.rollun+json

{
  "task": {
    "id": "qwerty",
    "idempotencyKey": "12345",
    "title": "My article",
    "content": "My first article!"
  }
}
```

Як видно, повторний запит не привів до повторного створення статті, а повернулась уже створенна стаття.

Нижче розглянемо декілька сценаріїв роботи з ідемпотентною POST операцією.

**Сценарій 1**

1. Клієнт надсилає POST запит на створення ресурсу
2. Сервер успішно виконує запит, і повертає відповідь з `201 Created` статус кодом
3. Клієнт не отримує відповідь через проблеми з мережею
4. Клієнт надсилає повторний ідентичний запит

*Результат:*

Клієнт отримує відповідь таку саму як на кроці 2, але з кодом `200 OK`. Ресурс створюється один раз на кроці 2.

**Сценарій 2**

1. Клієнт надсилає POST запит на створення ресурсу
2. Сервер відповідає з 500 кодом помилки
3. Клієнт не отримує відповідь через проблеми з мережею
4. Клієнт надсилає повторний ідентичний запит

*Результат:*

Результат не може буде визначенним. Повторний запит на кроці 4 може привести до створення дубліката ресурсу. Якщо 
клієнт все ж отримав відповідь на кроці 3, то рекомендується не відправляти повторний запит до з'ясування причин 
помилки.

**Сценарій 3**

1. Клієнт надсилає POST запит на створення ресурсу без хедера авторизації
2. Сервер відповідає з 403 кодом помилки
3. Клієнт отримує відповідь і надсилає повторний ідентичний запит, але з хедером авторизації
4. Сервер успішно оброблює запит і повертає 200 ОК відповідь

*Результат:*

Сервер створить ресурс на кроці 4. Крок 2 ніяк не вплине на створення ресурсу. Клієнт може безпечно надсилати запити з 
кроку 1 і отримувати відповідь як на кроці 2.

**Сценарій 4**

1. Клієнт надсилає POST запит на створення ресурсу
2. Сервер відповідає з 503 Service Unavailable кодом помилки
3. Клієнт отримує відповідь і планує повторний запит
4. Сервер повертається в робочий стан
5. Клієнт надсилає повторний запит з ідентичним ключем ідемпотентності
6. Сервер успішно виконує запит і повертає 200 ОК відповідь

*Результат:*

Сервер оброблює запит на кроці 6. Поки сервер знаходиться в Unavailable стані клієнт може беспечно надсилати запити з 
кроку 1 та отримувати відповідь з кроку 2. В кінці кінців відбудеться крок номер 5 та 6.

**Сценарій 5**

1. Клієнт надсилає POST запит на створення ресурсу
2. Сервер отримує запит та успішно його оброблює
3. Клієнт не отримує відповідь через проблеми з мережею
4. Клієнт надсилає повторний запит, але зі зміниними деякими параметрами (але ключ ідемпотентності той самий)

*Результат:*

Сервер надсилає 409 Conflict відповідь з поясненям помилки в тілі відповіді.

**Сценарій 6**

1. Клієнт надсилає POST запит на створення ресурсу
2. Север отримує запит та починає його виконання
3. Не чекаючи завершення виконання першого запита клієнт надсилає другий запит ідентичний першому
4. Сервер отримує другий запит до завершення виконання першого запиту

*Результат:*

Сервер виконує запит один раз у відповідь на запит відправлений у кроці 1. У відповідь на запит, відправлений у кроці 
2 повертається помилка 409 Conflict з поясненям помилки в тілі відповіді.

### 2.2 GET 

**GET необхідно використовувати для отримання представлення ресурсу або запуску виконання безпечного екшену.** Це метод 
лише для читання, який ніколи не повинен змінювати стан ресурсу.

### 2.3 HEAD 

**HEAD слід використовувати лише для отримання заголовків HTTP відповіді.** HEAD повертає ту саму відповідь, що й GET, 
за винятком того, що API повертає порожнє тіло. Це строго лише для читання.

### 2.4 POST

**POST необхідно використовувати для створення нового ресурсу в колекції або для запуску виконання екшену.**

Під час використання для створення ресурсу тіло запиту POST містить запропоноване представлення стану нового ресурсу, 
який буде додано до колекції, що належить серверу. Відповідь має містити HTTP-заголовок `Location`, що містить URI щойно 
створеного ресурсу, тоді як тіло містить його (часткове чи повне) представлення або може бути порожнє.

### 2.5 PUT

**PUT потрібно використовувати для оновлення збереженого ресурсу під URI, наданим клієнтом.** Його можна використовувати 
для вставки нового ресурсу, якщо створення ідентифікатора покладено на клієнта.

Якщо URI посилається на вже існуючий ресурс, вкладену сутність СЛІД вважати новою версією, яка замінить ту, що 
знаходиться на сервері. Якщо цільовий ресурс успішно змінено відповідно до стану вкладеного представлення, тоді СЛІД 
надіслати відповідь `200 OK`, щоб вказати успішне завершення запиту.

Якщо URI не вказує на існуючий ресурс, і цей URI можна визначити як новий ресурс, сервер може створити ресурс із цим 
URI. Сервер **ПОВИНЕН** повідомити клієнта, надіславши відповідь `201 Created`, щоб вказати на успішне створення.

Операції PUT можуть мати побічні ефекти (тобто змінювати стан), але ПОВИННІ бути ідемпотентними.

### 2.6 PATCH

PATCH необхідно використовувати для часткового оновлення представлення ресурсу.

Включена сутність містить набір інструкцій, що описують, як ресурс, який зараз знаходиться на початковому сервері, має
бути змінений для створення нової версії. Метод PATCH впливає на ресурс, визначений Request-URI, і він також МОЖЕ мати
побічні ефекти на інші ресурси; тобто нові ресурси можуть бути створені або існуючі модифіковані шляхом застосування 
PATCH. Операції PATCH не обов’язково повинні бути ідемпотентними.

#### 2.6.1 PATCH vs PUT

Різниця між запитами PUT і PATCH відображається в тому, як сервер обробляє об’єкт, щоб змінити ресурс,
ідентифікований за допомогою Request-URI. PUT запит містить об’єкт, що вважається модифікованою версією ресурсу,
який зберігається на сервері, і клієнт просить замінити збережену версію. В PATCH вкладений об’єкт
містить набір інструкцій, що описують, як ресурс, який зараз знаходиться на вихідному сервері, повинен бути змінений
для створення нової версії. Метод PATCH МОЖЕ мати побічні ефекти на інші ресурси; тобто нові ресурси можуть бути
створені або можуть бути змінені існуючі за допомогою застосування виправлення.

PATCH МОЖЕ створити новий ресурс залежно від типу patch документу.

PATCH описує набір змін в «patch документі», що визначається за допомогою media-type в хедері Content-Type. Хоча явно ніде не написано, але
в загальному випадку application/json - не являється patch документом. Адже сервер ніяк не зможе зрозуміти яким чином
йому змінювати ресурс.

Patch документ зазвичай може приймати одну з двох форм:

- **Містити чіткий опис змін.** Приклад [*json-patch*](https://datatracker.ietf.org/doc/html/rfc6902/).

The original document
```json
{
  "title": "hello, world!",
  "author": "John",
  "tags": ["example"],
  "content": "My article."
}
```

The patch

1. Замінити значення title на "First article!"
2. Додати значення "sample" до масиву tags.
3. Видалити поле author

```http request
Content-Type: application/json-patch+json

[
  { "op": "replace", "path": "/title", "value": "First article!" },
  { "op": "add", "path": "/tags", "value": ["sample"] },
  { "op": "remove", "path": "/author" }
]
```

The result

```json
{
  "title": "First article!",
  "tags": ["example", "sample"],
  "content": "My article."
}
```

- **Містити модифіковану версію ресурсу і дозволити серверу самому визначити набір змін.** Приклад [*json/merge-patch*](https://datatracker.ietf.org/doc/html/rfc7396)

The original document
```json
{
  "title": "hello, world!",
  "author": "John",
  "tags": ["example"],
  "content": "My article."
}
```

The patch

1. Замінити значення title на "First article!"
2. Замінити значення tags на ["sample"] (саме замінити, а не додати нове значення в масив).
3. Видалити поле author

```http request
Content-Type: application/merge-patch+json
        
{
  "title": "First article!",
  "tags": ["sample"],
  "content": null
}
```

The result

```json
{
  "title": "First article!",
  "tags": ["sample"],
  "content": "My article."
}
```

Мінус json-merge-patch в тому що він не може описати нормально описати деякі операції: наприклад додавання елементу
в массив.

### 2.7 DELETE

**DELETE потрібно використовувати для видалення ресурсу**. Після обробки запиту DELETE для певного ресурсу клієнти більше 
не можуть знайти цей ресурс. Таким чином, будь-яка майбутня спроба отримати представлення стану ресурсу за допомогою 
GET або HEAD має призвести до статусу 404 («Не знайдено»), повернутого API.

### 2.8 Http статус коди

#### 2.8.1 2xx Success

Дія була успішно отримана, зрозуміла та прийнята.

| Код          | Опис                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Методи                                 |
|--------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------|
| 200 OK       | **200 (“OK”) для використовується для позначення успіху в загальному сенсі** <br/><br/> У більшості випадків 200 - це код, який клієнт сподівається побачити. Це вказує на те, що REST API успішно виконав будь-яку дію, яку запитував клієнт, і що більш конкретний код із серії 2xx не підходить. На відміну від коду статусу 204, відповідь 200 має містити тіло відповіді.                                                                                                                                                  | GET, HEAD, PUT, PATCH, DELETE, OPTIONS | 
| 201 Created  | **201 («Created») має використовуватися для позначення успішного створення ресурсу** <br/><br/>  API REST відповідає кодом статусу 201 щоразу, коли колекція створює новий ресурс на запит клієнта. Тіло відповіді може бути порожнім або містити часткове або повне представлення нового ресурсу. Location хедер рекомендується використовувати, щоб позначити URL створенного ресурсу.                                                                                                                                        | POST, PUT                              |
| 202 Accepted | **202 («Accepted») має використовуватися для позначення успішного початку асинхронної дії** <br/><br/> Відповідь 202 вказує на те, що запит клієнта буде оброблено асинхронно. Цей код статусу відповіді повідомляє клієнту, що запит виглядає валідним, але з ним все ще можуть виникнути проблеми після його остаточної обробки. Відповідь 202 зазвичай використовується для дій, обробка яких потребує багато часу (див. [long tasks](#10-long-tasks)). Метод POST може надсилати 202 відповіді, але інші методи не повинні. | POST                                   | 

#### 2.8.2 3xx Redirect

Подальші дії потрібно виконати, щоб завершити запит.

| Код           | Опис                                                                                                                                                                                                                                                                                                                                                                    | Методи          |
|---------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------|
| 303 See Other | **303 (“See Other”) слід використовувати для направлення клієнта на інший URI** <br/><br/> 303 статус дозволяє вказати на ресурс не змушуючи клієнта завантажувати його. Щоб отримати ресурс клієнт може відправити GET запит до URI взятого з Location заголовка. <br/><br/> Використовується коли long task завершив свою роботу і хоче вказати на URI з результатом. | GET, HEAD, POST | 

#### 2.8.3 4xx Сlient error

Запит містить неправильний синтаксис або його неможливо виконати з легальних причин

| Код                        | Опис                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Методи                                       |
|----------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------|
| 400 Bad Request            | **400 («Bad Request») може використовуватися для позначення загальної помилки клієнта** <br/><br/> Може використовуватись коли ніякий інший статус код не піходить.                                                                                                                                                                                                                                                                                                                             | GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS | 
| 401 Unauthorized           | **401 («Unauthorized») необхідно використовувати, коли є проблема з авторизацією клієнта.** <br/><br/> Відповідь про помилку 401 вказує на те, що клієнт намагався виконати дію над захищеним ресурсом, не надавши належної авторизації. Можливо, він надав неправильні облікові дані або їх не було взагалі.                                                                                                                                                                                   | GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS | 
| 403 Forbidden              | **403 («Forbidden») слід використовувати для заборони доступу незалежно від стану авторизації.** <br/><br/> Відповідь про помилку 403 вказує на те, що запит клієнта сформовано правильно, але REST API відмовляється його виконувати. Відповідь 403 не є випадком проблеми з авторизацією; це буде 401 («Unauthorized»).                                                                                                                                                                       | GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS | 
| 404 Not Found              | **404 («Not Found») потрібно використовувати, якщо URI клієнта не можна співставити з ресурсом.** <br/><br/> Код статусу помилки 404 вказує на те, що REST API не може співставити URI клієнта з ресурсом.                                                                                                                                                                                                                                                                                      | GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS | 
| 405 Method Not Allowed     | **405 («Method Not Allowed») потрібно використовувати, коли метод HTTP не підтримується ресурсом.** <br/><br/> API відповідає помилкою 405, яка вказує на те, що клієнт намагався використати метод HTTP, який не підтримується ресурсом. Наприклад, коли дія PUT або POST виконується на ресурсі лише для читання, який підтримує лише GET і HEAD. <br/><br/> Відповідь 405 має містити заголовок Allow, у якому перераховано методи HTTP, які підтримує ресурс. Наприклад: `Allow: GET, POST` | GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS | 
| 406 Not Acceptable         | **406 («Not Acceptable») потрібно використовувати, коли запитаний тип медіа не може бути оброблено** <br/><br/> Відповідь про помилку 406 вказує на те, що API не може створити будь-який із бажаних типів мультимедійних даних клієнта, як зазначено в `Accept` заголовку. Наприклад, запит клієнта на дані у форматі `application/xml` отримає відповідь 406, якщо API бажає форматувати дані лише як `application/json`.                                                                     | GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS | 
| 409 Conflict               | **409 («Conflict») слід використовувати, коли запит конфліктує з поточним станом цільового ресурсу** <br/><br/> Відповідь про помилку 409 повідомляє клієнту, що він намагався перевести ресурс у неможливий стан. <br/><br/> Може повертатись у випадках порушення бізнес логіки. Наприклад, коли клієнт намагається закупити товар не дозволенний в його країні.                                                                                                                              | POST, PUT, PATCH, DELETE                     | 
| 412 Precondition Failed    | **412 («Precondition Failed») слід використовувати для підтримки умовних операцій** <br/><br/> Використовуйте лише для [умовних запитів](#114-умовні-запити) HTTP.                                                                                                                                                                                                                                                                                                                              | POST, PUT, PATCH, DELETE                     | 
| 413 Payload Too Large      | **413 («Payload Too Large») слід використовувати, коли запит відхилено, оскільки розмір запиту занадто великий**                                                                                                                                                                                                                                                                                                                                                                                | POST, PUT, PATCH                             | 
| 415 Unsupported Media Type | **415 («Unsupported Media Type») потрібно використовувати, коли медіа тип запиту не може бути оброблено** <br/><br/> Відповідь про помилку 415 вказує на те, що API не може обробити наданий клієнтом медіа-тип, як зазначено в заголовку запиту `Content-Type`. Наприклад, запит клієнта, що містить дані у форматі `application/xml`, отримає відповідь 415, якщо API бажає обробляти дані у форматі `application/json`.                                                                      | GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS | 
| 429 Too Many Requests      | **429 («Too Many Requests») слід використовувати, щоб вказати, що користувач надіслав забагато запитів за певний проміжок часу.** <br/><br/> Відповіді з кодом статусу 429 НЕ ПОВИННІ зберігатися в кеші.                                                                                                                                                                                                                                                                                       | GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS | 


#### 2.8.4 5xx Server Error

Сервер не зміг виконати валідний запит.

| Код                       | Опис                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Методи                                       |
|---------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------|
| 500 Internal Server Error | **500 («Internal Server Error») слід використовувати для позначення несправності API** <br/><br/> 500 — це загальна відповідь на помилку REST API. Більшість веб-фреймворків автоматично відповідають цим кодом статусу відповіді щоразу, коли вони виконують якийсь код обробника запитів, який викликає виняткову ситуацію. Помилка 500 ніколи не є провиною клієнта, тому для клієнта розумно повторити той самий запит, який викликав цю відповідь, і сподіватися отримати іншу відповідь. | GET, HEAD, PUT, PATCH, DELETE, OPTIONS       | 
| 502 Bad Gateway           | **Код статусу 502 («Bad Gateway») вказує на те, що сервер, діючи як шлюз або проксі, отримав недійсну відповідь від висхідного сервера, до якого він звертався під час спроби виконати запит.**                                                                                                                                                                                                                                                                                                | GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS |
| 503 Service Unavailable   | **503 («Сервіс недоступний») вказує на те, що сервер наразі не може обробити запит через тимчасове перевантаження або заплановане технічне обслуговування, яке, ймовірно, буде полегшено після деякої затримки.** <br/><br/> Сервер МОЖЕ надіслати поле заголовка `Retry-After`, щоб запропонувати відповідний проміжок часу, протягом якого клієнт повинен очікувати перед повторним запитом.                                                                                                 | GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS | 

### 2.9 Http заголовки

#### 2.9.1 Request headers

| Заголовок         | Опис                                                                                                                                                                                                                                        |
|-------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Accept            | **Список медіа типів, що розуміє клієнт**                                                                                                                                                                                                   |
| User-Agent        | **Ідентифікатор клієнтського програмного забезпечення.** <br/> <br/> Формат: `{Generator-Name}/{Generator-Version} {Manifest-Title}/{Manifest-Version}`                                                                                     |
| Authorization     | **Облікові дані клієнта для авторизації**                                                                                                                                                                                                   |
| Cache-Control     | **Використовується для вказівки директив, які повинні виконуватися всіма механізмами кешування вздовж ланцюжка запитів-відповідей.**                                                                                                        |
| Content-Type      | **Медіа тип тіла запиту**                                                                                                                                                                                                                   |
| Date              | **Дата і час створення повідомлення** (у форматі "HTTP-date", як визначено в [*RFC 9110: Семантика HTTP, розділ 5.6.7 "Формати дати/часу"*](https://www.rfc-editor.org/rfc/rfc9110#section-5.6.7)).                                         |
| If-Match          | **Виконувати дію лише у тому випадку, якщо etag, наданний клієнтом, збігається з таким же etag на сервері.** <br/><br/> Використовується для [запобігання колізій при редагуванні ресурсу](#12-запобігання-колізій-при-редагуванні-ресурсу) |
| If-Modified-Since | **Дозволяє повертати 304 Not Modified, якщо вміст не змінено.** <br/><br/> Використовується в [time-based умовних запитах](#1141-time-based)                                                                                                |
| If-None-Match     | **Дозволяє повертати 304 Not Modified, якщо вміст не змінено.** <br/><br/> Використовується в [content-based умовних запитах](#1142-content-based)                                                                                          |
| X-Lifecycle-Token | **Містить lifecycle token** (див. [Tracing](#8-tracing))                                                                                                                                                                                    |


#### 2.9.2 Response headers

| Заголовок             | Опис                                                                                                                                                                                                    |
|-----------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Cache-Control         | **Повідомляє всім механізмам кешування від сервера до клієнта, чи можуть вони кешувати цей об'єкт.**                                                                                                    |
| Content-Type          | **Медіа тип тіла відповіді**                                                                                                                                                                            |
| Date                  | **Дата і час відправлення повідомлення** (у форматі "HTTP-date", як визначено в [*RFC 9110: Семантика HTTP, розділ 5.6.7 "Формати дати/часу"*](https://www.rfc-editor.org/rfc/rfc9110#section-5.6.7)    |
| ETag                  | **ETag Ідентифікатор певної версії ресурсу** <br/><br/> Може бути хешем MD5, номером версії, міткою часу модифікації і т.п.                                                                             |
| Last-Modified         | **Остання дата зміни запитуваного об'єкта** (у форматі "HTTP-date", як визначено в [*RFC 9110: Семантика HTTP, розділ 5.6.7 "Формати дати/часу"*](https://www.rfc-editor.org/rfc/rfc9110#section-5.6.7) |
| Location              | **Використовується при перенаправленні або коли новий ресурс було створено.**                                                                                                                           |
| Location              | **Використовується при перенаправленні або коли новий ресурс було створено.**                                                                                                                           |
| X-Ratelimit-Limit     | **Дозволена кількість запитів в лімітному вікні**                                                                                                                                                       |
| X-Ratelimit-Remaining | **Кількість запитів що залишилась в поточному лімітному вікні**                                                                                                                                         |
| X-Ratelimit-Reset     | **Таймстамп в UNIX коли лімітне вікно обновиться**                                                                                                                                                      |

## 3. Ресурси

### 3.1 URI

*Правило*
> URI **повинен бути записаний в kebab-case.**

Приклади:

```
✅ http://parts-unlimited/openapi/suppliers-orders-cache/v1

❌ http://partsUnlimited/openapi/suppliersOrdersCache/v1

❌ http://parts_unlimited/openapi/suppliers_orders_cache/v1

❌ http://parts-unlimited/openapi/SUPPLIERS_ORDERS_CACHE/v1
```

*Правило*

> URI **ПОВИНЕН** бути формату URL.
> 
> Uniform Resource Identifier (URI) — це рядок символів, який використовується для ідентифікації імені або 
> ресурсу в Інтернеті.
>
> URI ідентифікує ресурс або за місцем розташування, або за назвою, або обома. URI має дві спеціалізації, відомі як 
> URL та URN.
>
> Uniform Resource Locator (URL) — це підмножина URI, яка визначає, де доступний визначений ресурс, і механізм його 
> отримання. URL-адреса визначає, як можна отримати ресурс. Це не обов’язково має бути URL-адреса HTTP (http://), 
> URL-адреса також може починатися з ftp:// або smb://, вказуючи протокол, який використовується для отримання ресурсу.
> 
> Uniform Resource Name (URN) — це URI, який використовує схему URN і не передбачає доступності ідентифікованого 
> ресурсу. І URN (імена), і URL (локатори) є URI, і окремий URI може бути і URL, і URN одночасно.
> 
> ![URI URL URN set](img/specification/uri-url-urn.webp)
> 
> ```
> URL: ftp://ftp.is.co.za/rfc/rfc1808.txt
> URL: http://www.ietf.org/rfc/rfc2396.txt
> URL: https://rollun.net
> URN (not URL): urn:oasis:names:specification:docbook:dtd:xml:4.1.2
> ```
> Джерело: https://stackoverflow.com/questions/4913343/what-is-the-difference-between-uri-url-and-urn

*Правило*
> Формат URL path: `/openapi/{manifest-title}/v{major-version}/{resources}`
> 
> **openapi**
>
> Обов'язковий префікс
> 
> **manifest-title**
> 
> Поле `title` з секції `info` openapi маніфесту в kebab-case.
> 
> **major-version**
> 
> Мажорна версія API (поле `version` секції `info` openapi маніфесту). Integer, що починається з одиниці.
> 
> **resources**
> 
> Повний шлях, що ідентифікує ресурс.

*Правило*
> URI **не повинен містити розширення файлу**

Замість цього розширення описується за допомогою медіа типу, який можна вказати в заголовках HTTP.

```
✅ http://parts-unlimited/openapi/suppliers-orders-cache/v1/orders

❌ http://parts-unlimited/openapi/suppliers-orders-cache/v1/orders.json
```

### 3.2 Типи ресурсів

Виділяються наступні типи ресурсів:
- [Документ](#33-документ)
  - [Скінченний автомат](#335-скінченний-автомат)
- [Колекція](#34-колекція)
- [Action](#35-action)

### 3.3 Документ

Документ - це ресурс який посилається на одну конкретну бізнес сутність або екземпляр об'єкта. Завжди json об'єкт, 
тобто не колекція, рядок і т.п.

*Правило*
> Кожен **документ повинен мати поле з ідентифікатором.** Це поле повинно називатись `id` та його тип повинен бути
> string. Ідентифікатор є чутливим до регістру, хоча в окремих випадках він може бути нечутливий.

*Правило*
> Ідентифікатор ресурсу документа рекомендується **обирати з природних бізнес ідентифікаторів** ресурсу, як, наприклад, 
> ІПН людини. У разі відсутності таких ідентифікаторів можна використовувати сурогатний ключ.

Приклад:

```http request
GET /articles/AB123
```

```json
{
  "data": {
    "id": "AB123",
    "title": "My first article!",
    "status": "draft",
    "content": "No content yet."
  }
}
```

*Правило*

> URL документа формується наступним чином: `/{collection}/{document}[/{collection/{document}]+`, де
> 
> `{collection}` - назва колекції документів (articles, orders, customers)
> 
> `{document}` - ідентифікатор документа
> 
> При цьому документ може мати дочірню колекцію, яка також буде містити документи, які своєю чергою теж можуть мати
> дочірні колекції й так далі.

![collection](img/specification/collection.png)


Приклади URL документів:
- `/orders/qwerty`
- `/orders/qwerty/customers/123`

Рекомендується не зловживати зв'язками в URI. Довгі цепочки залежностей, як, наприклад, `/customers/1/orders/99/products`
буде складніше обслуговувати та адаптувати у разі зміни зв'язків між ресурсами. Цей приклад URI краще розбити на коротші
та простіші URI: `/customers/1/orders` - щоб переглянути усі замовлення клієнта 1, а потім`/orders/99/products` щоб 
знайти усі товари замовлення 99.

#### 3.3.1 Вибірка полей ресурсу

*Правило*

> Query параметр `select` зарезервовано для отримання представлення ресурсу тільки з вказаними властивостями.
> 
> При цьому усі поля ресурсу в маніфесті повинні бути об'явленні як optional. Запит повинен мати select за 
> замовчуванням. 
> 
> Якщо запит не підтримує select (наприклад за ненадобності), то повинні повертатись усі поля ресурсу.
> 
> Якщо клієнт вказав у select властивості, яких немає у ресурсу, то повинен повернутися http код 400 з описом
> помилки в тілі відповіді.

Приклад:

```http request
GET /articles/AB123?select=title,status
```

```json
{
  "data": {
    "title": "My first article!",
    "status": "draft"
  }
}
```

#### 3.3.2 Оновлення ресурсу

Оновлення ресурсу можна здійснити одним із кількох способів.

У порядку переваги:

1. *використовуйте PUT із повними об’єктами для оновлення ресурсу до тих пір, поки це можливо (тобто взагалі не використовуйте PATCH).*

Цей варіант є кращим, якщо клієнти, ймовірно, завжди будуть враховувати повне представлення ресурсу. Якщо клієнт ігнорує 
деякі властивості ресурсу, вони, ймовірно, не будуть представлені в PUT запиті та, таким чином, втрачені. Цей сценарій 
може статися, коли під час життєвого циклу API додано нові властивості. У цьому випадку використовувати PUT не 
рекомендується.

2. Використовуйте PATCH із частковими об’єктами, щоб оновлювати лише частину ресурсу, коли це можливо, використовуючи 
стандарт [JSON Merge Patch](#261-patch-vs-put) або [JSON Patch](#261-patch-vs-put).

Використання patch рекомендується меншою мірою, оскільки його складніше реалізовувати.

**Повне оновлення**

Використовуйте PUT, якщо хочете виконати повне оновлення ресурсу документа. Усі значення замінюються значеннями, 
наданими клієнтом. Для відсутніх додаткових значень у запиті встановлюється значення за замовчуванням, якщо воно 
вказано в специфікації OpenAPI.

**Часткове оновлення**

Використовуйте PATCH, якщо хочете виконати часткове оновлення ресурсу документа.

*Правило*

> Повідомлення PATCH **ПОВИННО** відповідати специфікації [JSON Merge Patch](#261-patch-vs-put) або 
> [JSON Patch](#261-patch-vs-put). Json merge patch більш приорітетний, оскільки його простіше реалізовувати та він
> автоматично реалізований в датасторах.


#### 3.3.4 Операції над документом

| URI                   | GET                                             | POST    | PUT                                                                 | PATCH                                     | DELETE                           |
|-----------------------|-------------------------------------------------|---------|---------------------------------------------------------------------|-------------------------------------------|----------------------------------|
| /customers/1          | Отримання відомостей про клієнта 1              | Помилка | Створення або повне оновлення відомостей про клієнта 1              | Часткове оновлення клієнта 1              | Видалення клієнта 1              |
| /customers/1/orders/2 | Отримання відомостей про замовлення 2 клієнта 1 | Помилка | Створення або повне оновлення відомостей про замовлення 2 клієнта 1 | Часткове оновлення замовлення 2 клієнта 1 | Видалення замовлення 2 клієнта 1 |

POST запит повертає помилку при використанні з URL документом. Якщо вам потрібно створити новий ресурс, то 
використовуйте POST запит на URL колекції, так як описанно нижче, в розділі про колекції.

#### 3.3.5 Скінченний автомат

Скінченний автомат - це підвид документа, що описує ресурс, який в ході свого існування може змінювати стани.

##### 3.3.5.1 Стани скінченного автомата

*Правило*

> **Стан скінченного автомата міститься в полі `stage`**. Це поле є обов'язковим, та значення, які це поле може 
> приймати, повинні бути описані в маніфесті як enum.

Серед станів можна виділити початковий, проміжні та кінцеві.

*Початковий стан* - це той в який скінченний автомат може потрапити після свого створення. Початковий стан може бути
лише один.

*Кінцеві стани* - це такі стани, після потрапляння в які, зміна стану скінченного автомата більше не можлива. Кінцевий
стан повинен бути хоча б один. Після потрапляння автомата в кінцевий стан він залишається в ньому назавжди й вже не 
може змінювати стани на інші.

Також скінченний автомат може мати додаткові поля. На прикладі нижче таким додатковим полем є `orderId`, яке з'являється
при `fulfilled` стейджі.

Окрім `stage` є ще обов'язкове поле `status`, яке може приймати три значення:
- `pending` - якщо автомат НЕ в кінцевому стані
- `fulfilled` - якщо автомат в кінцевому стані і його виконання завершилось успішно
- `rejected` - якщо автомат в кінцевому стані і його виконання завершилось невдало


*Правило*

> **Кожен стейдж однозначно відповідає одному зі статусів.** Тобто в нас є початковий та проміжні стейджі, що 
> відповідають статусу pending. Є кінцеві невдалі стейджі, що відповідають статусу rejected. Та кінцеві вдалі, що 
> відповідають статусу fulfilled. **Початковий stage повинен називатися start.**

Приклад запису стейджів в маніфесті:

```yaml
FSM:
  type: object
  properties:
    stage:
      type: string
      oneOf:
        - $ref: '#/components/schemas/PendingStage'
        - $ref: '#/components/schemas/FulfilledStage'
        - $ref: '#/components/schemas/RejectedStage'
    status:
      type: string
      enum:
        - pending
        - rejected
        - fulfilled

  # Опис стейджів, що належать статусу pending
  PendingStage:
    type: string
    enum:
      - start
      - anotherState

  # Опис стейджів, що належать статусу fulfilled
  FulfilledStage:
    type: string
    enum:
      - completed

  # Опис стейджів, що належать статусу rejected
  RejectedStage:
    type: string
    enum:
      - error
```

Поле `problem` у форматі [application/vnd.rollun-error+json](#43-applicationvndrollun-errorjson) є обов'язковим при 
статусі `rejected`

![Order creating stages](img/specification/creating-order-stages.jpg)
<p style="text-align: center;">Рис. Приклад скінченного автомата по створенню замовлення.</p>

##### 3.3.5.2 Створення скінченного автомата

*Правило*

> У відповідь на створення скінченного автомата ми отримуємо лише його ідентифікатор, а не повну 
> сутність.

Example request

```http request
POST /order-creation-tasks
Content-Type: application/vnd.rollun-request+json
```

```json
{
  "payload": {
    "idempotencyKey": "qwerty",
    "to": "WA, Yakima, 1712 Melrose Street, 98908",
    "items": [
      {
        "id": "ABC12",
        "qty": 1
      }
    ]
  }
}
```

Example response

```http
HTTP/1.1 200 OK
Content-Type: application/vnd.rollun-document+json
Location: /order-creation-tasks/qwerty123
```

```json
{
  "data": {
    "id": "qwerty123"
  }
}
```

##### 3.3.5.3 Перехід між стейджами скінченного автомата
*Правило*

> Стейджі скінченного автомата можуть змінюватись як сервером, так і клієнтом, якщо це допустимо.
>
> Клієнт може змінювати стейджі за допомогою http запитів, що завчасно описані в маніфесті. 
> 
> Запити можуть бути наступних видів у порядку приорітету:
> 1. PATCH & PUT запити, що змінюють поля скінченного автомата, окрім полів `stage` та `status`. Автомат повинен сам
> реагувати на зміни своїх полів та змінювати `stage`.
> 2. POST /actions/... - екшени, що переводять скінченний автомат з одного стейджу в інший
> 3. Пряме редагування поля `stage` клієнтом. Не рекомендується до використання.

При цьому, коли скінченний автомат переходить в якийсь із стейджів (навіть самого в себе), то на сервері можуть
запускатись трігери, які також можуть змінити стейдж скінченного автомата.

*Правило*

> Якщо спробувати виконати запит, що не дозволенний в поточному стейджі скінченного автомата, то повинна повернутись 
> помилка 409 Conflict or 422 Unprocessable Content (TODO: погодити статус код).

Наприклад уявімо автомат, який описує стани статті. Вона може бути в чотирьох станах: start, validationError, 
readyToPublish, published. Поки вона знаходиться в станах validationError та readyToPublish то ми її можемо редагувати 
за допомогою PATCH запиту. При цьому після кожного редагування на сервері запуститься трігер який проведе валідацію 
статті і в залежності від результата може змінити її стейдж. Коли стаття в стейджі readyToPublish то ми можемо 
запустити екшен `POST /articles/actions/publish`, що переведе статтю в published стейдж.

![Article stages](img/specification/article-stages.jpg)
<p style="text-align: center;">Рис. Опис скінченного автомата: стаття</p>

### 3.4 Колекція

Колекція - це масив ресурсів типу документ.

*Правило*

> **Для назв колекцій слід використовувати іменник у множині**, як, наприклад, `employers`, `people`, `orders`.

Приклад колекції

```http request
GET /orders
```

```json
{
  "data": [
    {
      "id": "1",
      "invoice": {
        "total": 10.34,
        "currency": "USD"
      }
    },
    {
      "id": "2",
      "invoice": {
        "total": 12.26,
        "currency": "USD"
      }
    }
  ]
}
```

### 3.4.1 RQL

Фільтрування, вибірка та пагінація в колекціях здійснюється за допомогою RQL.

*Правило*

> Кожна колекція повинна підтримувати RQL. Але, за потреби, може робити це не в повному обсязі. Наприклад відмовитись
> від підтримки groupby ноди. Про це повинно бути написано в описі операції в openapi маніфесті. 
> 
> Якщо клієнт надсилає rql який не підтримується сервером, то сервер повинен відповісти кодом 501 Not Implemented з
> описом помилки в тілі відповіді.

#### 3.4.1.1 Опис RQL

Через обмеження openapi маніфесту описати RQL згідно його [*специфікації*](https://www.eclipse.org/ditto/basic-rql.html)
не можливо, оскільки хоч в специфікації URL явно не вказано в якому форматі повинна бути query частина, тобто це може 
бути будь-який рядок. Але в openapi специфікації query обов'язково повинно бути у форматі ключ=значення. Тому хоч з 
точки зору URL запис mydomain.com?eq(id,1) коректний, але в openapi маніфесті його ніяк не опишеш. Детальніше: 
[*issue #1502*](https://github.com/OAI/OpenAPI-Specification/issues/1502).

Для розв'язання цієї проблеми ми розділили RQL на декілька логічних частин, щоб його можна було записати в форматі 
ключ-значення.

Опис усіх ключів RQL в openapi маніфесті:

```yaml
"/resources":
    get:
      parameters:
        - name: query
          in: query
          required: false
          schema:
            type: string
            example: 'and(eq(field1,value1),eq(field2,value2))'
        - name: limit
          in: query
          required: false
          schema:
            type: integer
            default: 20
            example: 20
        - name: offset
          in: query
          required: false
          schema:
            type: integer
            default: 0
            example: 0
        - name: sort
          in: query
          required: false
          schema:
            type: string
            example: -field1
        - name: select
          in: query
          required: false
          style: form
          explode: false
          schema:
            type: array
            items:
              type: string
            example: field1,field2
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ResourceListResult"
```

```
/resource?query=and(eq(field1,value1),eq(field2,value2))&limit=20&offset=20&sort=-field1&select=field1,field2
```

#### 3.4.1.2 Фільтрація

Фільтрація елементів колекції здійснюється за допомогою query параметру `query`. 

Наприклад query ```/cars?query=and(eq(doors,5),or(eq(color,blue),eq(color,black)))``` буде інтерпретовано як "знайти
автомобілі у яких 5 дверей та їх колір або синій або чорний".

#### 3.4.1.3 Пагінація

*Правило*

> Якщо колекція передбачувано буде мати багато елементів, то вона **ПОВИННА** підтримувати пагінацію. Визначення того, 
> що вважати за "багато" елементів залишається на архітекторі системи, адже це може залежати від вимог до швидкості 
> роботи системи, обмеженням по пам'яті, розміру конкретного ресурсу та багато чого іншого.

Існує два популярних підходи до реалізації пагінації:
- offset-based
- cursor-based (aka key-based or luke index):

*Правило*

> Для пагінації повинен використовуватись offset-based підхід.

**Опис offset-based підходу**

Це пагінація в якому для опису поточної сторінки вказується номер елементу, що наступний після останнього отриманого. 
Контролюється двома параметрами: розмір сторінки (limit) та зміщення (offset). 

Для початку клієнт повинен визначитись з тим скільки елементів колекції повинно повертатись на одній сторінці. Це буде
query параметр limit. При цьому цей параметр може мати значення по замовчуванню. Потім, щоб перейти на сторінкку з 
номером n, де n - це ціле число, що більше або рівне за одиницю, клієнт повинен передати query параметр offset, який 
розраховується наступним чином: `offset = (n - 1) * limit`

*Правило*
> Query параметри offset і limit **ПОВИННІ** мати значення по замовчуванню.

Переваги:
- Велика поширеність у фреймворках/інструментах.
- Простота використання
- Можливість "стрибнути" на якусь певну сторінку, попередньо не отримавши на неї посилання

Недоліки:
- Порівняно низька швидкість роботи для виликих наборів данних.
- Низька швидкість роботи в NoSQL базах даних
- Можливість дублікатів при обході сторінок, якщо при цьому додався новий запис в базу даних.

*Правило*

> Значення `pagination` query параметра `metadata` зарезервовано для того, щоб отримати додаткові дані про пагінацію, 
> як, наприклад, загальна кількість елементів у колекції.

Request example
```http request
GET /resources?metata=pagination
```

Response example
```json5
{
  "metadata": {
    "pagination": {
      "totalCount": 101,
      "offset": 0,
      "limit": 20
    }
  },
  "data": [
    // ...
  ]
}
```

### 3.4.2 Операції над колекцією

| URI                            | GET                                           | POST                                      | PUT                                                           | PATCH   | DELETE                                                  |
|--------------------------------|-----------------------------------------------|-------------------------------------------|---------------------------------------------------------------|---------|---------------------------------------------------------|
| /customers/                    | Отримання колекції усіх клієнтів              | Створення нового клієнта                  | Масоване оновлення/створення колекції клієнтів                | Помилка | **ЗАБОРОНЕНО** (Видалення усіх клієнтів.)               |
| /customers/1/orders            | Отримання колекції усіх замовлень клієнта 1   | Створення нового замовлення для клієнта 1 | Масоване оновлення/створення колекції замовлень для клієнта 1 | Помилка | **ЗАБОРОНЕНО** (Видалення усіх замовлень для клієнта 1) |
| /customers?query=eq(name,John) | Отримання колекції усіх клієнтів з ім'ям John | Помилка                                   | Масоване оновлення/створення колекції клієнтів з ім'ям John   | Помилка | Видалення усіх клієнтів з ім'ям John                    |

*Правило*

> Використання DELETE методу на колекцію без застосування фільтрації - ЗАБОРОНЕНО.


*Правило*

> **При створенні документа заборонено передавати ідентифікатор, з яким повинен створитись документ.** Замість цього
> використовуйте PUT запит.

### 3.5 Action

Action (екшн) ресурс - це процедурний концепт. Action ресурси - це віддалено запускаємі функції з вхідними аргументами та
результатом. Вони можуть бути корисні, щоб описати операції, які не підпадають під операції над колекціями чи 
документами, наприклад, валідація даних.

*Правило*
> Назва екшену повинна бути дієсловом, а не іменником. Кожен action міститься в колекції actions. Ця колекція може 
> бути як окрема колекція, якщо action виконує дію над декількома ресурсами одночасно, так і дочірньою для документа.
>
> Запуск екшена може виконуватись одним із http методів:
> - POST - якщо екшн має побічні ефекти (змінює стан ресурсу), або для екшенів що не мають побічних ефектів, але 
> потребують тіло запиту
> - GET - для екшенів, що не мають побічних ефектів

Приклади:

Відправка повідомлення роботодавцю

```http request
POST /employers/93017373/actions/send-notification
```

Response:

```http
HTTP/1.1 200 OK
Content-Type: application/vnd.rollun-response+json
```

```json
{
  "data": {
    "success": true
  }
}
```

Конвертація грошей з однієї валюти в іншу (використовується GET, тому що операція не має побічних ефектів)

```http request
GET /actions/convert-money?from=EUR&amount=45&to=USD
```

*Правило*

> Перш ніж використовувати action подумайте над тим чи можливо його представити у вигляді ресурсу документа чи колекції,
> що описує намір дії.

Наприклад екшн відправки повідомлення

```http request
POST /employers/93017373/actions/send-notification
```

можна замінити ресурсом колекції

```http request
POST /employers/93017373/notifications
```

Використання іменника тут покращує розширюваність операцій. Наприклад можна додати GET запит, що поверне історію
усіх відправлених повідомлень.

Якщо вам потрібно реалізувати протяжний у часі екшн, який не зможе повертати результат синхронно, то рекомендується
поглянути у бік скінченного автомата, або реалізовувати екшн як лонг таск.

## 4. Media types

*Правило*

> Формат назви медіа типу: `application/vnd.{name}+{format}`
> 
> `application/vnd.` - обов'язковий префікс
> 
> `{name}` - унікальна назва медіа типу
> 
> `{format}` - формат данних (json,xml,csv, ...). На даний момент підтримується лише `json`. 


Медіа типи дозволяють дотримуватись обмеження REST на самоописувані повідомлення. Фактично вони виступають як 
дискримінатор того, що знаходиться в тілі запиту. Медіа типи можуть бути корисними, коли нам потрібно написати проксі 
сервер, що буде якось обробляти відповіді чи запити: наприклад логувати специфічні типи помилок, або вести метріки. 
Також він може бути корисним, щоб розрізняти тип помилки: можна створити два медіа типи, під технічні та бізнес помилки.

### 4.1 Схема опису

- **Parent:** батьківський медіа тип. Описуваний медіа тип містить усі властивості батківського типу,
  якщо явно не написано інше.

### 4.2 application/vnd.rollun-request+json

**Parent:** application/json

Цей медіа тип призначений для тіла запиту.

На верхньому рівні є завжди json об'єктом (не масивом, примитивом etc).

Для передачі корисних даних (фактично вхідних аргументів) повинно використовуватись поле `payload`. Якщо вхідні
аргументи завжди відсутні для данного типу операції, то поле `payload` не повинно передаватись взагалі. Якщо ж операція
загалом має вхідні аргументи, але при конкретному виклику вони відсутні, то поле `payload` повинно передаватись зі 
значенням `null`.

Передача інформації, для якої є визначені в http специфікації заголовки, повинна передаватись через них.

Openapi schema:

```yaml
Request:
    type: object
    properties:
        payload:
            nullable: true
            description: >
                Корисна інформація про стан ресурсу, або колекції ресурсів. Стан ресурсу описується набором полей 
                об'єкту, або примитивом (рядок, число і т.п.).
```

### 4.3 application/vnd.rollun-error+json

- **Parent:** application/json

Медіа тип призначений для опису помилок при створенні чи отриманні ресурсу і **НЕ ПОВИНЕН** використовуватись у запитах.
**МОЖЕ** використовуватись разом з 2хх кодом, якщо сама http операція виконалась успішно, але результат який описується
цією операцією - помилка. Приклад такої поведінки можна знайти в описі лонг тасків.

На верхньому рівні є завжди json об'єктом.

Об'єкт **НЕ ПОВИНЕН** містити поле `data`.

Об'єкт **ПОВИНЕН** містити поле `problem` з об'єктом опису помилки.

Ми беремо об'єки помилки у форматі зі стандарту [*RFC-7807*](https://www.rfc-editor.org/rfc/rfc7807) додаячи деякі свої
вимоги.

Об'єкт опису помилки **ПОВИНЕН** містити наступні поля:
- `title` (string) - engineers-readable повідомлення з коротким описом типу помилки. Має бути однаковим для однакових
типів помилок.
- `detail` (string) - human-readable повідомлення з детальним описом помилки.
- `status` (number) - http статус код, що описує помилку (може не завжди відповідати статус коду, що повернувся у 
відповіді, наприклад, якщо помилка описує результат попередньої операції).
- `type` (string) - uri, що описує помилку.
- `instance` (string) - uri конкретно цього випадку проблеми (в нашому випадку це lifecycle_token)

Об'єкт опису помилки **МОЖЕ** містити наступні поля:
- `context` - опціональний, довільний json object з деталями помилки

На прикладі це виглядає наступним чином:

Запит

```http request
POST /articles
Content-Type: application/vnd.rollun-request+json

{
  "payload": {
    "title": "Hello, world!"
  }
}
```

Відповідь

```http
HTTP/1.1 400 Bad Request
Content-Type: application/vnd.rollun-error+json
```

```json
{
  "problem": {
    "type": "https://rollun.org/docs/openapi/problems/inputValidationProblem",
    "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
    "status": 400,
    "title": "Validation error",
    "detail": "There is no author in request body",
    "context": {
      "issues": [
        {
          "type": "https://rollun.org/docs/openapi/problems/inputValidationProblem:schemaViolation",
          "in": "body",
          "name": "author",
          "detail": "Field author is mandatory"
        }
      ]
    }
  }
}
```

**Формат поля `type`:**

`https://rollun.org/docs/openapi/problems[/{api}]/{type}`

де:

`<api>` [необов'язковий]: назва api (title маніфесту), для специфічних помилок конкретного API

`<type>`: тип помилки в kebab-case

*Типи помилок, за можливості, потрібно робити незалежними від конкретного API*

**Формат поля `instance`:**

`https://elastic.com/logs?lifecycle-token=<lifecycle-token>`

Поле `issues` специфічне для типу помилки `https://rollun.org/docs/openapi/problems/validationError`

Об'єкт на верхньому рівні **МОЖЕ** містити поле `warnings` з об'єктом попередження.

Openapi schema:

```yaml
ErrorResponse:
    type: object
    properties:
        problem:
          allOf:
            - $ref: "#/components/schemas/Message"
        warnings:
          type: array
          items:
            $ref: "#/components/schemas/Warning"

Problem:
  description: A Problem Details object (RFC 7807)
  type: object
  required:
    - type
    - title
    - status
    - detail
    - instance
  properties:
    type:
      type: string
      format: uri
      description: An absolute URI that identifies the problem type
      example: https://rollun.org/docs/openapi/problems/service-unavailable
    title:
      type: string
      description: |
        A short, summary of the problem type. Written in English and readable for engineers (usually not suited 
        for non technical stakeholders and not localized).
      example: Service Unavailable
    status:
      type: integer
      format: int32
      description: The HTTP status code generated by the origin server for this occurrence of the problem.
      minimum: 400
      maximum: 600
      exclusiveMaximum: true
      example: 503
    detail:
      type: string
      description: A human-readable explanation specific to this occurrence of the problem
      example: External API is temporarily unavailable. Please try again after 120 seconds.
    instance:
      type: string
      format: uri
      description: Uri to where logs is placed. Should contain lifecycle token
      exampole: https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW
    context:
      type: object
      additionalProperties: true
      description: Object with error details

Warning:
  description: A warning object
  type: object
  required:
    - type
    - title
    - status
    - detail
    - instance
  properties:
    type:
      type: string
      format: uri
      description: An absolute URI that identifies the problem type
      example: https://rollun.org/docs/openapi/warnings/deprecation
    title:
      type: string
      description: |
        A short, summary of the problem type. Written in English and readable for engineers (usually not suited 
        for non technical stakeholders and not localized). The same for the same warning types.
      example: Deprecation
    detail:
      type: string
      description: A human-readable explanation specific to this occurrence of the problem
      example: Field 'author' is deprecated
```

### 4.4 application/vnd.rollun-response+json

- **Parent:** application/json

Медіа тип призначений для успішних відповідей з результатом в тілі відповіді.

На верхньому рівні є завжди json об'єктом.

Результат **ПОВИНННЕН** міститись у полі `data`.

### 4.5 application/vnd.rollun-document+json

**Parent:** application/vnd.rollun-response+json

Медіа тип призначений для успішних відповідей з документом в тілі відповіді.

На верхньому рівні є завжди json об'єктом.

Представлення документа **ПОВИННО** міститись у полі `data`.

Поле `data` **МОЖЕ** бути відсутнім, якщо успішне виконання операції має пусте представлення. Відсутність результату
(поле `data` відсутнє) може повертатись операцією, яка ніколи не повертає ніякого результату. У таких операцій все ще є
сенс повертати тіло відповіді, оскільки, окрім безпосередньо результату (поля'data') в ньому може міститись інформація
про попередження, метаданні і т.п.

Поле `data` може містити порожній результат, тобто дорівнювати null, що означає, що операція загалом повертає результат,
але у данному конкретному випадку його немає (з легальних причин).

Об'єкт **МОЖЕ** містити поле `warnings` з масивом об'єктів попередження.

Формат об'єкта попередження:
- `type` - urn з типом помилки
- `title` - engineers-readable повідомлення з коротким описом попередження.
- `details` - human-readable повідомлення з коротким описом попередження.

Openapi schema:

```yaml
DocumentResponse:
    type: object
    properties:
        data:
          type: object
          nullable: true
          description: >
            Представлення документа. Представлення ресурсу документа описується набором полей 
            об'єкту, або примитивом (рядок, число і т.п.).
        warnings:
          type: array
          items:
            $ref: "#/components/schemas/Warning"

Warning:
  description: A warning object
  type: object
  required:
    - type
    - title
    - status
    - detail
    - instance
  properties:
    type:
      type: string
      format: uri
      description: An absolute URI that identifies the problem type
      example: https://rollun.org/docs/openapi/warnings/deprecation
    title:
      type: string
      description: |
        A short, summary of the problem type. Written in English and readable for engineers (usually not suited 
        for non technical stakeholders and not localized). The same for the same warning types.
      example: Deprecation
    detail:
      type: string
      description: A human-readable explanation specific to this occurrence of the problem
      example: Field 'author' is deprecated
```

### 4.6 application/vnd.rollun-collection+json

- **Parent:** application/json

Медіа тип призначений для повернення колекцій документів.

На верхньому рівні є завжди json об'єктом.

Поле `data` **ПОВИННО** бути присутнім і містити массив - колекцію документів.

Поле `metadata` **МОЖЕ** бути присутнім і містити додаткову інформацію про колекцію:
- про пагінацію
  - offset - поточний відступ
  - limit - кількість елементів на сторінці
  - totalCount - загальна кількість елементів

Openapi schema:

```yaml
CollectionResponse:
    type: object
    required:
      - data
    properties:
        data:
          type: array
          description: An array of documents 
          items:
            type: object
        metadata:
            $ref: "#/components/schemas/Metadata"
            description: Метаінформація про ресурс, або колекцію ресурсів.
        warnings:
          type: array
          items:
            $ref: "#/components/schemas/Warning"
Metadata:
  type: object
  properties:
    pagination:
      allOf:
        - $ref: "#/components/schemas/PaginationMetadata"

OffsetPaginationMetadata:
  required:
    - totalCount
    - limit
    - offset
  properties:
    totalCount:
      type: int
      description: total items in collection
    limit: 
      type: int
      description: count of elements in current page
    offset:
      type: int
      description: offset of current page

Warning:
  description: A warning object
  type: object
  required:
    - type
    - title
    - status
    - detail
    - instance
  properties:
    type:
      type: string
      format: uri
      description: An absolute URI that identifies the problem type
      example: https://rollun.org/docs/openapi/warnings/deprecation
    title:
      type: string
      description: |
        A short, summary of the problem type. Written in English and readable for engineers (usually not suited 
        for non technical stakeholders and not localized). The same for the same warning types.
      example: Deprecation
    detail:
      type: string
      description: A human-readable explanation specific to this occurrence of the problem
      example: Field 'author' is deprecated
```

### 4.7 application/vnd.rollun-long-task+json

- **Parent:** application/vnd.rollun-document+json

Призначений для опису стану виконання асинхронної задачі.

Поле `data` **ПОВИННО** бути присутнім. В полі `data` **ПОВИНЕН** міститись об'єкт `long-task`.

Об'єкт `long-task` **ПОВИНЕН** містити поля:
- `id` : string - ідентифікатор задачі.
- `idempotency-key` - ключ ідемпотентності
- `status` - enum: pending, rejected, fulfilled
- `problem`: `application/problem+json` - якщо статус 'rejected'
- `data`: object - результат задачі, якщо статус 'fulfilled'

Об'єкт `long-task` **МОЖЕ** містити поля:
- `stage` : string - етап виконання задачі, повинен бути enum
- `percentComplete`: int[0-100] - стан виконання задачі у відсотках
- `createdAt`: date-time - час створення задачі
- `startedAt`: date-time - час початку виконання задачі

При використанні цього типу, якщо задача в статусі `pending`, то **РЕКОМЕНДУЄТЬСЯ** повертати хедер `Retry-After`,
що буде описувати естімейт, коли задача завершиться.

### 4.8 application/vnd.rollun-long-task-collection+json

- **Parent:** application/vnd.rollun-collection+json

Колекція об'єктів `long-task`.

В полі `data` усі об'єкти **ПОВИННІ** бути типу `long-task` як описано в медіа типі 
`application/vnd.rollun-long-task+json`.

### 4.9 application/vnd.rollun-fsm+json

- **Parent:** application/vnd.rollun-document+json

Поле `data` **ПОВИННО** бути присутнім. В полі `data` **ПОВИНЕН** міститись об'єкт `fsm`.

Об'єкт `fsm` **ПОВИНЕН** містити поля:
- `id` : string - ідентифікатор скінченного автомата.
- `idempotency-key` - ключ ідемпотентності
- `status` - enum: pending, rejected, fulfilled
- `stage` : string - етап виконання задачі, повинен бути enum
- `problem`: `application/problem+json` - якщо статус 'rejected'

### 4.10 application/vnd.rollun-fsm-collection+json

- **Parent:** application/vnd.rollun-collection+json

Колекція об'єктів `fsm`.

В полі `data` усі об'єкти **ПОВИННІ** бути типу `fsm` як описано в медіа типі `application/vnd.rollun-fsm+json`.

### 4.11 Підсумок

Діаграма наслідування медіа типів:

![Media-types](img/specification/media-types.jpg)

## 5 Openapi

OpenAPI є домінуючим стандартом для документації API, який отримав широку підтримку в індустрії.

*Правило*

> **Для кожного API повинні бути надані специфікації з використанням [*OpenAPI 3.0*](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md)**

В Openapi маніфесті присутнє поле externalDocs де можна вказати посилання на додаткову документацію. 

*Правило*

> Будь-яка додаткова документація повина бути пов'язана з OpenAPI API маніфестом за допомогою externalDocs властивості.

Приклад

```yaml
openapi: "3.0.0"
info:
  title: petShop
  description: API exposing my pet shop’s functionality
  version: "2.1.2"
servers:
  - url: https://example.org/openapi/pet-shop/v2
paths: {}
externalDocs: # <-----------
  description: API Documentation
  url: https://docs.example.org/openapi/pet-shop/v2
```

*Правило*

> **Файли OpenAPI повинні бути доступні у форматі YAML**, а також, за бажанням, у форматі JSON.
> 
> YAML - має усі можливості JSON, а також дозволяє коментарі.

*Правило*

> Коли API має багато операцій, використовуйте теги, щоб згрупувати їх разом. Це зробить візуальне представлення 
> (SwaggerUI) більш читабельним.

*Правило*

> Додайте приклади відповідей до специфікації OpenAPI у властивості examples.

Приклад:

```yaml
  /articles/{id}:
    get:
      operationId: getArticle
      parameters:
      - in: path
        name: id
        required: true
        schema:
          type: string
      responses:
        "200":
          description: successful operation
          content:
            application/json:
              schema:
                $ref: '#/definitions/Article'
              examples: # <---------------
                success:
                  {
                    "data": {
                      "id": "qwerty",
                      "title": "My first article!"
                    }
                  }
```

*Правило*

> Усі openapi маніфести повинні зберігатись в [`rollun-com /openapi-manifests`](https://github.com/rollun-com/openapi-manifests)
> репозиторії.

Openapi дозволяє посилатись з одного файлу маніфесту на компоненти, що визначені в інших файлах. Таким чином типи даних, 
що використовуються в різних маніфестах, можна описати один раз в окремому файлу.

*Правило*

> Типи даних, що використовуються в декількох Api, повинні знаходитись в OpenApi файлах за шляхом:
> ```
> <domain>/v<major-version>/<domain-version>.yaml
> or
> <domain>/<subdomain>/v<major-version>/<domain-subdomain-version>.yaml
> ```

Приклад:

`/item/identifier/v1/item-identifier-v1-1-2.yaml`
```yaml
info:
  title: item-identifier
  description: data types for item identifiers
  version: "1.1.2"
paths: {} # empty paths property required to be a valid OpenAPI file
components:
  schemas:
      Rid:
          description: "unique id of some items in our system"
          type: string
```

На тип можна посилатися з іншого файлу OpenAPI наступним чином:

```yaml
"$ref": "{url-to-file}#/definitions/Rid"
```

*Правило*

> Маніфести з загальними типами даних, що використовуються в багатьох маніфестах повинні зберігатись в
> `rollun-com/openapi-manifests-common` репозиторії


## 6 Версіонування API

### 6.1 Підхід до версіонування

З великою ймовірністю REST API, що описане в маніфесті, буде змінюватись. Зміни можуть бути наступними:
- Виправлення помилок
- Впровадження нових можливостей
- Видалення старих можливостей
- Зміна старих можливостей

При цьому деякі зміни можуть приводити до появи помилок на клієнті, наприклад, якщо було видалено поле яким
користувався клієнт.

Для того, щоб не запобігти неочікуваної появи помилок, через зміни API інтерфейсу в маніфесті, можна використовувати
версіонування API.

> Api - це абстрактне поняття, яке може бути описане за допомогою різних форматів: openapi маніфест,
> мова програмування, природня мова (e.g. українська, англійська) і т.п.
>
> Тому на далі коли говориться про зміну в API (чи REST API), то також мається на увазі, що й ідентична зміна
> відбудеться в openapi маніфесті, як в документі, що описує API. Так само і навпаки: зміна в маніфесті означає
> ідентичну зміну в API, який описується цим маніфестом.

Для версіонування будь-якого API (будь-то інтерфейс php бібліотеки, чи REST API) існує стандарт під назвою
[*семантичне версіонування*](https://semver.org/lang/uk/). Який ми й будемо використовувати.

> Короткий опис семантичного версіонування:
>
> Версія має вигляд МАЖОРНА.МІНОРНА.ПАТЧ. При цьому слід збільшувати:
> 1. МАЖОРНУ версію, якщо зроблені зміни API, що несумісні з попередньою версією
> 2. МІНОРНУ версію, якщо додана нова функціональність, що є сумісною з попередньою версією
> 3. ПАТЧ версію, якщо були зроблені виправлення помилок, що не впливають на сумісність з попередньою версією

Зміна буде вважатись сумісною з попередньою версією, тоді коли при заміні старої версії API на нову, функціонування
**будь-якої** системи, яка **користується** цим API, не порушиться.

Важливо розуміти, що сумісність розглядається лише стосовно системи, яка **користується** API, а не для системи, яка
**реалізовує** це API. В загальному випадку будь-яка зміна API є несумісною для системи, що **реалізовує** API,
хоча й в деяких конкретних випадка, в залежності від специфіки реалізації, можуть бути виключення. Так само як і зміна,
що в загальному випадку порушує сумісність, може не порушувати її для якогось конкретного специфічного клієнта.

> У нашому випадку систему, яка користується API - клієнт, а система, що реалізовує API - сервер.

*Правило:*

> В маніфесті потрібно застосовувати [*семантичне версіонування*](https://semver.org/lang/uk/). Версія повинна
> записуватись в `info` секцію, поле `version`.

```yaml
openapi: "3.0.0"
info:
  title: petShop
  description: API exposing my pet shop’s functionality
  version: "2.1.2"
servers:
  - url: https://example.org/openapi/pet-shop/v2
paths:
  # ...
```

*Правило*

> Версіонування api ПОВИННО вказуватись в URL, це дозволить простіше кешувати ресурси (адже uri однозначно
> співвідноситься з даними які повертаються), а також дозволить вказувати версію при відправці get запиту через браузер.
>
> Тільки мажорна версія повинна бути вказанна в URL. Тим самим сервер в один момент часу може реалізовувати тільки
> одну мінорну та патч версію для кожного мажорного релізу.

*Правило*

> Після оновлення маніфесту, його потрібно тримати в draft розділі допоки усі сервера не реалізують його нову версію.
> Якщо ж якись сервер не може реалізувати нову версію, то його потрібно прибрати зі списку серверів та випустити
> нову *мажорну* версію маніфесту.

### 6.2 Коли змінювати мажорну версію

При *будь-яких* змінах, що порушують зворотну сумісність (в тому числі при виправленні помилок, за виключеннями, що
будуть описані талі).

Приклади змін, що порушують зворотну сумісність:
- Змінна типу поля
- Зміна значення (сенсу) поля, навіть якщо його тип не змінився
- Видалення поля
- Додання обмежень до логіки валідації
- Маніпуляція з enum:
  - Збільшення діапазону enum значень у відповіді
  - Зменшення діапазону enum значень у запиті
  - Зміна сенсу enum значень
  - Зменшення діапазону enum значень у відповіді (тому що це впливає на валідацію)
- Видалення ендпоінту
- Додання обов'язкового поля до запиту
- Зміна поля з необов'язкового на обов'язкове у запиті
- Видалення сервера зі списку серверів

Рекомендується, за можливості, запобігати таких змін. Для цього можна, наприклад:
- замість видалення поля/ендпоінту, можна його відмітити як deprecated.
- Замість зміни сенсу, або типу поля можна створити нове поле, та підтримувати обидва поля, до наступної мажорної
  версії маніфесту.

### 6.3 Коли змінювати мінорну версію

Зі [*специфікації семантичного версіонування*](https://semver.org/lang/uk/#spec-item-7):

> Мінорна версія Y (x.Y.z | x > 0) ПОВИННА бути збільшена, якщо до публічного API додана нова зворотньосумісна
> функціональність. Вона ПОВИННА бути збільшена, якщо будь-яка функціональність публічного API позначена, як
> застаріла (deprecated). Вона МОЖЕ бути збільшена, якщо в приватний код внесені істотні зміни функціональних
> можливостей або вдосконалення. Вона МОЖЕ включати зміни рівня патчів. Патч версія ПОВИННА бути скинута до 0 при
> збільшенні мінорної версії.

Приклади:
- Додання нової інформації у відповідь, яка ніяк не впливає на інформацію, що вже поверталась.
  > При умові, що клієнти ігнорують усі невідомі їм поля
  >
  > Наприклад нам поверталась деяка відстань в метрах в полі `distanceInMeters`, а потім ми додали поле
  > `distanceInFoots` з цією самою відстанню, але в футах.
- Додання необов'язкового поля до запиту
- Помітити enum значення/поле/ендпоінт як deprecated.
- Додання нового ендпоінту
- Додання документації
- Додання нового серверу до списку серверів

*Правило*

> Якщо поле/значення/ендпоінт визначили як deprecated, то це потрібно зазначити в openapi маніфесті.

Приклад позначення поля як deprecated:

```yaml
components:
  schemas:
    Service:
      type: object
      properties:
        location:
          type: string
          description: Location of the service
          example: '400 Street name, City State postcode, Country'
          deprecated: true    # <---------
```

Приклад позначення значення як deprecated:

На жаль наразі відмітити одне значення з діапазону enum як застаріле неможливо, тому це потрібно просто писати в
описі. Наприклад, якщо ми перестаємо використовувати значення in_progress в деякому status енамі, то в маніфесті це
потрібно відобразити так:
```
status:
  type: string
  description: |
    pending - ...
    in_progress - deprecated.
    fulfilled - ...
    rejected - ...
  enum:
    - pending
    - in_progress
    - fulfilled
    - rejected
```

*Правило*

> У випадку, якщо якесь enum значення, що використовується лише у відповідях, поміченно як deprecated, то сервер
> **ПОВИНЕН** перестати його використовувати.

Приклад позначення ендпоінту як deprecated:

```yaml
/pet:
  get:
    deprecated: true
```

### 6.4 Коли змінювати patch версію

Це виправлення помилок, що не порушують [зворотну сумісність](#63-коли-змінювати-мінорну-версію). А також:
- Додання прикладів в маніфест
- Виправлення помилок в документації (коментарях та описах).

### 6.5 Контроль версій за допомогою User-Agent та Server хедерів

Оскільки серверів так само як і клієнтів може бути безліч, та вони усі можуть реалізовувати/використовувати різні
версії маніфесту (Рис 6.5-1), а в деяких випадках одночасно декілька, то потрібен механізм, що буде контролювати
сумісність версій маніфесту на клієнті та сервері.

![Рис 1.3.1-1](../docs/img/specification/api-versioning.jpg)
<p style="text-align: center;">Рис 6.5-1</p>

Для контролю сумісності між мажорними версіями використовується url, але в ньому не вказані мінорні та патч версії. Для
того, щоб повністю контролювати сумісність клієнта та сервера можна використовувати User-Agent та Server хедери,
наступним чином:

*Правило*

> Клієнт в кожному запиті **ПОВИНЕН** передавати назву/версію маніфесту та генератора з якого відправляється запит
> у хедері [*Used-Agent*](https://datatracker.ietf.org/doc/html/rfc2616#section-14.43). Приклад:

Request:
```http request
GET /resources
User-Agent: {Generator-Name}/{Generator-Version} {Manifest-Title}/{Manifest-Version}
```

*Правило*

> Сервер **ПОВИНЕН** передавати назву/версію маніфесту та генератора, що оброблювали запит у хедері
> [*Server*](https://datatracker.ietf.org/doc/html/rfc2616#section-14.38).

*Правило*

> Якщо версія маніфесту, що реалізованна сервером менша, ніж передана клієнтом у запиті, то код відповіді від сервера
> **ПОВИНЕН** бути [*501 Not Implemented*](https://datatracker.ietf.org/doc/html/rfc2616#section-10.5.2). 

Приклад:

Response
```http
HTTP/1.1 200 OK
Server: {Generator-Name}/{Generator-Version} {Manifest-Title}/{Manifest-Version}
```

*Правило*

> Клієнт може перевірити версію маніфесту, що реалізована на стороні сервера відправивши OPTIONS запит на url маніфесту.
> Сервер **ПОВИНЕН** підтримувати OPTIONS запити. 
 
Приклад:

Request:
```http request
OPTIONS openapi/{manifest-name}/v{major-version}
User-Agent: {Generator-Name}/{Generator-Version} {Manifest-Title}/{Manifest-Version}
```

Response
```http
HTTP/1.1 200 OK
Server: {Generator-Name}/{Generator-Version} {Manifest-Title}/{Manifest-Version}
```

## 7 Рейт ліміти

*Правило*

> Сервер, у якого є рейт ліміти, ПОВИНЕН повертати з **кожною** відповіддю наступні три заголовки:
> 
| Header Name           | 	Description                                                |
|-----------------------|-------------------------------------------------------------|
| X-Ratelimit-Limit     | 	Дозволена кількість запитів в годину                       |
| X-Ratelimit-Remaining | Кількість запитів що залишилась в поточному лімітному вікні |
| X-Ratelimit-Reset     | Таймстамп в UNIX коли лімітне вікно обновиться              |

Приклад:

```bash
$ curl -I https://api.serivce.com/openapi/shop/v1/users
> HTTP/2 200
> Date: Mon, 01 Jul 2013 17:27:06 GMT
> X-Ratelimit-Limit: 60
> X-Ratelimit-Remaining: 56
> X-Ratelimit-Reset: 1372700873
```

*Правило*
> Якщо використовувася [умовний запит](#114-умовні-запити) і повернувся код 304 Not Modified, то цей запит не 
> враховується в рейт лімітах.

*Правило*

> Якщо рейт ліміти закінчились у лімітному вікні, то сервер ПОВИНЕН повернути 429 код відповіді.

```bash
$ curl -I https://api.serivce.com/openapi/shop/v1/users
> HTTP/2 429
> Date: Mon, 01 Jul 2013 17:27:06 GMT
> X-Ratelimit-Limit: 60
> X-Ratelimit-Remaining: 0
> X-Ratelimit-Reset: 1372700873
```

### 7.1 Вказання рейт лімітів по-замовчуванню в маніфесті

*Правило*

> Рейт ліміти вказуються через [*кастомні атрибути*](https://swagger.io/docs/specification/openapi-extensions/). Ми можемо
> вказати рейт-ліміти для окремої операції (ендпоінту):
>
> ```yaml
> paths:
>   /users/{id}:
>     x-ratelimit-limit: 100 # Кількість запитів доступних для лімітного вікна
>     x-ratelimit-window: 60 sec # Час життя лімітного вікна
>     responses:
>       # ...
> ```
> 
> Або для усіх едпоінтів одночасно в секції info:
> 
> ```yaml
> info:
>   title: ...
>   version: ...
>   x-ratelimit-limit: 100
>   x-ratelimit-window: 60 sec
> ```
>
> Рейт ліміти, що вказані для окремої операції мають вищий приорітет та перевизначають ліміти, що вказані у секції info.

## 8 Tracing

Для того, щоб можна було відстежувати джерело запитів, а також переглядати пов'язанні з запитом логи, кожен запит може
містити унікально згенероване значення за допомогою якого можна відстежувати цикл життя запиту.

*Правило*
> API повинно відправляти заголовок `X-Lifecycle-Token` з кожним запитом, в якому повинен міститись унікально 
> згенерований рядок.

## 9 Обробка помилок

### 9.1 Значення статус коду

Статус код визначає лише успішність виконання поточної http операції (хоча й результат операції може описувати
попередні операції). Добре ци видно на прикладі з асинхроними задачами.

Припустимо, що ми хочемо створити нову статтю. У нашого Api стаття характеризується полями: title, description та
author. Серед яких title та author - обов'язкові. Зазвичай створення нової статті - це синхроний процес, але в
деяких випадках система буває перенавантаженою, та відкладає створення нових ресурсів у чергу.

Розглянемо варіант створення статті, при якому відбувається помилка: в запиті відсутнє обов'язкове поле author, для
двох випадків:

**1. Синхронне створення**

Запит

```http request
POST /articles
Content-Type: application/json

{
  "title": "Hello, world!"
}
```

Оскільки POST операцію (тобто створення) не вдалось виконати, то у відповідь повернеться код помилки 400 Bad Request
(чому він можна глянути [*тут*](https://stackoverflow.com/questions/3290182/which-status-code-should-i-use-for-failed-validations-or-invalid-duplicates))
та деякий об'єкт що описує помилку (поки не будемо вдаватись в формат об'єкту).

**2. Асинхронне створення**

Візьмемо запит з попереднього пункту, та допустимо, що операція створення відклалась в чергу через перенавантаження
системи. В такому випадку у відповіді повернеться 202 Accepted код, який сигналізує що запит прийнято, але ще не
опрацьовано, а також посилання на ресурс задачі, через який можна відслітковувати стан виконання операції.

```http
HTTP/1.1 202 Accepted 
Location: /articles/tasks/1
```

Після чого ми відправляємо запит на отримання стану виконання операції:

```http request
GET /articles/tasks/1
```

Якщо задачу, ще не завершено, та get запит відпрацював успішно, то у відповідь ми разом із станом задачі отримаємо код
200 OK. Вже на цьому етапі варто зазначити, що хоч і операція виконується асинхроно код на GET запит повертається 200, а
не 202. Тому що цей код визначає саме успішність **операції по отриманню** ресурсу `/articles/tasks/1`, який вже
описує стан минулого запиту (POST /articles).

Так само, після того, як до створення статті дійте черга та валідатор помітить, що поле `autor` відсутнє, то ми у
відповідь на `GET /articles/tasks/1` отримаємо 200 код, а не 400, а в тілі відповіді буде об'єкт з описом помилки
(звісно при умові, що сам GET запит відпрацював успішно, тобто не виникло ніяких проблем з мережею і т.п.).

### 9.2 Формат опису помилки

*Правило*

> Для опису помилки **ПОВИНЕН** використовуватись медіа тип 
> [application/vnd.rollun-error+json](#43-applicationvndrollun-errorjson)

### 9.3 Попередження

Випадки в яких може повертатись попередження:
- *Виникли помилки, що не завадили виконанню операції* (наприклад при створенні замовлення клієнту не змогло
  відправитись оповіщення по email).
- *Клієнт не дотримується рекомендацій по використанню API* (наприклад не передає в запиті поле, що не обов'язкове, але
  рекомендоване)

### 9.4 Стандартні типи помилок

#### 9.4.1 InputValidationProblem

- **Status code**: 400 Bad Request
- **Title**: Validation problem
- **Description**: Вхідне повідомлення не пройшло валідацію. Деталі описані у полі `context.issues`.

Запит

```http request
GET /suppliers/not-exist/orders
```

Відповідь

```http
HTTP/1.1 400 Bad Request
Content-Type: application/rollun.problem+json
```

```json
{
  "problem": {
    "type": "https://rollun.org/docs/openapi/problems/input-validation-problem",
    "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
    "status": 400,
    "title": "Validation error",
    "detail": "There is no supplier with name 'not exitst'",
    "issues": [
      {
        "type": "https://rollun.org/docs/openapi/problems/input-validation-problem/schemaViolation",
        "in": "path",
        "name": "supplier",
        "detail": "Supplier 'not-exist' is not in enum"
      }
    ]
  }
}
```

#### 9.4.2 Missing Permission

- **Status code**: 403 Forbidden
- **Title**: Missing Permission
- **Description**: Клієнт не має дозволу на запуск цієї операції.

Запит

```http request
PUT /parts-unlimited/orders
Authorization: Bearer ds4d2f13sdds2q13qxcgbdf245
```

Відповідь

```
HTTP/1.1 403 Forbidden
Content-Type: application/problem+json
```

```json
{
  "problem": {
     "type": "https://rollun.org/docs/openapi/problems/missing-permission",
     "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
     "status": 403,
     "title": "Missing Permission",
     "detail": "Not permitted to update the order of this supplier"
  }
}
```

#### 9.4.3 Resource Not Found

- **Status code**: 404 Not Found
- **Title**: Resource Not Found
- **Description**: Сервер не знайшов ресурс, або не бажає розкривати клієнту його існування. Ця помилка не вказує на
  те чи ресурс тимчасово не доступний, чи його не існує взагалі (код 410 в приорітеті, якщо сервер точно знає, що
  відсутність ресурсу постійна). В полі `details` міститься детальніша інформація чому ресурс не знайдено.

Запит

```http request
GET /parts-unlimited/orders/123
```

Відповідь

```http
HTTP/1.1 404 Not Found
Content-Type: application/problem+json
```

```json
{
  "problem": {
     "type": "https://rollun.org/docs/openapi/problems/resource-not-found", 
     "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
     "status": 404,
     "title": "Resource Not Found",
     "detail": "The order with number '123' never existed or has been deleted."
  }
}
```

#### 9.4.4 Too Many Requests

- **Status code**: 429 Too Many Requests
- **Title**: The request limit has been reached
- **Description**: Клієнт вичерпав ліміт запитів в поточному лімітному вікні.

Запит

```http request
GET /parts-unlimited/orders/123
```

Відповідь

```http
HTTP/1.1 429 Too Many Requests
Content-Type: application/problem+json
x-ratelimit-limit: 60
x-ratelimit-remaining: 0
x-ratelimit-reset: 1372700873
```

```json
{
  "problem": {
     "type": "https://rollun.org/docs/openapi/problems/too-many-requests",
     "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
     "status": 429,
     "title": "The request limit has been reached",
     "detail": "No more requests accepted before 2013-07-01T17:47:53.000Z"
  }
}
```

#### 9.4.5 Internal Server Error

- **Status code**: 500 Internal Server Error
- **Title**: Internal Server Error
- **Description**: Сервер зіштовхнувся с помилкою, яку не знає як обробляти.

Запит

```http request
GET /parts-unlimited/orders/123
```

Відповідь

```http
HTTP/1.1 500 Internal Server Error
Content-Type: application/problem+json
```

```json
{
  "problem": {
     "type": "https://rollun.org/docs/openapi/problems/internal-server-error",
     "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
     "status": 500,
     "title": "Internal Server Error",
     "detail": "Null pointer exception while executing 'Order::create'."
  }
}
```

#### 9.4.6 Bad Gateway

- **Status code**: 502 Bad Gateway
- **Title**: Bad Gateway
- **Description**: Сервер, діючи як шлюз (gateway) або проксі некоректну відповідь (або яку не знає як обробляти) від
  висхідного сервера. На мій полгяд є сенс використовувати цей код у всіх ситаціях (якщо немає очевидно кращого коду),
  коли сервер не може виконати запит, через те що отримав некоректну відповідь від іншого сервера. Але це не стосується
  ситуацій, коли сервер отримав цілком легальну помилку від іншого сервера, яку знає як обробляти (Наприклад висхідний
  сервер, що відправляє електроні листи повернув помилку, що заданого email не існує).

Запит

```http request
GET /autodist/orders/123
```

Відповідь

```http
HTTP/1.1 502 Bad Gateway
Content-Type: application/problem+json
Retry-After: 120
```

```json
{
  "problem": {
     "type": "https://rollun.org/docs/openapi/problems/bad-gateway",
     "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
     "status": 502,
     "title": "Bad Gateway",
     "detail": "Cannot fulfill request because autodist api returned 500 Internal Server Error"
  }
}
```

#### 9.4.6 Service Unavailable

- **Status code**: 503 Service Unavailable
- **Title**: Internal Server Error
- **Description**: Сервер тимчасово не доступний, або не може виконати операцію через недоступність серверів від
  яких він залежить. Якщо відоммо час, коли сервер відновить роботу, то він повинен бути зазначенний у хедері
  Retry-After

Запит

```http request
GET /autodist/orders/123
```

Відповідь

```http
HTTP/1.1 503 Service Unavailable
Content-Type: application/problem+json
Retry-After: 120
```

```json
{
  "problem": {
     "type": "https://rollun.org/docs/openapi/problems/service-unavailable",
     "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
     "status": 503,
     "title": "Service Unavailable",
     "detail": "Autodist api is temporarily unavailable. Please try again after 120 seconds."
  }
}
```
#### 9.4.7 Gateway Timeout

- **Status code**: 504 Gateway Timeout
- **Title**: Gateway Timeout
- **Description**: Сервер, діючи як шлюз (gateway) або проксі не дочекався відповіді від висхідного серверу
  Запит

```http request
GET /autodist/orders/123
```

Відповідь

```http
HTTP/1.1 504 Gateway Timeout
Content-Type: application/problem+json
Retry-After: 120
```

```json
{
  "problem": {
    "type": "https://rollun.org/docs/openapi/problems/gateway-timeout",
    "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
    "status": 504,
    "title": "Gateway Timeout",
    "detail": "Cannot fulfill request because autodist api request is timeout"
  }
}  
```

### 9.5 Помилки, що не мають http відповіді

Деякі помилки виникають через те що сервер або не зміг відправити запит, або не отримав ніякої відповіді. Для таких
випадків немає http кодів (адже вони застосовуються у відповіді якої в даних ситуація просто немає), так само як
і немає сенсу описувати тіло відповіді, якої немає. Ці випадки клієнт сам повинен коректно визначати та обробляти.

Перелік таких помилок:
- Request Timeout
- DNS errors
- Connection errors

## 10 Long tasks

*Правило*

> При виконанні будь-якого http запит у відповідь може повернутись 202 код. Це означає, що сервер прийняв запит в
> обробку, але поки ще не виконав (відклав його у чергу). В результаті запит може як виконатись, так і ні. Представлення
> при цьому коді містить опис поточного стану виконання запиту, а також вказівник на ресурс (далі задача), що надає
> користувачеві оцінку того, коли запит буде виконаний.
>
> У відповіді з 202 статусом медіа тип **ПОВИНЕН** бути [application/vnd.rollun-long-task+json](#47-applicationvndrollun-long-taskjson).
> Також може бути присутній заголовок Retry-After з естімейтом виконання задачі.
> 
> При отриманні (GET) ресурсу задачі відповіді можуть бути наступні:
> - Задача в обробці (status = pending): статус 200 OK і представлення ресурсу зі станом задачі (медіа тип 
> application/vnd.rollun-long-task+json)
> - Успіх (status = fulfilled): статус 303 See Other з заголовком Location, який містить посилання (URL) на результат 
> задачі.
> - Помилка (status = rejected): статус 200 OK з представленням ресурсу зі станом задачі, який також містить причину 
> помилки

**Початок асинхроного запиту**

Request
```http request
POST /articles
Accept: application/vnd.rollun+json, application/vnd.rollun-error+json, application/vnd.rollun-long-task+json
Content-Type: application/vnd.rollun-request+json

{
  "payload": {
    "idempotencyKey": "abc",
    "title": "My article!"
  }
}
```

Response
```http
HTTP/1.1 202 Accepted
Location: http://www.example.org/articles/actions/creating/123
Retry-After: 30
Content-type: application/vnd.rollun-long-task+json

{
  "task": {
    "id": "123",
    "status": "pending",
    "idempotencyKey": "abc",
    "stage": "step-0"
  }
}
```

**Отримання стану задачі**

Request
```http request
GET /articles/actions/creating/123
Accept: application/vnd.rollun-error+json, application/vnd.rollun-long-task+json
```

Response
```http
HTTP/1.1 200 Ok
Content-type: application/vnd.rollun-long-task+json
Retry-After: 10

{
  "task": {
    "id": "123",
    "status": "pending",
    "idempotencyKey": "abc",
    "stage": "step-1",
  }
}
```

**Якщо виконання успішно закінчилось**

У відповідь ми отримуємо 303 статус, з редіректом на результат задачі. Також результат міститься у полі "task.data", 
але, зазвичай, тільки його ідентифікатор.

Request
```http request
GET /articles/actions/creating/123
Accept: application/vnd.rollun-error+json, application/vnd.rollun-long-task+json
```

Response
```http
HTTP/1.1 303 See Other
Location: http://www.example.org/articles/1
Content-type: application/vnd.rollun-long-task+json

{
  "task": {
    "id": "123",
    "status": "fulfilled",
    "idempotencyKey": "abc",
    "stage": "done",
    "completed":"2018-09-13T02:10:00Z",
    "data": {
      "id": "1"
    }
  }
}
```

Request

```http request
GET http://www.example.org/articles/1
Accept: application/vnd.rollun+json, application/vnd.rollun-error+json
```

Response

```http
HTTP/1.1 200 OK
Content-type: application/vnd.rollun+json

{
  "data": {
    "id": 1,
    "idempotencyKey": "abc",
    "title": "My article!"
  }
}
```

**Якщо виконання закінчилось помилкою**, то повертається код **200**, а тіло відповіді буде описувати помилку.

Детальніше про те чому код саме 200 в розділі про [обробку помилок](#91-значення-статус-коду)

Request
```http request
GET /articles/actions/creating/123
Accept: application/vnd.rollun+json, application/vnd.rollun-error+json, application/vnd.rollun-long-task+json
```

Response

```http
HTTP/1.1 200 Ok
Content-Type: application/vnd.rollun-long-task+json
```

```json
{
  "task": {
    "id": "123",
    "status": "rejected",
    "idempotencyKey": "abc",
    "stage": "step-01",
    "completed":"2018-09-13T02:10:00Z",
    "problem": {
      "type": "https://rollun.org/docs/openapi/problems/internal-server-error",
      "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
      "status": 500,
      "title": "Internal Server Error",
      "detail": "Null pointer exception while executing 'Article::create'."
    }
  }
}
```

## 11 Кешування

Продуктивність веб-сайтів та програм можна значно підвищити за рахунок повторного використання раніше отриманих 
ресурсів. Веб-кеші скорочують затримку та знижують мережевий трафік, зменшуючи тим самим час, необхідний для 
виконання запиту.

*Правило*

> Http кешування **СЛІД** застосовувати для ресурсів, що часто запитуються клієнтами

### 11.1 Різні види кешу

Техніка кешування полягає у збереженні копії отриманого ресурсу для повернення цієї копії у відповідь на подальші 
запити. Запит на ресурс, що вже є у веб-кеші, перехоплюється і замість звернення до вихідного сервера виконується 
завантаження копії з кеша. Таким чином, знижується навантаження на сервер, якому не доводиться самому обслуговувати 
всіх клієнтів, і підвищується продуктивність — кеш ближче до клієнта і ресурс передається швидше. Кешування є основним 
джерелом підвищення продуктивності веб api. Проте, кеш треба правильно налаштувати: ресурси рідко залишаються 
незмінними, отже копію потрібно зберігати лише доти, як ресурс змінився, але не довше.

Існує кілька видів кешів, які можна поділити на дві основні категорії: приватні кеші та кеші спільного використання. 
У кешах спільного використання (shared cache) зберігаються копії, які можуть надсилатися різним користувачам. Приватний 
кеш призначений для окремого користувача. Тут буде говорити в основному про кеші браузерів та проксі, але існують також 
кеші шлюзів, CDN, реверсні проксі кеші та балансувальники навантаження, що розгортаються на серверах для підвищення 
надійності, продуктивності та масштабованості веб-сайтів та веб-додатків.

#### 11.1.1 Приватний кеш

Приватний кеш призначений для окремого клієнта. Ви, можливо, вже бачили параметри кешування у налаштуваннях свого 
браузера. Кеш браузера містить усі документи, завантажені користувачем HTTP. Він використовується для доступу до раніше 
завантажених сторінок під час навігації назад/вперед, дозволяє зберігати сторінки або переглядати їх код, не звертаючись
зайвий раз до сервера. Крім того, такий кеш корисний при відключенні від мережі.

#### 11.1.2 Спільний кеш

Кеш спільного використання - це кеш, який зберігає відповіді, щоб їх потім могли використовувати різні користувачі. 
Наприклад, у локальній мережі вашого провайдера або компанії може бути встановлений проксі, який обслуговує безліч 
користувачів, щоб можна було повторно використовувати популярні ресурси, скорочуючи тим самим мережевий трафік і час 
очікування.

### 11.2 Цілі кешування

Кешування в HTTP не є обов'язковим, проте в більшості випадків корисно повторно використовувати раніше збережені 
ресурси. Тим не менш, стандартні кеші HTTP зазвичай здатні кешувати лише відповіді на запити методом [`GET`](#22-get), 
інші відхиляють.

Первинний ключ складається з методу запиту та запитуваного URI (часто використовується лише URI, оскільки метою 
кешування є лише [`GET`](#22-get)-запити). Ось приклади того, що зазвичай записується в кеш:

- Успішно завантажені ресурси: відповідь `200 OK` на запит методом [`GET`](#22-get) HTML-документів, зображень чи файлів.
- Постійні перенаправлення: відповідь `301 Moved Permanently` (переміщено назавжди).
- Повідомлення про помилки: відповідь `404 Not Found` (не знайдено).
- Неповні результати: відповідь `206 Partial Content` (частковий вміст).
- Відповіді на запити відмінні від [`GET`](#22-get), якщо є щось, що підходить для використання як ключ кеша.

*Джерело:* https://developer.mozilla.org/ru/docs/Web/HTTP/Caching

### 11.3 Управління кешом

#### 11.3.1 Заголовок Cache-control

Поле Cache-Control загального заголовка HTTP/1.1 використовується для завдання інструкцій з механізму кешування як у 
запитах, так і у відповіді. Застосовується для завдання політик кешування.

#### 11.3.2 Повна відсутність кешування
У кеші не повинно зберігатися нічого – ні за запитами клієнта, ні за відповідями сервера. Запит завжди надсилається на 
сервер, відповідь завжди завантажується повністю.

```
Cache-Control: no-store
```

#### 11.3.3 Кешувати, але перевіряти актуальність
Перед тим, як віддати копію, кеш запитує вихідний сервер щодо актуальності ресурсу.

```
Cache-Control: no-cache
```

#### 11.3.4 Приватні (private) та спільні (public) кеші
Директива "public" вказує, що відповідь можна зберігати у будь-якому кеші. Це буває корисно, якщо виникає потреба 
зберегти сторінки з автентифікацією HTTP, або такими кодами відповіді, які зазвичай не кешуються. Директива "private" 
вказує, що відповідь призначена окремому користувачеві і не повинна зберігатися в кеші спільного використання. У цьому 
випадку відповідь може зберігатись приватним кешем клієнта.

```
Cache-Control: private
Cache-Control: public
```

#### 11.3.5 Термін дії (Expiration)
Найважливішою тут є директива "max-age=<seconds>" - максимальний час, протягом якого ресурс вважається "свіжим". 
На відміну від директиви `Expires` вона прив'язана до моменту запиту.

```
Cache-Control: max-age=31536000
```

#### 11.3.6 Перевірка актуальності
При використанні директиви "must-revalidate" кеш зобов'язаний перевіряти статус ресурсів зі строком дії, що минув. 
Ті копії, що втратили актуальність, не повинні використовуватися. 

Докладніше про це можна почитати [тут](https://developer.mozilla.org/ru/docs/Web/HTTP/Caching#%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%B5%D1%88%D0%B0).

```
Cache-Control: must-revalidate
```

#### 11.3.7 Дерево прийняття рішеннь

У наступній схемі показано дерево рішень для налаштування кешування для певного ресурсу:

![http cache decision tree](img/specification/cache-decision-tree.jpg)

### 11.4 Умовні запити

Умовні запити – це запити, у яких клієнт може запитати сервер, чи є у нього оновлена копія ресурсу. Клієнт надішле деяку 
інформацію про кешований ресурс, який він зберігає, і сервер визначить, чи потрібно повертати оновлений вміст, чи копія 
клієнта вже оновлена. В останньому випадку повертається статус HTTP `304 Not Modified`.

![conditional request](img/specification/conditional-request.jpg)

Хоча умовні запити дійсно викликають виклик у мережі, незмінені ресурси призводять до порожнього тіла відповіді, 
заощаджуючи витрати на передачу ресурсу назад кінцевому клієнту. Сервер також часто може дуже швидко визначити останню 
версію або дату модифікації ресурсу без доступу до ресурсу, що само по собі економить час обробки.

Є два види умовних запитів

#### 11.4.1 Time-based

Умовний запит на основі часу базується на часі останньої зміни ресурсу. Якщо час останньої модифікації кешованої копії 
все ще є останнім, сервер повертає код відповіді 304. Щоб використовувати умовні запити на основі часу, сервер вказує 
час останньої зміни ресурсу через заголовок відповіді Last-Modified.

```
Last-Modified: Mon, 03 Jan 2011 17:45:57 GMT
```

Наступного разу, коли клієнт запитує цей ресурс, він запитуватиме лише вміст ресурсу, якщо той не змінився з цієї дати. 
Для цього використовується заголовок запиту If-Modified-Since

```
If-Modified-Since: Mon, 03 Jan 2011 17:45:57 GMT
```

Якщо ресурс не змінився з понеділка, 3 січня 2011 р., 17:45:57 GMT, сервер повернеться з порожнім тілом із кодом 
відповіді 304.

*Првило*

> Заголовок Last-Modified не підтримує досекундну точність, що може призвести до неправильних звернень до кешу, якщо є
> два оновлення протягом секунди.
>
> Через це **СЛІД** надавати перевагу ETag над заголовком Last-Modified.

#### 11.4.2 Content-based

ETag (або Entity Tag) працює подібно до заголовка Last-Modified, за винятком того, що його значення є тегом довільної 
форми, що ідентифікує версію ресурсу. Дійсні ETags можуть бути хешем MD5, номером версії або міткою часу модифікації, 
що забезпечує більшу точність, ніж при використанні заголовка Last-Modified.

Серовер разом з відповіддю надсилає тег останньої версії ресурсу.
```
ETag: "15f0fff99ed5aae4edffdd6496d7131f"
```

У наступних запитах клієнта заголовок запиту If-None-Match надсилається зі значенням ETag останньої запитуваної версії 
ресурсу.

```
If-None-Match: "15f0fff99ed5aae4edffdd6496d7131f"
```

Як і у випадку з заголовком If-Modified-Since, якщо поточна версія має те саме значення ETag, що й кешована копія 
клієнта, тоді повертається статус HTTP 304.

## 12 Запобігання колізій при редагуванні ресурсу 

При роботі застосунку може відбутись таке, коли два процесса паралельно спробують модифікувати один і той самий ресурс.
Якщо при цьому використовується PUT запит, то один запит затре зміни іншого запиту. Для того, щоб цього забігти можна 
використовувати умовні запити з заголовками `Etag` та `If-Match`.

Для цього при отриманні ресурсу разом з ним повинен приходити заголовок Etag.

```http request
GET https://api.serivce.com/openapi/shop/v1/users/1
```

```http
HTTP/2 200
Etag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

Після чого, при редагуванні ресурсу, клієнт повинен передати отриманний в попередньому запиті Etag в заголовку
`If-Match`

```http request
PUT https://api.serivce.com/openapi/shop/v1/users/1
If-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

Сервер своєю чергою перевірить, якщо відправлений Etag збігається з тим, що зараз зберігається на сервері, то виконає
запит, а інакше поверне помилку `412 Precondition Failed`.