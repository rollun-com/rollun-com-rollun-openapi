# Rollun REST API specification

## 1. Визначення REST архітектури

## 1.1 Починаємо з Null стилю

Філдинг (автор REST архітектури) виділяє два підходи до проєктування архітектури. Перший - це коли архітектор починає
з чистого листа і створює архітектуру зі знайомих компонентів доти, доки вона не задовольнить усі вимоги до системи.
Другий - це коли архітектор починає з потреб системи в цілому, без обмежень, та потім поступово визначає та застосовує
обмеження до елементів системи. REST було розроблено з використанням другого підходу, тому він складається з набору
обмежень, які повинно дотримуватись API, щоб називатись REST API.

## 1.2 Клієнт-серверна архітектура

Першим обмеженням є приведення архітектури до моделі клієнт-сервер. Ця модель детальніше описана в [главі 3.4.1](https://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm#sec_3_4_1)
дисертації Роя Філдинга. 

## 1.3 Відсутність стану

Друге обмеження додається до моделі клієнт-сервер: взаємодія повинна бути без стану. Тобто кожен запит від клієнта
до сервера повинен містити усю, необхідну для розуміння запиту, інформацію і не може використовувати будь-який
збережений на сервері контекст. Стан сеансу повністю зберігається на клієнті.

## 1.4 Кешування

Обмеження на кешування вимагає, щоб дані у відповідь на запит були явно, або неявно, позначені як такі, що кешуються,
або такі що не кешуються. Якщо відповідь кешується, то клієнт отримує право повторно використати дані з кешу для 
еквівалентних запитів.

## 1.5 Однорідний (уніфікований) інтерфейс

Головною особливістю, яка відрізняє архітектурний стиль REST від інших мережевих стилів, є акцент на уніфікованому
інтерфейсі між компонентами. 

До уніфікованих інтерфейсів застосовуються чотири обмеження:

**Ідентифікація ресурсів**

Ключовою абстракцією інформації в REST є *ресурс*. Ресурсом може бути будь-яка інформація, яку можна назвати: документ 
або зображення, тимчасовий сервіс (наприклад, «сьогоднішня погода у Львові»), набір інших ресурсів, невіртуальний об’єкт
(наприклад, людина) тощо.. Іншими словами, будь-яка концепція, яка може бути ціллю гіпертекстового посилання автора, 
повинна відповідати визначенню ресурсу.

**Маніпуляція ресурсами через представлення**

**Самоописові повідомлення**

**Гіпермедіа як рушій стану застосунку**

## 2. Http

Протокол http спроектований згідно вимог до REST архітектури і ми використовуємо його для того, щоб будувати наші REST 
API.

### 2.1 Ідемпотентність

Ідемпотентність - це властивість операції, коли результат виконання декількох однакових запитів призводить до того 
самого стану серверу, що й виклик одного запиту. Іншими словами ідемпотентна операція не має ніяких побічних ефектів, 
окрім сбору статистики та подібних операцій. 

Важливо зазначити, що ідемпотентність стосується лише стану серверу, фактичні відповіді на запити можуть бути різними.
Наприклад метод DELETE, який є ідемпотентним, може перший раз повернути код 200 OK, а наступні рази повертати код 
404 Not found.

Згідно специфікації http ідемпотентними є методи: `GET`, `HEAD`, `PUT`, `DELETE`. Але ми розширюємо цей список вносячи
наступне правило:

*Правило*

> **Метод POST повинен бути ідемпотентним.** Зробити POST метод ідемпотентним можна додаючи ключ ідемпотентності в 
> тіло запиту. При цьому сервер повинен відстежувати, щоб запити з однаковим ключем ідемпотентності не виконувались
> повторно.

*Приклад*

Перший запит: 

```http request
POST /articles
Content-Type: application/vnd.rollun-request+json

{
  "payload": {
    "idempotencyKey": "12345",
    "title": "My article",
    "content": "My first article!"
  }
}
```

Відповідь:

```http
HTTP/1.1 201 Created
Location: /articles/qwerty
Content-type: application/vnd.rollun+json

{
  "task": {
    "id": "qwerty",
    "idempotencyKey": "12345",
    "title": "My article",
    "content": "My first article!"
  }
}
```

Повторний, ідентичний запит:

```http request
POST /articles
Content-Type: application/vnd.rollun-request+json

{
  "payload": {
    "idempotencyKey": "12345",
    "title": "My article",
    "content": "My first article!"
  }
}
```

Відповідь:

```http
HTTP/1.1 200 OK
Location: /articles/qwerty
Content-type: application/vnd.rollun+json

{
  "task": {
    "id": "qwerty",
    "idempotencyKey": "12345",
    "title": "My article",
    "content": "My first article!"
  }
}
```

Як видно, повторний запит не привів до повторного створення статті, а повернулась уже створенна стаття.

Нижче розглянемо декілька сценаріїв роботи з ідемпотентною POST операцією.

**Сценарій 1**

1. Клієнт надсилає POST запит на створення ресурсу
2. Сервер успішно виконує запит
3. Клієнт не отримує відповідь через проблеми з мережею
4. Клієнт надсилає повторний ідентичний запит

*Результат:*

Клієнт отримує відповідь таку саму як на кроці 2. Ресурс створюється один раз на кроці 2.

**Сценарій 2**

1. Клієнт надсилає POST запит на створення ресурсу
2. Сервер відповідає з 500 кодом помилки
3. Клієнт не отримує відповідь через проблеми з мережею
4. Клієнт надсилає повторний ідентичний запит

*Результат:*

Результат не може буде визначенним. Повторний запит на кроці 4 може привести до створення дубліката ресурсу. Якщо 
клієнт все ж отримав відповідь на кроці 3, то рекомендується не відправляти повторний запит до з'ясування причин 
помилки.

**Сценарій 3**

1. Клієнт надсилає POST запит на створення ресурсу без хедера авторизації
2. Сервер відповідає з 403 кодом помилки
3. Клієнт отримує відповідь і надсилає повторний ідентичний запит, але з хедером авторизації
4. Сервер успішно оброблює запит і повертає 200 ОК відповідь

*Результат:*

Сервер створить ресурс на кроці 3. Крок 2 ніяк не вплине на створення ресурсу. Клієнт може безпечно надсилати запити з 
кроку 1 і отримувати відповідь як на кроці 2.

**Сценарій 4**

1. Клієнт надсилає POST запит на створення ресурсу
2. Сервер відповідає з 503 Service Unavailable кодом помилки
3. Клієнт отримує відповідь і планує повторний запит
4. Сервер повертається в робочий стан
5. Клієнт надсилає повторний запит з ідентичним ключем ідемпотентності
6. Сервер успішно виконує запит і повертає 200 ОК відповідь

*Результат:*

Сервер оброблює запит на кроці 6. Поки сервер знаходиться в Unavailable стані клієнт може беспечно надсилати запити з 
кроку 1 та отримувати відповідь з кроку 2. В кінці кінців відбудеться крок номер 5 та 6.

**Сценарій 5**

1. Клієнт надсилає POST запит на створення ресурсу
2. Сервер отримує запит та успішно його оброблює
3. Клієнт не отримує відповідь через проблеми з мережею
4. Клієнт надсилає повторний запит, але зі зміниними деякими параметрами (але ключ ідемпотентності той самий)

*Результат:*

Сервер надсилає 409 Conflict відповідь з поясненям помилки в тілі відповіді.

**Сценарій 6**

1. Клієнт надсилає POST запит на створення ресурсу
2. Сервер отримує запит та відповідає з 400 кодом помилки
3. Клієнт отримує відповідь і надсилає ідентичний запит
4. Сервер отримує запит

*Результат:*

Сервер повинен надіслати відповідь з кроку 2. При цьому якщо клієнт на кроці 3 змінить деякі параметри запиту, то це 
приведе до сценарію 5.

**Сценарій 7**

1. Клієнт надсилає POST запит на створення ресурсу
2. Север отримує запит та починає його виконання
3. Не чекаючи завершення виконання першого запита клієнт надсилає другий запит ідентичний першому
4. Сервер отримує другий запит до завершення виконання першого запиту

*Результат:*

Сервер виконує запит один раз у відповідь на запит відправлений у кроці 1. У відповідь на запит, відправлений у кроці 
2 повертається помилка 409 Conflict з поясненям помилки в тілі відповіді.

### 2.2 GET 

**GET необхідно використовувати для отримання представлення ресурсу або запуску виконання безпечного екшену.** Це метод 
лише для читання, який ніколи не повинен змінювати стан ресурсу.

### 2.3 HEAD 

**HEAD слід використовувати лише для отримання заголовків HTTP відповіді.** HEAD повертає ту саму відповідь, що й GET, 
за винятком того, що API повертає порожнє тіло. Це строго лише для читання.

### 2.4 POST

**POST необхідно використовувати для створення нового ресурсу в колекції або для запуску виконання екшену.**

Під час використання для створення ресурсу тіло запиту POST містить запропоноване представлення стану нового ресурсу, 
який буде додано до колекції, що належить серверу. Відповідь має містити HTTP-заголовок `Location`, що містить URI щойно 
створеного ресурсу, тоді як тіло містить його (часткове чи повне) представлення або може бути порожнє.

### 2.5 PUT

**PUT потрібно використовувати для оновлення збереженого ресурсу під URI, наданим клієнтом.** Його можна використовувати 
для вставки нового ресурсу, якщо створення ідентифікатора покладено на клієнта.

Якщо URI посилається на вже існуючий ресурс, вкладену сутність СЛІД вважати новою версією, яка замінить ту, що 
знаходиться на сервері. Якщо цільовий ресурс успішно змінено відповідно до стану вкладеного представлення, тоді СЛІД 
надіслати відповідь `200 OK`, щоб вказати успішне завершення запиту.

Якщо URI не вказує на існуючий ресурс, і цей URI можна визначити як новий ресурс, сервер може створити ресурс із цим 
URI. Сервер **ПОВИНЕН** повідомити клієнта, надіславши відповідь `201 Created`, щоб вказати на успішне створення.

Операції PUT можуть мати побічні ефекти (тобто змінювати стан), але ПОВИННІ бути ідемпотентними.

### 2.6 PATCH

PATCH необхідно використовувати для часткового оновлення представлення ресурсу.

Включена сутність містить набір інструкцій, що описують, як ресурс, який зараз знаходиться на початковому сервері, має
бути змінений для створення нової версії. Метод PATCH впливає на ресурс, визначений Request-URI, і він також МОЖЕ мати
побічні ефекти на інші ресурси; тобто нові ресурси можуть бути створені або існуючі модифіковані шляхом застосування 
PATCH. Операції PATCH не обов’язково повинні бути ідемпотентними.

#### 2.6.1 PATCH vs PUT

Різниця між запитами PUT і PATCH відображається в тому, як сервер обробляє об’єкт, щоб змінити ресурс,
ідентифікований за допомогою Request-URI. PUT запит містить об’єкт, що вважається модифікованою версією ресурсу,
який зберігається на сервері, і клієнт просить замінити збережену версію. В PATCH вкладений об’єкт
містить набір інструкцій, що описують, як ресурс, який зараз знаходиться на вихідному сервері, повинен бути змінений
для створення нової версії. Метод PATCH МОЖЕ мати побічні ефекти на інші ресурси; тобто нові ресурси можуть бути
створені або можуть бути змінені існуючі за допомогою застосування виправлення.

PATCH МОЖЕ створити новий ресурс залежно від типу patch документу.

PATCH описує набір змін в «patch документі», що визначається за допомогою media-type в хедері Content-Type. Хоча явно ніде не написано, але
в загальному випадку application/json - не являється patch документом. Адже сервер ніяк не зможе зрозуміти яким чином
йому змінювати ресурс.

Patch документ зазвичай може приймати одну з двох форм:

- **Містити чіткий опис змін.** Приклад [json-patch](https://datatracker.ietf.org/doc/html/rfc6902/).

The original document
```json
{
  "title": "hello, world!",
  "author": "John",
  "tags": ["example"],
  "content": "My article."
}
```

The patch

1. Замінити значення title на "First article!"
2. Додати значення "sample" до масиву tags.
3. Видалити поле author

```http request
Content-Type: application/json-patch+json

[
  { "op": "replace", "path": "/title", "value": "First article!" },
  { "op": "add", "path": "/tags", "value": ["sample"] },
  { "op": "remove", "path": "/author" }
]
```

The result

```json
{
  "title": "First article!",
  "tags": ["example", "sample"],
  "content": "My article."
}
```

- **Містити модифіковану версію ресурсу і дозволити серверу самому визначити набір змін.** Приклад [json/merge-patch](https://datatracker.ietf.org/doc/html/rfc7396)

The original document
```json
{
  "title": "hello, world!",
  "author": "John",
  "tags": ["example"],
  "content": "My article."
}
```

The patch

1. Замінити значення title на "First article!"
2. Замінити значення tags на ["sample"] (саме замінити, а не додати нове значення в масив).
3. Видалити поле author

```http request
Content-Type: application/merge-patch+json
        
{
  "title": "First article!",
  "tags": ["sample"],
  "content": null
}
```

The result

```json
{
  "title": "First article!",
  "tags": ["sample"],
  "content": "My article."
}
```

Мінус json-merge-patch в тому що він не може описати нормально описати деякі операції: наприклад додавання елементу
в массив.

### 2.7 DELETE

**DELETE потрібно використовувати для видалення ресурсу**. Після обробки запиту DELETE для певного ресурсу клієнти більше 
не можуть знайти цей ресурс. Таким чином, будь-яка майбутня спроба отримати представлення стану ресурсу за допомогою 
GET або HEAD має призвести до статусу 404 («Не знайдено»), повернутого API.

## 3. Ресурси

### 3.1 URI

*Правило*
> URI **повинен бути записаний в kebab-case.**

Приклади:

```
✅ http://parts-unlimited/openapi/suppliers-orders-cache/v1

❌ http://partsUnlimited/openapi/suppliersOrdersCache/v1

❌ http://parts_unlimited/openapi/suppliers_orders_cache/v1

❌ http://parts-unlimited/openapi/SUPPLIERS_ORDERS_CACHE/v1
```

*Правило*
> Формат URL path: `/openapi/{manifest-title}/v{major-version}/{resources}`
> 
> **openapi**
>
> Обов'язковий префікс
> 
> **manifest-title**
> 
> Поле `title` з секції `info` openapi маніфесту в kebab-case.
> 
> **major-version**
> 
> Мажорна версія API (поле `version` секції `info` openapi маніфесту). Integer, що починається з одиниці.
> 
> **resources**
> 
> Повний шлях, що ідентифікує ресурс.

*Правило*
> URI **не повинен містити розширення файлу**

Замість цього розширення описується за допомогою медіа типу, який можна вказати в заголовках HTTP.

```
✅ http://parts-unlimited/openapi/suppliers-orders-cache/v1/orders

❌ http://parts-unlimited/openapi/suppliers-orders-cache/v1/orders.json
```

### 3.2 Типи ресурсів

Виділяються наступні типи ресурсів:
- Документ
- Колекція
- Action
- Датастор
- Кінцевий автомат

### 3.3 Документ

Документ - це ресурс який посилається на одну конкретну бізнес сутність або екземпляр об'єкта. Завжди json об'єкт, 
тобто не колекція, рядок і т.п.

*Правило*
> Кожен **документ повинен мати поле з ідентифікатором.** Це поле рекомендується називати `id` та його тип повинен бути
> string.

*Правило*
> Ідентифікатор ресурсу документа рекомендується **обирати з природних бізнес ідентифікаторів** ресурсу, як, наприклад, 
> ІПН людини. У разі відсутності таких ідентифікаторів можна використовувати сурогатний ключ.

Приклад:

```http request
GET /articles/AB123
```

```json
{
  "data": {
    "id": "AB123",
    "title": "My first article!",
    "status": "draft",
    "content": "No content yet."
  }
}
```

Документ частіше за все міститься в батьківській колекції та визначається ідентифікатором. Документ 
може містити дочірні колекції.

![collection](img/specification/collection.png)

Рекомендується не зловживати зв'язками в URI. Довгі цепочки залежностей, як, наприклад, `/customers/1/orders/99/products`
буде складніше обслуговувати та адаптувати у разі зміни зв'язків між ресурсами. Цей приклад URI краще розбити на коротші
та простіші URI: `/customers/1/orders` - щоб переглянути усі замовлення клієнта 1, а потім`/orders/99/products` щоб 
знайти усі товари замовлення 99.

#### 3.3.1 Часткове отримання ресурсу

*Правило*

> Query параметр `select` зарезервовано для отримання представлення ресурсу тільки з вказаними властивостями.
> 
> При цьому усі поля ресурсу в маніфесті повинні бути об'явленні як optional. Запит повинен мати select за 
> замовчуванням. 
> 
> Якщо запит не підтримує select (наприклад за ненадобності), то повинні повертатись усі поля ресурсу.
> 
> Якщо клієнт вказав у select властивості, яких немає у ресурсу, то повинен повернутися http код 400 з описом
> помилки в тілі відповіді.

Приклад:

```http request
GET /articles/AB123?select=title,status
```

```json
{
  "data": {
    "title": "My first article!",
    "status": "draft"
  }
}
```

#### 3.3.2 Оновлення ресурсу

Оновлення ресурсу можна здійснити одним із кількох способів. Для кожного ресурсу **РЕКОМЕНДУЄТЬСЯ** вибрати лише один із 
наведених нижче шаблонів, якщо це не вимушено зворотно сумісною зміною.

У порядку переваги:

1. *використовуйте PUT із повними об’єктами для оновлення ресурсу до тих пір, поки це можливо (тобто взагалі не використовуйте PATCH).*

Цей варіант є кращим, якщо клієнти, ймовірно, завжди будуть враховувати повне представлення ресурсу. Якщо клієнт ігнорує 
деякі властивості ресурсу, вони, ймовірно, не будуть представлені в PUT запиті та, таким чином, втрачені. Цей сценарій 
може статися, коли під час життєвого циклу API додано нові властивості. У цьому випадку використовувати PUT не 
рекомендується.

2. Використовуйте PATCH із частковими об’єктами, щоб оновлювати лише частину ресурсу, коли це можливо, використовуючи 
стандарт [JSON Patch](#261-patch-vs-put).

Використання patch рекомендується меншою мірою, оскільки його складніше реалізовувати.

**Повне оновлення**

Використовуйте PUT, якщо хочете виконати повне оновлення ресурсу документа. Усі значення замінюються значеннями, 
наданими клієнтом. Для відсутніх додаткових значень у запиті встановлюється значення за замовчуванням, якщо воно 
вказано в специфікації OpenAPI.

**Часткове оновлення**

Використовуйте PATCH, якщо хочете виконати часткове оновлення ресурсу документа.

Повідомлення PATCH **ПОВИННО** відповідати специфікації [JSON Patch](#261-patch-vs-put)

### 3.4 Колекція

Колекція - це список ресурсів документів.

*Правило*

> **Для назв колекцій слід використовувати іменник у множині**, як, наприклад, `employers`, `people`, `orders`.

Приклад колекції

```http request
GET /orders
```

```json
{
  "data": [
    {
      "id": "1",
      "invoice": {
        "total": 10.34,
        "currency": "USD"
      }
    },
    {
      "id": "2",
      "invoice": {
        "total": 12.26,
        "currency": "USD"
      }
    }
  ]
}
```

### 3.4.1 RQL

Фільтрування, вибірка та пагінація в колекціях здійснюється за допомогою RQL.

*Правило*

> Кожна колекція повинна підтримувати RQL. Але, за потреби, може робити це не в повному обсязі. Наприклад відмовитись
> від підтримки groupby ноди. Про це повинно бути написано в описі операції в openapi маніфесті. 
> 
> Якщо клієнт надсилає rql який не підтримується сервером, то сервер повинен відповісти кодом 501 Not Implemented з
> описом помилки в тілі відповіді.

#### 3.4.1.1 Опис RQL

Описати RQL в тому вигляді в якому його задумували не вийде, оскільки хоч в специфікації URL явно не вказано в якому 
форматі повинна бути query частина, тобто це може бути будь-який рядок. Але в openapi специфікації query обов'язково 
повинно бути у форматі ключ=значення. Тому хоч з точки зору URL запис mydomain.com?eq(id,1) коректний, але в openapi 
маніфесті його ніяк не опишеш. Детальніше: [issue #1502](https://github.com/OAI/OpenAPI-Specification/issues/1502).

Для розв'язання цієї проблеми ми розділили RQL на декілька логічних частин, щоб його можна було записати в форматі 
ключ-значення.

Опис усіх ключів RQL в openapi маніфесті:

```yaml
"/resources":
    get:
      parameters:
        - name: query
          in: query
          required: false
          schema:
            type: string
            example: 'and(eq(field1,value1),eq(field2,value2))'
        - name: limit
          in: query
          required: false
          schema:
            type: integer
            default: 20
            example: 20
        - name: offset
          in: query
          required: false
          schema:
            type: integer
            default: 0
            example: 0
        - name: sort
          in: query
          required: false
          schema:
            type: string
            example: -field1
        - name: select
          in: query
          required: false
          style: form
          explode: false
          schema:
            type: array
            items:
              type: string
            example: field1,field2
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ResourceListResult"
```

```
/resource?query=and(eq(field1,value1),eq(field2,value2))&limit=20&offset=20&sort=-field1&select=field1,field2
```

#### 3.4.1.2 Фільтрація

Фільтрація елементів колекції здійснюється за допомогою query параметру `query`. 

Наприклад query ```/cars?query=and(eq(doors,5),or(eq(color,blue),eq(color,black)))``` буде інтерпретовано як "знайти
автомобілі у яких 5 дверей та їх колір або синій або чорний".

#### 3.4.1.3 Пагінація

*Правило*

> Якщо колекція передбачувано буде мати багато елементів, то вона **ПОВИННА** підтримувати пагінацію. Визначення того, що 
> вважати за "багато" елементів залишається на архітекторі системи, адже це може залежати від вимог до швидкості роботи 
> системи, обмеженням по пам'яті, розміру конкретного ресурсу та багато чого іншого.

Існує два популярних підходи до реалізації пагінації:
- offset-based
- cursor-based (aka key-based or luke index):

*Правило*

> Для пагінації повинен використовуватись offset-based підхід.

**Опис offset-based підходу**

Це пагінація яка використовується в наших датасторах, фактично вказується номер елементу, що наступний після останнього
отриманого. Контролюється двома параметрами: розмір сторінки (limit) та зміщення (offset). 

Для початку клієнт повинен визначитись з тим скільки елементів колекції повинно повертатись на одній сторінці. Це буде
query параметр limit. При цьому цей параметр може мати значення по замовчуванню, тож клієнт може використовувати його.
Потім щоб перейти на сторінкку з номером n, де n - це ціле число, що більше або рівне за одиницю, клієнт повинен 
передати query параметр offset, який розраховується наступним чином: `offset = (n - 1) * limit`

*Правило*
> Query параметри offset і limit **ПОВИННІ** мати значення по замовчуванню.


Переваги:
- Велика поширеність у фреймворках/інструментах.
- Простота використання
- Можливість "стрибнути" на якусь певну сторінку, попередньо не отримавши на неї посилання

Недоліки:
- Порівняно низька швидкість роботи для виликих наборів данних.
- Низька швидкість роботи в NoSQL базах даних
- Можливість дублікатів при обході сторінок, якщо при цьому додався новий запис в базу даних.

*Правило*
> Якщо використовується пагінація, то разом з колекцією повинна повертатись metadata пагінації в форматі, як у прикладі
> нижче.

Request example
```http request
GET /resources
```

Response example
```json5
{
  "metadata": {
    "pagination": {
      "totalCount": 101,
      "offset": 0,
      "limit": 20
    }
  },
  "data": [
    // ...
  ]
}
```

**Опис Cursor-based підходу**

На данний момент ми не використовуємо cursor-based пагінацію, але для повноти інформації також опишемо цей підхід
в загальних рисах.

В цьому підході клієнт, щоб перейти на якусь сторінку повинен явно отримати від сервера значення курсору для цієї 
сторінки. Для клієнтської сторони курсор це лише набір символів, який вказує на певну сторінку. Реальне значення курсору 
може відрізнятись в залежності від імплементації сервера. Зазвичай у якості курсору використовують ідентифікатор першого 
або останнього елементу на сторінці.

Переваги:
- Швидкість роботи для великих наборів даних та NoSQL баз даних
- неможливість дублікатів при обході сторінок

Недоліки:
- Складність реалізації
- Неможливість "стрибнути" на певну сторінку, попередньо не отримавши посилання на неї

Зауваження:
- Може не працювати, якщо потрібен total count of results (поки не знаю чому, можливо мається на увазі його
  неефективність при даній умові)
- При неправильній реалізації може бути помилка, якщо курсор вказуватиме на елемент, що вже видалено

Request example (cursor - необов'язковий в першому запиті, але присутній для прикладу)
```http request
GET /resources?cursour=null
```

Замість null можна використовувати якісь інші зарезервовані значення: 0 або -1 і т.п. Головне щоб це значення було
вказано для поля у розділі default, а також коректно оброблювалось серверною стороною.

Response example
```json5
{
  "metadata": {
    "pagination": {
      "nextPageCursor": "gRk90324",
      "prevPageCursor": null,
      "currentCursor": 'nm2bu4n5j',
      "limit": 20
    }
  },
  "data": [
    // ...
  ]
}
```

### 3.5 Action

Action (екшн) ресурс - це процедурний концепт. Action ресурси - це віддалено запускаємі функції з вхідними аргументами та
результатом. Вони можуть бути корисні, щоб описати операції, які не підпадають під операції над колекціями чи 
документами, наприклад, валідація даних.

*Правило*
> Назва екшену повинна бути дієсловом, а не іменником. Кожен action міститься в колекції actions. Ця колекція може 
> бути як окрема колекція, якщо action виконує дію над декількома ресурсами одночасно, так і дочірньою для документа.
>
> Запуск екшена може виконуватись одним із http методів:
> - POST - якщо екшн має побічні ефекти (змінює стан ресурсу), або для екшенів що не мають побічних ефектів, але 
> потребують тіло запиту
> - GET - для екшенів, що не мають побічних ефектів

Приклади:

Відправка повідомлення роботодавцю

```http request
POST /employers/93017373/actions/send-notification
```

Конвертація грошей з однієї валюти в іншу (використовується GET, тому що операція не має побічних ефектів)

```http request
GET /actions/convert-money?from=EUR&amount=45&to=USD
```

*Правило*

> Перш ніж використовувати action подумайте над тим чи можливо його представити у вигляді ресурсу документа чи колекції,
> що описує намір дії.

Наприклад екшн відправки повідомлення

```http request
POST /employers/93017373/actions/send-notification
```

можна замінити ресурсом колекції

```http request
POST /employers/93017373/notifications
```

Використання іменника тут покращує розширюваність операцій. Наприклад можна додати GET запит, що поверне історію
усіх відправлених повідомлень.

Якщо вам потрібно реалізувати протяжний у часі екшн, який не зможе повертати результат синхронно, то рекомендується
поглянути у бік скінченного автомата, або реалізовувати екшн як лонг таск.

### 3.6 Скінченний автомат

Скінченний автомат - це підвид документа, що описує ресурс, який в ході свого існування може змінювати стани.

*Правило*

> Скінченний автомат повинен знаходитись в колекції `/fsm`: `/fsm/order-creation-tasks`, `/fsm/articles/123`

#### 3.6.1 Стани скінченного автомата
Скінченний автомат має стани. Кожен стан скінченного автомата однозначно описується полем `stage`. Це поле є 
обов'язковим, та значення, які це поле може приймати, повинні бути описані в маніфесті як enum.

Серед станів можна виділити початкові та кінцеві.

*Початковий стан* - це той в який скінченний автомат може потрапити після свого створення. Початковий стан може бути 
лише один.

*Кінцеві стани* - це такі стани, після потрапляння в які, зміна стану скінченного автомата більше не можлива. Кінцевий 
стан повинен бути хоча б один.

Скінченний автомат обов'язково починає своє виконання з одного з початкових станів та закінчує кінцевим.

В маніфесті в описі поля `stage` потрібно зазначити який стан є початковим, та які кінцевими.

Також скінченний автомат може мати додаткові поля. На прикладі нижче таким додатковим полем є `orderId`, яке з'являється 
при `fulfilled` стейджі.

Окрім `stage` є ще обов'язкове поле `status`, яке може приймати три значення:
- `pending` - якщо автомат НЕ в кінцевому стані
- `fulfilled` - якщо автомат в кінцевому стані і його виконання завершилось успішно
- `rejected` - якщо автомат в кінцевому стані і його виконання завершилось невдало

Кожен стейдж однозначно відповідає одному зі статусів. Якщо автомат в кінцевому стейджі, то поле `status` матиме
значення або `fulfilled` або `rejected`

Якщо немає потреби в детальних стейджах, то поле `stage` може бути рівним полю `status`. Тобто також приймати три
значення: `pending`, `fulfilled` та `rejected`

Поле `problem` у форматі [RFC-7807](https://www.rfc-editor.org/rfc/rfc7807) (TODO: посилання на опис формату помилки в 
специфікації) є обов'язковим при статусі `rejected`

Приклад скінченного автомата по створенню замовлення.

![Order creating stages](img/specification/creating-order-stages.jpg)

#### 3.6.2 Створення скінченного автомата
*Правило*

> Створення скінченного автомата - це завжди синхронна операція. У відповідь на створення лонг таску ми отримуємо лише 
> його ідентифікатор у заголовку Location, а не повну сутність.

Example request

```http request
POST /fsm/order-creation-tasks
Content-Type: application/vnd.rollun-request+json
```

```json
{
  "payload": {
    "idempotencyKey": "qwerty",
    "to": "WA, Yakima, 1712 Melrose Street, 98908",
    "items": [
      {
        "id": "ABC12",
        "qty": 1
      }
    ]
  }
}
```

Example response

```http
HTTP/1.1 200 OK
Location: /fsm/order-creation-tasks/qwerty123
```

На майбутнє ми залишаємо до розгляду варіант, коли створення скінченного автомата може бути асинхронною операцією. В 
цьому випадку ми б у відповідь на POST запит отримали б код 202 Accepted та ідентифікатор ресурсу через який можна 
відстежувати стан виконання операції. Але поки що вважаємо, що створення скінченного автомата - завжди синхронна 
операція.

#### 3.6.3 Ідемпотентність скінченного автомата

При створенні лонг таску обов'язково передається ключ ідемпотентності. Тоді повторний запит на створення лонг таску з
цим самим ключем вже не створить лонг таск, а або поверне помилку 409 Conflict, або екземпляр, вже створенного минулим
запитом, лонг таску. Це залежить від реалізації сервера.

Тут працює правило один ключ ідемпотнентності - один екземпляр автомата. Тому, якщо, наприклад, виконання задачі
завершилось помилкою, що призвело до rejected статусу, то цей лонг таск вже не можна ніяк змінити (тому що rejected -
кінцевий стан) та, наприклад, спробувати його перезапустити. Єдиний шлях повторно спробувати виконати дію - це створити
новий лонг таск з новим ключем ідемпотентності.

#### 3.6.4 Перехід між стейджами скінченного автомата
*Правило*

> Стейджі лскінченного автомата можуть змінюватись як сервером, так і клієнтом, якщо це допустимо.
> 
> Клієнт може змінювати стейджі за допомогою http запитів, що завчасно описані в маніфесті. При цьому усі запити повинні
> бути синхронними. Запити можуть бути двох видів:
> 1. PATCH & PUT запити, що змінюють поля скінченного автомата.
> 2. POST & GET /actions/... - екшени, що переводять скінченний автомат з одного стейджу в інший

При цьому, коли скінченний автомат переходить в якийсь із стейджів (навіть самого в себе), то на сервері можуть 
запускатись трігери, які також можуть змінити стейдж скінченного автомата.

*Правило*

> Якщо спробувати виконати запит, що не дозволенний в поточному стейджі лонг таску, то повинна повернутись помилка
> 409 Conflict.

Наприклад уявімо автомат, який описує стани статті. Вона може бути в трьох станах: validationError, readyToPublish,
published. Поки вона знаходиться в станах validationError та readyToPublish то ми її можемо редагувати за допомогою
PATCH запиту. При цьому після кожного редагування на сервері запуститься трігер який проведе валідацію статті і в
залежності від результата може змінити її стейдж. Коли стаття в стейджі readyToPublish то ми можемо запустити екшен
`POST /articles/actions/publish`, що переведе статтю в published стейдж.

![Article stages](img/specification/article-stages.jpg)

## 4. Media types

### 4.1 Схема опису

- **Parent:** батьківський медіа тип. Описуваний медіа тип містить усі властивості батківського типу,
  якщо явно не написано інше.

### 4.2 application/vnd.rollun-request+json

**Parent:** application/json

Цей медіа тип призначений для тіла запиту.

На верхньому рівні є завжди json об'єктом (не масивом, примитивом etc).

Для передачі корисних даних (фактично вхідних аргументів) **ПОВИННО** використовуватись поле `payload`. Поле **МОЖЕ**
бути відсутнім, якщо операції не передаються ніякі вхідні аргументи.

Передача інформації, для якої є визначені в http специфікації заголовки, повинна передаватись через них. А саме:

- Accept - список медіа типів які здатен опрацювати клієнт
- Accept-Charset - кодування символів (charset) яке здатен зрозуміти клієнт (utf-8, iso-8859-15, etc)
- Accept-Encoding - кодування (encoding) яке здатен опрацювати клієнт (gzip, compress, br)
- Accept-Language - набір природних мов, яким клієнт надає перевагу
- Authorization - данні авторизації
- From - email адреса власника клієнта (що, відправляє запит)
- Заголовки умовних запитів: If-Match, If-None-Match, If-Modified-Since, If-Unmodified-Since, If-Range
- Інші технічні заголовки

Openapi schema:

```yaml
SuccessResponse:
    type: object
    properties:
        payload:
            nullable: true
            description: >
                Корисна інформація про стан ресурсу, або колекції ресурсів. Стан ресурсу описується набором полей 
                об'єкту, або примитивом (рядок, число і т.п.).
```

### 4.3 application/vnd.rollun-document+json

**Parent:** application/vnd.rollun-metadata+json

Медіа тип призначений для успішних відповідей з документом в тілі відповіді.

На верхньому рівні є завжди json об'єктом.

Представлення документа **ПОВИННО** міститись у полі `data`. 

Поле `data` **МОЖЕ** бути відсутнім, якщо успішне виконання операції має пусте представлення. Відсутність результату 
(поле `data` відсутнє) може повертатись операцією, яка ніколи не повертає ніякого результату. У таких операцій все ще є 
сенс повертати тіло відповіді, оскільки, окрім безпосередньо результату (поля'data') в ньому може міститись інформація 
про попередження, метаданні і т.п.

Поле `data` може містити порожній результат, тобто дорівнювати null, що означає, що операція загалом повертає результат, 
але у данному конкретному випадку його немає (з легальних причин).

Об'єкт **МОЖЕ** містити поле `warnings` з масивом об'єктів попередження.

Формат об'єкта попередження:
- `type` - urn з типом помилки
- `title` - engineers-readable повідомлення з коротким описом попередження.
- `details` - human-readable повідомлення з коротким описом попередження.

Openapi schema:

```yaml
DocumentResponse:
    type: object
    properties:
        data:
          type: object
          nullable: true
          description: >
            Представлення документа. Представлення ресурсу документа описується набором полей 
            об'єкту, або примитивом (рядок, число і т.п.).
        warnings:
          type: array
          items:
            $ref: "#/components/schemas/Warning"

Warning:
  description: A warning object
  type: object
  required:
    - type
    - title
    - status
    - detail
    - instance
  properties:
    type:
      type: string
      format: uri
      description: An absolute URI that identifies the problem type
      example: https://rollun.org/docs/openapi/warnings/deprecation
    title:
      type: string
      description: |
        A short, summary of the problem type. Written in English and readable for engineers (usually not suited 
        for non technical stakeholders and not localized). The same for the same warning types.
      example: Deprecation
    detail:
      type: string
      description: A human-readable explanation specific to this occurrence of the problem
      example: Field 'author' is deprecated
```

### 4.4 application/vnd.rollun-collection+json

- **Parent:** application/json

Медіа тип призначений для повернення колекцій документів.

На верхньому рівні є завжди json об'єктом.

Поле `data` **ПОВИННО** бути присутнім і містити массив - колекцію документів.

Поле `metadata` **МОЖЕ** бути присутнім і містити додаткову інформацію про колекцію:
- про пагінацію 
  - offset - поточний відступ
  - limit - кількість елементів на сторінці
  - totalCount - загальна кількість елементів

Openapi schema:

```yaml
CollectionResponse:
    type: object
    required:
      - data
    properties:
        data:
          type: array
          description: An array of documents 
          items:
            type: object
        metadata:
            $ref: "#/components/schemas/Metadata"
            description: Метаінформація про ресурс, або колекцію ресурсів.
        warnings:
          type: array
          items:
            $ref: "#/components/schemas/Warning"
Metadata:
  type: object
  properties:
    pagination:
      allOf:
        - $ref: "#/components/schemas/PaginationMetadata"

OffsetPaginationMetadata:
  required:
    - totalCount
    - limit
    - offset
  properties:
    totalCount:
      type: int
      description: total items in collection
    limit: 
      type: int
      description: count of elements in current page
    offset:
      type: int
      description: offset of current page

Warning:
  description: A warning object
  type: object
  required:
    - type
    - title
    - status
    - detail
    - instance
  properties:
    type:
      type: string
      format: uri
      description: An absolute URI that identifies the problem type
      example: https://rollun.org/docs/openapi/warnings/deprecation
    title:
      type: string
      description: |
        A short, summary of the problem type. Written in English and readable for engineers (usually not suited 
        for non technical stakeholders and not localized). The same for the same warning types.
      example: Deprecation
    detail:
      type: string
      description: A human-readable explanation specific to this occurrence of the problem
      example: Field 'author' is deprecated
```

### 4.5 application/vnd.rollun-error+json

- **Parent:** application/json

Медіа тип призначений для опису помилок при створенні чи отриманні ресурсу і **НЕ ПОВИНЕН** використовуватись у запитах.
**МОЖЕ** використовуватись разом з 2хх кодом, якщо сама http операція виконалась успішно, але результат який описується
цією операцією - помилка. Приклад такої поведінки можна знайти в описі лонг тасків.

На верхньому рівні є завжди json об'єктом.

Об'єкт **НЕ ПОВИНЕН** містити поле `data`.

Об'єкт **ПОВИНЕН** містити поле `problem` з об'єктом опису помилки.

Ми беремо об'єки помилки у форматі зі стандарту [RFC-7807](https://www.rfc-editor.org/rfc/rfc7807) додаячи деякі свої
вимоги.

Об'єкт опису помилки **ПОВИНЕН** містити наступні поля:
- `title` (string) - engineers-readable повідомлення з коротким описом типу помилки. Має бути однаковим для однакових
типів помилок.
- `detail` (string) - human-readable повідомлення з детальним описом помилки.
- `status` (number) - http статус код, що описує помилку (може не завжди відповідати статус коду, що повернувся у 
відповіді, наприклад, якщо помилка описує результат попередньої операції).
- `type` (string) - uri, що описує помилку.
- `instance` (string) - uri конкретно цього випадку проблеми (в нашому випадку це lifecycle_token)

Об'єкт опису помилки **МОЖЕ** містити наступні поля:
- `context` - опціональний, довільний json object з деталями помилки

На прикладі це виглядає наступним чином:

Запит

```http request
POST /articles
Content-Type: application/vnd.rollun-request+json

{
  "payload": {
    "title": "Hello, world!"
  }
}
```

Відповідь

```http
HTTP/1.1 400 Bad Request
Content-Type: application/vnd.rollun-error+json
```

```json
{
  "problem": {
    "type": "https://rollun.org/docs/openapi/problems/inputValidationProblem",
    "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
    "status": 400,
    "title": "Validation error",
    "detail": "There is no author in request body",
    "context": {
      "issues": [
        {
          "type": "https://rollun.org/docs/openapi/problems/inputValidationProblem:schemaViolation",
          "in": "body",
          "name": "author",
          "detail": "Field author is mandatory"
        }
      ]
    }
  }
}
```

**Формат поля `type`:**

`https://rollun.org/docs/openapi/problems[/{api}]/{type}`

де:

`<api>` [необов'язковий]: назва api (title маніфесту), для специфічних помилок конкретного API

`<type>`: тип помилки в kebab-case

*Типи помилок, за можливості, потрібно робити незалежними від конкретного API*

**Формат поля `instance`:**

`https://elastic.com/logs?lifecycle-token=<lifecycle-token>`

Поле `issues` специфічне для типу помилки `https://rollun.org/docs/openapi/problems/validationError`

Об'єкт на верхньому рівні **МОЖЕ** містити поле `warnings` з об'єктом попередження.

Openapi schema:

```yaml
ErrorResponse:
    type: object
    properties:
        problem:
          allOf:
            - $ref: "#/components/schemas/Message"
        warnings:
          type: array
          items:
            $ref: "#/components/schemas/Warning"

Problem:
  description: A Problem Details object (RFC 7807)
  type: object
  required:
    - type
    - title
    - status
    - detail
    - instance
  properties:
    type:
      type: string
      format: uri
      description: An absolute URI that identifies the problem type
      example: https://rollun.org/docs/openapi/problems/service-unavailable
    title:
      type: string
      description: |
        A short, summary of the problem type. Written in English and readable for engineers (usually not suited 
        for non technical stakeholders and not localized).
      example: Service Unavailable
    status:
      type: integer
      format: int32
      description: The HTTP status code generated by the origin server for this occurrence of the problem.
      minimum: 400
      maximum: 600
      exclusiveMaximum: true
      example: 503
    detail:
      type: string
      description: A human-readable explanation specific to this occurrence of the problem
      example: External API is temporarily unavailable. Please try again after 120 seconds.
    instance:
      type: string
      format: uri
      description: Uri to where logs is placed. Should contain lifecycle token
      exampole: https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW
    context:
      type: object
      additionalProperties: true
      description: Object with error details

Warning:
  description: A warning object
  type: object
  required:
    - type
    - title
    - status
    - detail
    - instance
  properties:
    type:
      type: string
      format: uri
      description: An absolute URI that identifies the problem type
      example: https://rollun.org/docs/openapi/warnings/deprecation
    title:
      type: string
      description: |
        A short, summary of the problem type. Written in English and readable for engineers (usually not suited 
        for non technical stakeholders and not localized). The same for the same warning types.
      example: Deprecation
    detail:
      type: string
      description: A human-readable explanation specific to this occurrence of the problem
      example: Field 'author' is deprecated
```

### 4.6 application/vnd.rollun-long-task+json

- **Parent:** application/vnd.rollun-document+json

Призначений для опису стану виконання асинхронної задачі.

Поле `data` **ПОВИННО** бути присутнім. В полі `data` **ПОВИНЕН** міститись об'єкт `long-task`.

Об'єкт `long-task` **ПОВИНЕН** містити поля:
- `id` : string - ідентифікатор задачі.
- `idempotency-key` - ключ ідемпотентності
- `status` - enum: pending, rejected, fulfilled
- `problem`: `application/problem+json` - якщо статус 'rejected'

Об'єкт `long-task` **МОЖЕ** містити поля:
- `stage` : string - етап виконання задачі, повинен бути enum
- `percentComplete`: int[0-100] - стан виконання задачі у відсотках
- `createdAt`: date-time - час створення задачі
- `startedAt`: date-time - час початку виконання задачі

При використанні цього типу, якщо задача в статусі `pending`, то **РЕКОМЕНДУЄТЬСЯ** повертати хедер `Retry-After`,
що буде описувати естімейт, коли задача завершиться.

### 4.7 application/vnd.rollun-long-task-collection+json

- **Parent:** application/vnd.rollun-collection+json

Колекція об'єктів `long-task`.

В полі `data` усі об'єкти **ПОВИННІ** бути типу `long-task` як описано в медіа типі 
`application/vnd.rollun-long-task+json`.

### 4.8 application/vnd.rollun-fsm+json

- **Parent:** application/vnd.rollun-document+json

Поле `data` **ПОВИННО** бути присутнім. В полі `data` **ПОВИНЕН** міститись об'єкт `fsm`.

Об'єкт `fsm` **ПОВИНЕН** містити поля:
- `id` : string - ідентифікатор скінченного автомата.
- `idempotency-key` - ключ ідемпотентності
- `status` - enum: pending, rejected, fulfilled
- `stage` : string - етап виконання задачі, повинен бути enum
- `problem`: `application/problem+json` - якщо статус 'rejected'

### 4.9 application/vnd.rollun-fsm-collection+json

- **Parent:** application/vnd.rollun-collection+json

Колекція об'єктів `fsm`.

В полі `data` усі об'єкти **ПОВИННІ** бути типу `fsm` як описано в медіа типі `application/vnd.rollun-fsm+json`.

### 4.10 Підсумок

Діаграма наслідування медіа типів:

![Media-types](img/specification/media-types.jpg)

## 6 Версіонування API

### 6.1 Підхід до версіонування

З великою ймовірністю REST API, що описане в маніфесті, буде змінюватись. Зміни можуть бути наступними:
- Виправлення помилок
- Впровадження нових можливостей
- Видалення старих можливостей
- Зміна старих можливостей

При цьому деякі зміни можуть приводити до появи помилок на клієнті, наприклад, якщо було видалено поле яким
користувався клієнт.

Для того, щоб не запобігти неочікуваної появи помилок, через зміни API інтерфейсу в маніфесті, можна використовувати
версіонування API.

> Api - це абстрактне поняття, яке може бути описане за допомогою різних форматів: openapi маніфест,
> мова програмування, природня мова (e.g. українська, англійська) і т.п.
>
> Тому на далі коли говориться про зміну в API (чи REST API), то також мається на увазі, що й ідентична зміна
> відбудеться в openapi маніфесті, як в документі, що описує API. Так само і навпаки: зміна в маніфесті означає
> ідентичну зміну в API, який описується цим маніфестом.

Для версіонування будь-якого API (будь-то інтерфейс php бібліотеки, чи REST API) існує стандарт під назвою
[семантичне версіонування](https://semver.org/lang/uk/). Який ми й будемо використовувати.

> Короткий опис семантичного версіонування:
>
> Версія має вигляд МАЖОРНА.МІНОРНА.ПАТЧ. При цьому слід збільшувати:
> 1. МАЖОРНУ версію, якщо зроблені зміни API, що несумісні з попередньою версією
> 2. МІНОРНУ версію, якщо додана нова функціональність, що є сумісною з попередньою версією
> 3. ПАТЧ версію, якщо були зроблені виправлення помилок, що не впливають на сумісність з попередньою версією

Зміна буде вважатись сумісною з попередньою версією, тоді коли при заміні старої версії API на нову, функціонування
**будь-якої** системи, яка **користується** цим API, не порушиться.

Важливо розуміти, що сумісність розглядається лише стосовно системи, яка **користується** API, а не для системи, яка
**реалізовує** це API. В загальному випадку будь-яка зміна API є несумісною для системи, що **реалізовує** API,
хоча й в деяких конкретних випадка, в залежності від специфіки реалізації, можуть бути виключення. Так само як і зміна,
що в загальному випадку порушує сумісність, може не порушувати її для якогось конкретного специфічного клієнта.

> У нашому випадку систему, яка користується API - клієнт, а система, що реалізовує API - сервер.

*Правило:*

> В маніфесті потрібно застосовувати [семантичне версіонування](https://semver.org/lang/uk/). Версія повинна
> записуватись в `info` секцію, поле `version`.

```yaml
openapi: "3.0.0"
info:
  title: petShop
  description: API exposing my pet shop’s functionality
  version: "2.1.2"
servers:
  - url: https://example.org/petShop/v2
paths:
  # ...
```

*Правило*
> Версіонування api ПОВИННО вказуватись в URL, це дозволить простіше кешувати ресурси (адже uri однозначно
> співвідноситься з даними які повертаються), а також дозволить вказувати версію при відправці get запиту через браузер.
>
> Тільки мажорна версія повинна бути вказанна в URL. Тим самим сервер в один момент часу може реалізовувати тільки
> одну мінорну та патч версію для кожного мажорного релізу.

### 6.2 Коли змінювати мажорну версію

При *будь-яких* змінах, що порушують зворотну сумісність (в тому числі при виправленні помилок, за виключеннями, що
будуть описані талі).

Приклади змін, що порушують зворотну сумісність:
- Змінна типу поля
- Зміна значення (сенсу) поля, навіть якщо його тип не змінився
- Видалення поля
- Додання обмежень до логіки валідації
- Збільшення діапазону enum значень у відповіді
- Зменшення діапазону enum значень у запиті
- Зміна сенсу enum значень
- Видалення ендпоінту
- Додання обов'язкового поля до запиту
- Зміна поля з необов'язкового на обов'язкове у запиті
- Зменшення діапазону enum значень у відповіді (тому що це впливає на валідацію)

Рекомендується, за можливості, запобігати таких змін. Для цього можна, наприклад:
- замість видалення поля/ендпоінту, можна його відмітити як deprecated.
  > Якщо стандартними засобами помітити щось як deprecated не можливо, то можна просто написати про це в описі.
- Замість зміни сенсу, або типу поля можна створити нове поле, та підтримувати обидва поля, до наступної мажорної
  версії маніфесту.

### 6.3 Коли змінювати мінорну версію

Зі [специфікації семантичного версіонування](https://semver.org/lang/uk/#spec-item-7):

> Мінорна версія Y (x.Y.z | x > 0) ПОВИННА бути збільшена, якщо до публічного API додана нова зворотньосумісна
> функціональність. Вона ПОВИННА бути збільшена, якщо будь-яка функціональність публічного API позначена, як
> застаріла (deprecated). Вона МОЖЕ бути збільшена, якщо в приватний код внесені істотні зміни функціональних
> можливостей або вдосконалення. Вона МОЖЕ включати зміни рівня патчів. Патч версія ПОВИННА бути скинута до 0 при
> збільшенні мінорної версії.

Приклади:
- Додання нової інформації у відповідь, яка ніяк не впливає на інформацію, що вже поверталась.
  > При умові, що клієнти ігнорують усі невідомі їм поля
  >
  > Наприклад нам поверталась деяка відстань в метрах в полі `distanceInMeters`, а потім ми додали поле
  > `distanceInFoots` з цією самою відстанню, але в футах.
- Додання необов'язкового поля до запиту
- Помітити enum значення/поле/ендпоінт як deprecated.
  > На жаль наразі відмітити одне значення з діапазону enum як застаріле неможливо, тому це потрібно просто писати в
  > описі. Наприклад, якщо ми перестаємо використовувати значення in_progress в деякому status енамі, то в маніфесті це
  > потрібно відобразити так:
  >```
  > status:
  >   type: string
  >   description: |
  >     pending - ...
  >     in_progress - deprecated.
  >     fulfilled - ...
  >     rejected - ...
  >   enum:
  >     - pending
  >     - in_progress
  >     - fulfilled
  >     - rejected
  >```
  > У випадку, якщо якесь enum значення, що використовується лише у відповідях, поміченно як deprecated, то сервер
  > **ПОВИНЕН** перестати його використовувати.
- Додання нового ендпоінту
- Додання документації

### 6.4 Коли змінювати patch версію

Це виправлення помилок, що не порушують [зворотну сумісність](#63-коли-змінювати-мінорну-версію). А також:
- Додання прикладів в маніфест
- Виправлення помилок в документації.

## 7 Рейт ліміти

*Правило*

> Сервер, у якого є рейт ліміти, ПОВИНЕН повертати з **кожною** відповіддю наступні три заголовки:
> 
| Header Name           | 	Description                                                |
|-----------------------|----------------------------------------------------------------|
| x-ratelimit-limit     | 	Дозволена кількість запитів в годину                       |
| x-ratelimit-remaining | Кількість запитів що залишилась в поточному лімітному вікні |
| x-ratelimit-reset     | Таймстамп в UNIX коли лімітне вікно обновиться              |

Приклад:

```bash
$ curl -I https://api.serivce.com/users/octocat
> HTTP/2 200
> Date: Mon, 01 Jul 2013 17:27:06 GMT
> x-ratelimit-limit: 60
> x-ratelimit-remaining: 56
> x-ratelimit-reset: 1372700873
```

*Правило*
> Якщо використовувася [conditional request](https://docs.github.com/en/rest/overview/resources-in-the-rest-api#conditional-requests)
> і повернувся код 304 Not Modified, то цей запит не враховується в рейт лімітах.

*Правило*

> Якщо рейт ліміти закінчились у лімітному вікні, то сервер ПОВИНЕН повернути 429 код відповіді.

```bash
$ curl -I https://api.serivce.com/users/octocat
> HTTP/2 429
> Date: Mon, 01 Jul 2013 17:27:06 GMT
> x-ratelimit-limit: 60
> x-ratelimit-remaining: 0
> x-ratelimit-reset: 1372700873
```

### 7.1 Вказання рейт лімітів по-замовчуванню в маніфесті

*Правило*

> Рейт ліміти вказуються через [кастомні атрибути](https://swagger.io/docs/specification/openapi-extensions/). Ми можемо
> вказати рейт-ліміти для окремої операції (ендпоінту):
>
> ```yaml
> paths:
>   /users/{id}:
>     x-ratelimit-limit: 100 # Кількість запитів доступних для лімітного вікна
>     x-ratelimit-window: 60 sec # Час життя лімітного вікна
>     responses:
>       # ...
> ```
> 
> Або для усіх едпоінтів одночасно в секції info:
> 
> ```yaml
> info:
>   title: ...
>   version: ...
>   x-ratelimit-limit: 100
>   x-ratelimit-window: 60 sec
> ```
>
> Рейт ліміти, що вказані для окремої операції мають вищий приорітет та перевизначають ліміти, що вказані у секції info.

## 8 Tracing

Для того щоб можна було відстежувати джерело запитів, а також переглядати пов'язанні з запитом логи, кожен запит може
містити унікально згенероване значення за допомогою якого можна відстежувати цикл життя запиту.

*Правило*
> API ПОВИННО відправляти заголовок `Lifecycle-Token` з кожним запитом, в якому повинно міститись унікально згенерований
> рядок.

## 9 Обробка помилок

### 9.1 Значення статус коду

Статус код визначає лише успішність виконання поточної http операції (хоча й результат операції може описувати
попередні операції). Добре ци видно на прикладі з асинхроними задачами.

Припустимо, що ми хочемо створити нову статтю. У нашого Api стаття характеризується полями: title, description та
author. Серед яких title та author - обов'язкові. Зазвичай створення нової статті - це синхроний процес, але в
деяких випадках система буває перенавантаженою, та відкладає створення нових ресурсів у чергу.

Розглянемо варіант створення статті, при якому відбувається помилка: в запиті відсутнє обов'язкове поле author, для
двох випадків:

**1. Синхронне створення**

Запит

```http request
POST /articles
Content-Type: application/json

{
  "title": "Hello, world!"
}
```

Оскільки POST операцію (тобто створення) не вдалось виконати, то у відповідь повернеться код помилки 400 Bad Request
(чому він можна глянути [тут](https://stackoverflow.com/questions/3290182/which-status-code-should-i-use-for-failed-validations-or-invalid-duplicates))
та деякий об'єкт що описує помилку (поки не будемо вдаватись в формат об'єкту).

**2. Асинхронне створення**

Візьмемо запит з попереднього пункту, та допустимо, що операція створення відклалась в чергу через перенавантаження
системи. В такому випадку у відповіді повернеться 202 Accepted код, який сигналізує що запит прийнято, але ще не
опрацьовано, а також посилання на ресурс задачі, через який можна відслітковувати стан виконання операції.

```http
HTTP/1.1 202 Accepted 
Location: /articles/tasks/1
```

Після чого ми відправляємо запит на отримання стану виконання операції:

```http request
GET /articles/tasks/1
```

Якщо задачу, ще не завершено, та get запит відпрацював успішно, то у відповідь ми разом із станом задачі отримаємо код
200 OK. Вже на цьому етапі варто зазначити, що хоч і операція виконується асинхроно код на GET запит повертається 200, а
не 202. Тому що цей код визначає саме успішність **операції по отриманню** ресурсу `/articles/tasks/1`, який вже
описує стан минулого запиту (POST /articles).

Так само, після того, як до створення статті дійте черга та валідатор помітить, що поле `autor` відсутнє, то ми у
відповідь на `GET /articles/tasks/1` отримаємо 200 код, а не 400, а в тілі відповіді буде об'єкт з описом помилки
(звісно при умові, що сам GET запит відпрацював успішно, тобто не виникло ніяких проблем з мережею і т.п.).

### 9.2 Формат опису помилки

*Правило*

> Для опису помилки **ПОВИНЕН** використовуватись медіа тип 
> [application/vnd.rollun-error+json](#45-applicationvndrollun-errorjson)

### 9.3 Попередження

Випадки в яких може повертатись попередження:
- *Виникли помилки, що не завадили виконанню операції* (наприклад при створенні замовлення клієнту не змогло
  відправитись оповіщення по email).
- *Клієнт не дотримується рекомендацій по використанню API* (наприклад не передає в запиті поле, що не обов'язкове, але
  рекомендоване)

### 9.4 Стандартні типи помилок

#### 9.4.1 InputValidationProblem

- **Status code**: 400 Bad Request
- **Title**: Validation problem
- **Description**: Вхідне повідомлення не пройшло валідацію. Деталі описані у полі `context.issues`.

Запит

```http request
GET /suppliers/not-exist/orders
```

Відповідь

```http
HTTP/1.1 400 Bad Request
Content-Type: application/rollun.problem+json
```

```json
{
  "problem": {
    "type": "https://rollun.org/docs/openapi/problems/input-validation-problem",
    "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
    "status": 400,
    "title": "Validation error",
    "detail": "There is no supplier with name 'not exitst'",
    "issues": [
      {
        "type": "https://rollun.org/docs/openapi/problems/input-validation-problem/schemaViolation",
        "in": "path",
        "name": "supplier",
        "detail": "Supplier 'not-exist' is not in enum"
      }
    ]
  }
}
```

#### 9.4.2 Missing Permission

- **Status code**: 403 Forbidden
- **Title**: Missing Permission
- **Description**: Клієнт не має дозволу на запуск цієї операції.

Запит

```http request
PUT /parts-unlimited/orders
Authorization: Bearer ds4d2f13sdds2q13qxcgbdf245
```

Відповідь

```
HTTP/1.1 403 Forbidden
Content-Type: application/problem+json
```

```json
{
  "problem": {
     "type": "https://rollun.org/docs/openapi/problems/missing-permission",
     "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
     "status": 403,
     "title": "Missing Permission",
     "detail": "Not permitted to update the order of this supplier"
  }
}
```

#### 9.4.3 Resource Not Found

- **Status code**: 404 Not Found
- **Title**: Resource Not Found
- **Description**: Сервер не знайшов ресурс, або не бажає розкривати клієнту його існування. Ця помилка не вказує на
  те чи ресурс тимчасово не доступний, чи його не існує взагалі (код 410 в приорітеті, якщо сервер точно знає, що
  відсутність ресурсу постійна). В полі `details` міститься детальніша інформація чому ресурс не знайдено.

Запит

```http request
GET /parts-unlimited/orders/123
```

Відповідь

```http
HTTP/1.1 404 Not Found
Content-Type: application/problem+json
```

```json
{
  "problem": {
     "type": "https://rollun.org/docs/openapi/problems/resource-not-found", 
     "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
     "status": 404,
     "title": "Resource Not Found",
     "detail": "The order with number '123' never existed or has been deleted."
  }
}
```

#### 9.4.4 Too Many Requests

- **Status code**: 429 Too Many Requests
- **Title**: The request limit has been reached
- **Description**: Клієнт вичерпав ліміт запитів в поточному лімітному вікні.

Запит

```http request
GET /parts-unlimited/orders/123
```

Відповідь

```http
HTTP/1.1 429 Too Many Requests
Content-Type: application/problem+json
x-ratelimit-limit: 60
x-ratelimit-remaining: 0
x-ratelimit-reset: 1372700873
```

```json
{
  "problem": {
     "type": "https://rollun.org/docs/openapi/problems/too-many-requests",
     "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
     "status": 429,
     "title": "The request limit has been reached",
     "detail": "No more requests accepted before 2013-07-01T17:47:53.000Z"
  }
}
```

#### 9.4.5 Internal Server Error

- **Status code**: 500 Internal Server Error
- **Title**: Internal Server Error
- **Description**: Сервер зіштовхнувся с помилкою, яку не знає як обробляти.

Запит

```http request
GET /parts-unlimited/orders/123
```

Відповідь

```http
HTTP/1.1 500 Internal Server Error
Content-Type: application/problem+json
```

```json
{
  "problem": {
     "type": "https://rollun.org/docs/openapi/problems/internal-server-error",
     "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
     "status": 500,
     "title": "Internal Server Error",
     "detail": "Null pointer exception while executing 'Order::create'."
  }
}
```

#### 9.4.6 Bad Gateway

- **Status code**: 502 Bad Gateway
- **Title**: Bad Gateway
- **Description**: Сервер, діючи як шлюз (gateway) або проксі некоректну відповідь (або яку не знає як обробляти) від
  висхідного сервера. На мій полгяд є сенс використовувати цей код у всіх ситаціях (якщо немає очевидно кращого коду),
  коли сервер не може виконати запит, через те що отримав некоректну відповідь від іншого сервера. Але це не стосується
  ситуацій, коли сервер отримав цілком легальну помилку від іншого сервера, яку знає як обробляти (Наприклад висхідний
  сервер, що відправляє електроні листи повернув помилку, що заданого email не існує).

Запит

```http request
GET /autodist/orders/123
```

Відповідь

```http
HTTP/1.1 502 Bad Gateway
Content-Type: application/problem+json
Retry-After: 120
```

```json
{
  "problem": {
     "type": "https://rollun.org/docs/openapi/problems/bad-gateway",
     "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
     "status": 502,
     "title": "Bad Gateway",
     "detail": "Cannot fulfill request because autodist api returned 500 Internal Server Error"
  }
}
```

#### 9.4.6 Service Unavailable

- **Status code**: 503 Service Unavailable
- **Title**: Internal Server Error
- **Description**: Сервер тимчасово не доступний, або не може виконати операцію через недоступність серверів від
  яких він залежить. Якщо відоммо час, коли сервер відновить роботу, то він повинен бути зазначенний у хедері
  Retry-After

Запит

```http request
GET /autodist/orders/123
```

Відповідь

```http
HTTP/1.1 503 Service Unavailable
Content-Type: application/problem+json
Retry-After: 120
```

```json
{
  "problem": {
     "type": "https://rollun.org/docs/openapi/problems/service-unavailable",
     "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
     "status": 503,
     "title": "Service Unavailable",
     "detail": "Autodist api is temporarily unavailable. Please try again after 120 seconds."
  }
}
```
#### 9.4.7 Gateway Timeout

- **Status code**: 504 Gateway Timeout
- **Title**: Gateway Timeout
- **Description**: Сервер, діючи як шлюз (gateway) або проксі не дочекався відповіді від висхідного серверу
  Запит

```http request
GET /autodist/orders/123
```

Відповідь

```http
HTTP/1.1 504 Gateway Timeout
Content-Type: application/problem+json
Retry-After: 120
```

```json
{
  "problem": {
    "type": "https://rollun.org/docs/openapi/problems/gateway-timeout",
    "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
    "status": 504,
    "title": "Gateway Timeout",
    "detail": "Cannot fulfill request because autodist api request is timeout"
  }
}  
```

### 9.5 Помилки, що не мають http відповіді

Деякі помилки виникають через те що сервер або не зміг відправити запит, або не отримав ніякої відповіді. Для таких
випадків немає http кодів (адже вони застосовуються у відповіді якої в даних ситуація просто немає), так само як
і немає сенсу описувати тіло відповіді, якої немає. Ці випадки клієнт сам повинен коректно визначати та обробляти.

Перелік таких помилок:
- Request Timeout
- DNS errors
- Connection errors

## 10 Long tasks

*Правило*

> При виконанні будь-якого http запит у відповідь може повернутись 202 код. Це означає, що сервер прийняв запит в
> обробку, але поки ще не виконав (відклав його у чергу). В результаті запит може як виконатись, так і ні. Представлення
> при цьому коді містить опис поточного стану виконання запиту, а також вказівник на ресурс (далі задача), що надає
> користувачеві оцінку того, коли запит буде виконаний.
>
> У відповіді з 202 статусом медіа тип **ПОВИНЕН** бути [application/vnd.rollun-long-task+json](#46-applicationvndrollun-long-taskjson).
> Також може бути присутній заголовок Retry-After з естімейтом виконання задачі.
> 
> При отриманні (GET) ресурсу задачі відповіді можуть бути наступні:
> - Задача в обробці (status = pending): статус 200 OK і представлення ресурсу зі станом задачі (медіа тип 
> application/vnd.rollun-long-task+json)
> - Успіх (status = fulfilled): статус 303 See Other з заголовком Location, який містить посилання (URL) на результат 
> задачі.
> - Помилка (status = rejected): статус 200 OK з представленням ресурсу зі станом задачі, який також містить причину 
> помилки

**Початок асинхроного запиту**

Request
```http request
POST /articles
Accept: application/vnd.rollun+json, application/vnd.rollun-error+json, application/vnd.rollun-long-task+json
Content-Type: application/vnd.rollun-request+json

{
  "payload": {
    "idempotencyKey": "abc",
    "title": "My article!"
  }
}
```

Response
```http
HTTP/1.1 202 Accepted
Location: http://www.example.org/articles/actions/creating/123
Retry-After: 30
Content-type: application/vnd.rollun-long-task+json

{
  "task": {
    "id": "123",
    "status": "pending",
    "idempotencyKey": "abc",
    "stage": "step-0"
  }
}
```

**Отримання стану задачі**

Request
```http request
GET /articles/actions/creating/123
Accept: application/vnd.rollun-error+json, application/vnd.rollun-long-task+json
```

Response
```http
HTTP/1.1 200 Ok
Content-type: application/vnd.rollun-long-task+json
Retry-After: 10

{
  "task": {
    "id": "123",
    "status": "pending",
    "idempotencyKey": "abc",
    "stage": "step-1",
  }
}
```

**Якщо виконання успішно закінчилось**

У відповідь ми отримуємо 303 статус, з посиланням на результат операції в полі "resultId" (якщо результат існує).

Request
```http request
GET /articles/actions/creating/123
Accept: application/vnd.rollun-error+json, application/vnd.rollun-long-task+json
```

Response
```http
HTTP/1.1 303 See Other
Location: http://www.example.org/articles/1
Content-type: application/vnd.rollun-long-task+json

{
  "task": {
    "id": "123",
    "status": "fulfilled",
    "idempotencyKey": "abc",
    "stage": "done",
    "completed":"2018-09-13T02:10:00Z",
  }
}
```

Request

```http request
GET http://www.example.org/articles/1
Accept: application/vnd.rollun+json, application/vnd.rollun-error+json
```

Response

```http
HTTP/1.1 200 OK
Content-type: application/vnd.rollun+json

{
  "data": {
    "id": 1,
    "idempotencyKey": "abc",
    "title": "My article!"
  }
}
```

**Якщо виконання закінчилось помилкою**, то повертається код **200**, а тіло відповіді буде описувати помилку.

*Детальніше про те чому код саме 200 в розділі про [обробку помилок](#91-значення-статус-коду)*

Request
```http request
GET /articles/actions/creating/123
Accept: application/vnd.rollun+json, application/vnd.rollun-error+json, application/vnd.rollun-long-task+json
```

Response

```http
HTTP/1.1 200 Ok
Content-Type: application/vnd.rollun-long-task+json
```

```json
{
  "task": {
    "id": "123",
    "status": "rejected",
    "idempotencyKey": "abc",
    "stage": "step-01",
    "completed":"2018-09-13T02:10:00Z",
    "problem": {
      "type": "https://rollun.org/docs/openapi/problems/internal-server-error",
      "instance": "https://elastic.com/logs?lifecycle-token=AHJKSD234JIOWFE433HFW",
      "status": 500,
      "title": "Internal Server Error",
      "detail": "Null pointer exception while executing 'Article::create'."
    }
  }
}
```

## 11 Кешування

Продуктивність веб-сайтів та програм можна значно підвищити за рахунок повторного використання раніше отриманих 
ресурсів. Веб-кеші скорочують затримку та знижують мережевий трафік, зменшуючи тим самим час, необхідний для 
виконання запиту.

*Правило*

> Http кешування **СЛІД** застосовувати для ресурсів, що часто запитуються клієнтами

### 11.1 Різні види кешу

Техніка кешування полягає у збереженні копії отриманого ресурсу для повернення цієї копії у відповідь на подальші 
запити. Запит на ресурс, що вже є у веб-кеші, перехоплюється і замість звернення до вихідного сервера виконується 
завантаження копії з кеша. Таким чином, знижується навантаження на сервер, якому не доводиться самому обслуговувати 
всіх клієнтів, і підвищується продуктивність — кеш ближче до клієнта і ресурс передається швидше. Кешування є основним 
джерелом підвищення продуктивності веб api. Проте, кеш треба правильно налаштувати: ресурси рідко залишаються 
незмінними, отже копію потрібно зберігати лише доти, як ресурс змінився, але не довше.

Існує кілька видів кешів, які можна поділити на дві основні категорії: приватні кеші та кеші спільного використання. 
У кешах спільного використання (shared cache) зберігаються копії, які можуть надсилатися різним користувачам. Приватний 
кеш призначений для окремого користувача. Тут буде говорити в основному про кеші браузерів та проксі, але існують також 
кеші шлюзів, CDN, реверсні проксі кеші та балансувальники навантаження, що розгортаються на серверах для підвищення 
надійності, продуктивності та масштабованості веб-сайтів та веб-додатків.

#### 11.1.1 Приватний кеш

Приватний кеш призначений для окремого клієнта. Ви, можливо, вже бачили параметри кешування у налаштуваннях свого 
браузера. Кеш браузера містить усі документи, завантажені користувачем HTTP. Він використовується для доступу до раніше 
завантажених сторінок під час навігації назад/вперед, дозволяє зберігати сторінки або переглядати їх код, не звертаючись
зайвий раз до сервера. Крім того, такий кеш корисний при відключенні від мережі.

#### 11.1.2 Спільний кеш

Кеш спільного використання - це кеш, який зберігає відповіді, щоб їх потім могли використовувати різні користувачі. 
Наприклад, у локальній мережі вашого провайдера або компанії може бути встановлений проксі, який обслуговує безліч 
користувачів, щоб можна було повторно використовувати популярні ресурси, скорочуючи тим самим мережевий трафік і час 
очікування.

### 11.2 Цілі кешування

Кешування в HTTP не є обов'язковим, проте в більшості випадків корисно повторно використовувати раніше збережені 
ресурси. Тим не менш, стандартні кеші HTTP зазвичай здатні кешувати лише відповіді на запити методом [`GET`](#22-get), 
інші відхиляють.

Первинний ключ складається з методу запиту та запитуваного URI (часто використовується лише URI, оскільки метою 
кешування є лише [`GET`](#22-get)-запити). Ось приклади того, що зазвичай записується в кеш:

- Успішно завантажені ресурси: відповідь `200 OK` на запит методом [`GET`](#22-get) HTML-документів, зображень чи файлів.
- Постійні перенаправлення: відповідь `301 Moved Permanently` (переміщено назавжди).
- Повідомлення про помилки: відповідь `404 Not Found` (не знайдено).
- Неповні результати: відповідь `206 Partial Content` (частковий вміст).
- Відповіді на запити відмінні від [`GET`](#22-get), якщо є щось, що підходить для використання як ключ кеша.

*Джерело:* https://developer.mozilla.org/ru/docs/Web/HTTP/Caching

### 11.3 Управління кешом

#### 11.3.1 Заголовок Cache-control

Поле Cache-Control загального заголовка HTTP/1.1 використовується для завдання інструкцій з механізму кешування як у 
запитах, так і у відповіді. Застосовується для завдання політик кешування.

#### 11.3.2 Повна відсутність кешування
У кеші не повинно зберігатися нічого – ні за запитами клієнта, ні за відповідями сервера. Запит завжди надсилається на 
сервер, відповідь завжди завантажується повністю.

```
Cache-Control: no-store
```

#### 11.3.3 Кешувати, але перевіряти актуальність
Перед тим, як віддати копію, кеш запитує вихідний сервер щодо актуальності ресурсу.

```
Cache-Control: no-cache
```

#### 11.3.4 Приватні (private) та спільні (public) кеші
Директива "public" вказує, що відповідь можна зберігати у будь-якому кеші. Це буває корисно, якщо виникає потреба 
зберегти сторінки з автентифікацією HTTP, або такими кодами відповіді, які зазвичай не кешуються. Директива "private" 
вказує, що відповідь призначена окремому користувачеві і не повинна зберігатися в кеші спільного використання. У цьому 
випадку відповідь може зберігатись приватним кешем клієнта.

```
Cache-Control: private
Cache-Control: public
```

#### 11.3.5 Термін дії (Expiration)
Найважливішою тут є директива "max-age=<seconds>" - максимальний час, протягом якого ресурс вважається "свіжим". 
На відміну від директиви `Expires` вона прив'язана до моменту запиту.

```
Cache-Control: max-age=31536000
```

#### 11.3.6 Перевірка актуальності
При використанні директиви "must-revalidate" кеш зобов'язаний перевіряти статус ресурсів зі строком дії, що минув. 
Ті копії, що втратили актуальність, не повинні використовуватися. 

Докладніше про це можна почитати [тут](https://developer.mozilla.org/ru/docs/Web/HTTP/Caching#%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%86%D0%B8%D1%8F_%D0%BA%D0%B5%D1%88%D0%B0).

```
Cache-Control: must-revalidate
```

#### 11.3.7 Дерево прийняття рішеннь

У наступній схемі показано дерево рішень для налаштування кешування для певного ресурсу:

![http cache decision tree](img/specification/cache-decision-tree.jpg)

### 11.4 Умовні запити

Умовні запити – це запити, у яких клієнт може запитати сервер, чи є у нього оновлена копія ресурсу. Клієнт надішле деяку 
інформацію про кешований ресурс, який він зберігає, і сервер визначить, чи потрібно повертати оновлений вміст, чи копія 
клієнта вже оновлена. В останньому випадку повертається статус HTTP `304 Not Modified`.

![conditional request](img/specification/conditional-request.jpg)

Хоча умовні запити дійсно викликають виклик у мережі, незмінені ресурси призводять до порожнього тіла відповіді, 
заощаджуючи витрати на передачу ресурсу назад кінцевому клієнту. Сервер також часто може дуже швидко визначити останню 
версію або дату модифікації ресурсу без доступу до ресурсу, що само по собі економить час обробки.

Є два види умовних запитів

#### 11.4.1 Time-based

Умовний запит на основі часу базується на часі останньої зміни ресурсу. Якщо час останньої модифікації кешованої копії 
все ще є останнім, сервер повертає код відповіді 304. Щоб використовувати умовні запити на основі часу, сервер вказує 
час останньої зміни ресурсу через заголовок відповіді Last-Modified.

```
Last-Modified: Mon, 03 Jan 2011 17:45:57 GMT
```

Наступного разу, коли клієнт запитує цей ресурс, він запитуватиме лише вміст ресурсу, якщо той не змінився з цієї дати. 
Для цього використовується заголовок запиту If-Modified-Since

```
If-Modified-Since: Mon, 03 Jan 2011 17:45:57 GMT
```

Якщо ресурс не змінився з понеділка, 3 січня 2011 р., 17:45:57 GMT, сервер повернеться з порожнім тілом із кодом 
відповіді 304.

*Првило*

> Заголовок Last-Modified не підтримує досекундну точність, що може призвести до неправильних звернень до кешу, якщо є
> два оновлення протягом секунди.
>
> Через це **СЛІД** надавати перевагу ETag над заголовком Last-Modified.

#### 11.4.2 Content-based

ETag (або Entity Tag) працює подібно до заголовка Last-Modified, за винятком того, що його значення є тегом довільної 
форми, що ідентифікує версію ресурсу. Дійсні ETags можуть бути хешем MD5, номером версії або міткою часу модифікації, 
що забезпечує більшу точність, ніж при використанні заголовка Last-Modified.

Серовер разом з відповіддю надсилає тег останньої версії ресурсу.
```
ETag: "15f0fff99ed5aae4edffdd6496d7131f"
```

У наступних запитах клієнта заголовок запиту If-None-Match надсилається зі значенням ETag останньої запитуваної версії 
ресурсу.

```
If-None-Match: "15f0fff99ed5aae4edffdd6496d7131f"
```

Як і у випадку з заголовком If-Modified-Since, якщо поточна версія має те саме значення ETag, що й кешована копія 
клієнта, тоді повертається статус HTTP 304.