# Правила создание openapi манифеста
Генераторы заточены под версию openapi **3.0.0** по этому использование других версий не поддерживается.
Для ознакомления с документацией swagger (openapi) перейдите по [ссылке](https://swagger.io/docs/).   

## Блоки манифеста
Пример манифеста вы можете посмотреть [здесь](../openapi-hello-user.yaml). Описание блоков будет базироваться на манифесте с примера.

Манифест разделен на несколько логических блоков:
 * **openapi** - здесь нужно указать версию
 
   ``openapi: 3.0.0``, всегда нужно указывать версию 3.0.0 так как другая не поддерживается
 * **info** - здесь нужно указать общую информацию об апи. Например название, версию, описание и т.д.
   ```
   info:
     version: "1"
     title: HelloUser
   ```
   генератор использует version и title в кодогенерации. title используется как имя модуля, а версия как версия. То есть если в генераторе будет указано то что в примере, то файлы будут в ```src/HelloUser/src/OpenAPI/V1/```, неймспейс будет строиться по этому же принципу. 
 * **servers** - здесь нужно указать сервера (hosts)
   ```
   servers:
     - url: http://HOSTNAME/openapi/HelloUser/v1 
   ``` 
   данный параметр используется генератором для определения полного пути. Если рассматривать с точки зрения клиентского кода то этот параметр определяет куда можно отправлять, а если з точки зрения серверной части то по какому пути будут доступны ваши обработчики. Более детально про возможности можете прочесть [здесь](https://swagger.io/docs/specification/api-host-and-base-path/). Так же, по умолчанию в сгенерированом коде, запрос отправляется на первый хост - [пример](https://github.com/rollun-com/rollun-openapi/blob/410ee5877698daf189d49499011bb607000b096b/src/HelloUser/src/OpenAPI/V1/Client/Api/HelloApi.php#L87).
индекс пробрасывается из Rest директории. Что бы кастомизировать создание сервиса, нужно перекрыть метод createApi из BaseAbstract класса.
 * **tags** - здесь нужно указать метки, условное группирование методов по определенному признаку. **ВАЖНО** Теги должны называтся с большой буквы, для корректной генерации названий фалов и классов.
   ```
   tags:
     - name: User
     - name: Hello
   ```  
   как видно я указал при помощи тегов, что все пути буду разделены на две группы: User, Hello. Это очень важный параметр так как при помощи меток генератор определяет какие имена будут у классов которые он создаст. 
 * **paths** - здесь нужно указать все пути на которые будет возможность отправлять запросы, и получать ответы.
   ```
   paths:
     /User:
       post:
         tags:
           - User
         responses:
           '201':
             description: Created
             content:
               application/json:
                 schema:
                   $ref: '#/components/schemas/UserResult'
           '400':
             description: Bad Request
             content:
               application/json:
                 schema:
                   $ref: '#/components/schemas/ErrorResult'
           '500':
             description: Internal error
             content:
               application/json:
                 schema:
                   $ref: '#/components/schemas/ErrorResult'
         requestBody:
           required: true
           content:
             application/json:
               schema:
                 $ref: '#/components/schemas/User'
   ``` 
   как видно здесь мы указываем путь на который есть возможность отправлять запрос. Также мы указываем метки к которым относиться путь. Важно указывать только одну метку так как в ином случае возникнет путаница, генератор создаст несколько классов который будут обрабатывать один и тот же путь. Описывая путь нужно указывать HTTP методы которые возможны для конкретного пути. В примере мы показали что для ```/User``` возможен только HTTP POST метод. Также нужно описать запрос и ответы. Важно при описании тела запроса или ответа, всегда использовать ссылки на схемы, точно так как в примере. Генератор создает DTO объекты на базе описанных вами схем с теми же именами. В случае если вы не будете ссылаться на схемы, а просто опишете объект, то генератор создаст DTO объекты с техническими названиями, что не удобно в дальнейшем использовании.
 * **components** - здесь нужно указать дополнительные компоненты на которые будут ссылаться path.
   ```
   components:
     schemas:
       Message:
         type: object
         required:
           - level
           - text
         properties:
           level:
             type: string
             description: 'Message level  (like in a logger)'
             example: 'error'
           text:
             type: string
             description: 'Message text'
             example: 'Something wrong.'
           context:
             type: array
             description: 'Message context (like in a logger)'
             items:
               type: string
   ```
   как видно здесь мы описали объект Message со всеми его полями. Генератор создаст DTO объект Message где будут указаны все поля описанные здесь, а также в классе будет описана валидация, которая также будет создана согласно описанного в манифесте.  

## Структура представлення ресурсу

### Структура ресурсу відповіді (response)

Структура відповіді повинна наслідувати поля від openapi компонента ErrorResponse - якщо виникла
помилка, SuccessResponse - у разі успішної відповіді.

```yaml
ErrorResponse:
    type: object
    properties:
        messages:
            type: array
            items:
                $ref: "#/components/schemas/Message"
            description:
    description: >
        Список повідомлень про виконання запиту: помилки, попередження, або інша корисна для клієнта інформація.
Message:
    type: object
    properties:
        level:
            type: string
            enum: [ `emergency`, `alert`, `critical`, `error`, `warning`, `notice`, `info` ]
        type:
            type: string
            enum:
                - UNDEFINED
            description: >
                Тип повідомлення для зручного розрізняння помилки клієнтською програмою.
                Назви типів повинні бути у верхньому регістрі, а слова розділені нижнім 
                підкреслюванням '_' (e.g. VALIDATION_ERROR).
                UNDEFINED - тип за замовчуванням
        text:
            type: string
            description: довільний текст з поясненням для людини
SuccessResponse:
    allOf:
        -   $ref: '#/components/schemas/ErrorResponse'
    type: object
    properties:
        data:
            description: >
                Корисна інформація про стан ресурсу, або колекції ресурсів. Стан ресурсу описується набором полей 
                об'єкту, або примитивом (рядок, число і т.п.).
```

> Поле 'data' фактично може бути якого завгодно типу, але генератор поки не підтримує поля у яких не об'явлений тип,
> тому зазвичай тип поля 'data' в маніфесті ставиться 'object'. Але він може бути змінений у об'єкті нащадку.
>```yaml
>SuccessResponse:
>  allOf:
>    - $ref: '#/components/schemas/ErrorResponse'
>  type: object
>  properties:
>    data:
>      type: object
>ResourceResponse:
>  allOf:
>    - $ref: '#/components/schemas/SuccessResult'
>  type: object
>  properties:
>    data:
>      type: string
>```

> Об'єкти, що об'явлені без жодного properties не підтримуються php генератором. Тож їх використання не рекомендується.

У відповіді **ПОВИННО** бути присутнім одне з полів: 'data', або 'messages'.

> Компоненти вище описані для openapi специфікації версії '3.0.0'. Згідно якої, якщо не вказано, що поле обов'язкове
> (його немає у масиві required), то цей ключ може бути відсутній у компоненті. Тобто у специфікації вище фактично
> дозволяється повернути пусту відповідь ('{}'). Тому ми накладаємо додаткові обмеження.

Якщо у відповіді відсутній ключ `data` (або його значення null), то у messages **РЕКОМЕНДУЄТЬСЯ** наявність, як мінімум,
одного повідомлення з `level` рівним `error` або вище.

> Рівні сортируются у порядку спадання наступним чином: `emergency`, `alert`, `critical`, `error`, `warning`, `notice`,
> `info`

> Фактично за схемою поле 'data' не може мати значення null, але через помилку у старих версіях php генератора немає
> можливості зовсім не повернути поле 'data' і воно повертається зі значенням 'null'. Після того як усі програми
> перейдуть на нову версію генератора і виправлять помилку, то умову про 'null' можна буде прибрати.

```json5
{
  "messages": [
    // оскільки `data` відсутня, то хоча б одна помилка (повідомлення з рівнем 'error' або вище) повинна бути присутня
    {
      "type": "VALIDATION_ERROR",
      "level": "error",
      "text": "Track number has wrong format."
    }
  ]
}
```

Якщо `data` і `messages` одночасно присутні у відповіді, то `messages` **НЕ ПОВИНЕН** містити повідомлень з рівнем вище
ніж warning.

```json5
{
  "data": {
    "id": "...",
    "trackNumber": "...",
    "shippingMethod": "FedEx 2Day",
    "estimateDeliveryDate": null
  },
  "messages": [
    {
      "type": "NO_SHIPPING_ESTIMATES",
      "level": "warning",
      // не може бути error тому що `data` не пуста 
      "text": "No rules found to calculate estimates for 'FedEx 2Day'."
    }
  ]
}
```

### Наявність ідентифікатора

При використанні REST стилю серед корисних даних ресурсу перелічених у `data` **ПОВИННО** бути поле з ідентифікатором.
За замовчуванням назва поля `id`. Це потрібно для однозначної ідентифікації кожного окремого елементу з колекції, а
також його кешування.

Наприклад нам потрібно виводити на сайті інформацію про кількість оформлених замовлень на різних маркетплейсах за певний
період часу. Для цього ми можемо використати ресурс `/statistcs/created_orders` в query якого вказувати період. В такому
випадку ідентифікатором може бути об'єднання інформації про приналежність статистики до певного маркетплейса, і періоду
за який надається статистика.

```http request
GET /statistcs/created_orders?from=2022-05-18T12:00:00Z&to=2022-05-18T13:00:00Z

// Response
{ 
 "data": [ 
   {
     "id": "Ebay | 2022-05-18T12:00:00Z | 2022-05-18T13:00:00Z", 
     "marketplace": "Ebay",
     "created_orders": 25 
   },
   {
     "id": "Amazon | 2022-05-18T12:00:00Z | 2022-05-18T13:00:00Z", 
     "marketplace": "Amazon",
     "created_orders": 10 
   }
 ] 
}
```

```http request
GET /statistcs/created_orders/Ebay | 2022-05-18T12:00:00Z | 2022-05-18T13:00:00Z

// Response
{ 
 "data": { 
   "id": "Ebay | 2022-05-18T12:00:00Z | 2022-05-18T13:00:00Z", 
   "marketplace": "Ebay",
   "created_orders": 25 
 } 
}
```

## Ідемпотентність

В специфікації http усі методи, окрім POST - є ідемпотентними. Це означає, що виконання методу кілька разів поспіль з
однаковими параметрами приводить до однакового результату. Для клієнта це означає, що він може безпечно повторити запит,
якщо не отримав відповіді від сервера.

Ця специфікація додає додаткове обмеження: POST **ПОВИНЕН** бути ідемпотентним за допомогою механізму
описаного нижче.

Розглянемо що це означає на практиці для кожного методу.

### GET

GET - не повинен виконувати ніяких дії над ресурсом, він лише повертає стан ресурсу у конкретний момент часу. Це
означає,
що ми можемо безпечно виконувати будь-яку кількість GET запитів до ресурсу і це не змінить його стан.

Важливо зазначити, що стан ресурсу може змінюватись сам по собі, або внаслідок запитів від інших клієнтів. Тому два GET
запити, виконані один за одним, можуть повернути різний стан ресурсу. Це не є порушенням ідемпотентності, адже стан
ресурсу не внаслідок GET запиту.

### POST

Як згадувалось раніше в http специфікації POST - не ідемпотентний. Це означає, що два однакових POST запита створять два
однакових ресурса.
У цих ресурсів можуть відрізнятись ідентифікатори, якщо ідентифікатор генерується серверною стороною, а не передається
від клієнта у запиті, разом з іншими відомостями про ресурс.

Оскільки взаємодія через мережу є ненадійною і дані можуть втрачатись, то може виникнути ситуація, коли клієнт надіслав
POST запит і не отримав відповіді від сервера. У цьому випадку клієнт ніяк не може дізнатись який з двух випадків
відбувся:

1. Запит від клієнта не дійшов до сервера і ресурс не був створений.
2. Запит дійшов до сервера і ресурс був створений, але відповідь від сервера не дійшла до клієнта.

Тобто фактично, надіславши POST запит і не отримавши відповіді клієнт не знає чи ресурс був створений. Повторно
надіслати ще один POST - небезпечно, оскільки може створитись дублікат ресурсу.

Для того, щоб розв'язувати проблему описану вище POST запит роблять ідемпотентним. Для цього клієнт до ресурсу додає
'idempotencyKey', який має бути однаковим для двух однакових ресурсів. Сервер, коли отримує POST запит перевіряє, чи
існує ресурс з переданим 'idempotencyKey', якщо ні - то створює його, якщо так, то не створює новий, а повертає у
відповіді вже створений. Таким чином клієнт може у разі чого повторно надіслати POST запит і не хвилюватись, що
буде створений дублікат ресурсу.

### PUT та PATCH

TODO

### DELETE

DELETE являється ідемпотентним оскільки не важливо скільки запитів на видалення ресурсу ми відправимо - у результаті
ресурс буде видаленим.

Якщо відправити два однакових DELETE запита, то перший видалить ресурс, а другий нічого не
зробить, але у результаті зо після першого, що після другого запиту ресурс залишиться видаленим.